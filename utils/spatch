#!/bin/sh
# shellcheck disable=SC2030
# shellcheck disable=SC2031
# shellcheck disable=SC2048
# shellcheck disable=SC2086
# shellcheck disable=SC2181
# shellcheck disable=SC2254

: <<'notice'
 * SPDX-License-Identifier: GPL-3.0
 *
 * Copyright (C) 2020-2021 Dimitar Yurukov <mscalindt@protonmail.com>
 *
notice

usage() {
printf "%s" "\
Usage: spatch [options] [--] FILE
Sort commit/patch URLs by date.

Options:
  -d, --direct-url           assume URLs are valid patch links even if they do
                             not end with .patch
  -i, --invert-sort          sort from newest to oldest
  -l, --line-numbers         append line numbers to the sort output
  -o, --output=PATH          PATH is an absolute or relative location to which
                             the sort output shall be written
  -p, --preserve-url         preserve the URLs
  -t, --timestamp            append timestamp to the sort output
  -v, --verbose              show additional information unrelated to the sort
                             output
      --help     display this help text and exit
      --         specify end of options

External utilities dependency list:
awk, curl, date, rm, sort.
"
}

# Description:
# Check command availability
#
# Parameters:
# <$1> - command
#
# Returns:
# (0) if command available,
# (127) if not
#
cmd_avail() {
    if command -v $1 > /dev/null 2>&1; then
        return 0
    fi

    return 127
}

# Description:
# Print error and exit
#
# Parameters:
# <"$1"> - text
# <$2> - exit code
#
err() {
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$1" 1>&2
    exit $2
}

# Description:
# Count files and directories in a directory
#
# Parameters:
# <"$1"> - directory
# ['$2'] - mode('0X' - count files and directories ending with "X",
#               '1' - count only files,
#               '1X' - count only files ending with "X",
#               '2' - count only directories,
#               '2X' - count only directories ending with "X")
#
# Returns:
# (0) count
# (1) directory is empty
#
fcount() {
    i=$(printf "%s" "$1")

    if [ $# -eq 2 ]; then
        case "$2" in
            "0"*)
                ii=$(printf "%s" "${2#0}")
                set -- "$i"/*"$ii" && iii="$1" && ii=$#
            ;;
            "1")
                set -- "$i"/* && iii="$1" && ii=$#
                set -- "$i"/*/ && i=$# && ii=$((ii - i))
            ;;
            "1"*)
                ii=$(printf "%s" "${2#1}")
                set -- "$i"/*"$ii" && iii="$1" && iiii=$#
                set -- "$i"/*"$ii"/ && i=$# && ii=$((iiii - i))
            ;;
            "2")
                set -- "$i"/*/ && iii="$1" && ii=$#
            ;;
            "2"*)
                ii=$(printf "%s" "${2#2}")
                set -- "$i"/*"$ii"/ && iii="$1" && ii=$#
            ;;
        esac
    else
        set -- "$i"/* && iii="$1" && ii=$#
    fi

    if [ -e "$iii" ]; then
        printf "%d" "${ii}"
        return 0
    fi

    printf "0" && return 1
}

# Description:
# Convert relative path to absolute path
#
# Parameters:
# <"$1"> - path
#
# Returns:
# $PWD/$1,
# $1
#
get_fpath() {
    case "$1" in
        "/"*) ;;
        *) i=$(printf "%s/%s" "$PWD" "$1") && set -- "$i" ;;
    esac

    printf "%s" "$1"
}

# Description:
# Check the existence/position of a substring in a string
#
# Parameters:
# <"$1"> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is the string on its own)
#
# Returns:
# (0) substring exists
# (1) no substring
#
grep_str() {
    if [ $# -eq 3 ]; then
        if [ $3 -eq 1 ]; then
            case "$2" in
                "$1"*) grepstr=0 && return 0 ;;
            esac
        elif [ $3 -eq 2 ]; then
            case "$2" in
                *"$1") grepstr=0 && return 0 ;;
            esac
        elif [ $3 -eq 3 ]; then
            case "$2" in
                "$1") grepstr=0 && return 0 ;;
            esac
        fi
    else
        case "$2" in
            *"$1"*) grepstr=0 && return 0 ;;
        esac
    fi

    return 1
}

# Description:
# Add a command to the hash table
#
# Parameters:
# <$1> - command
#
# Returns:
# (0) success
# (127) command does not exist
#
hash_cmd() {
    if hash $1 > /dev/null 2>&1; then
        return 0
    fi

    return 127
}

# Description:
# Print info
#
# Parameters:
# <"$1"> - text
#
info() {
    printf "%bINFO:%b %s\n" "\033[1;37m" "\033[0m" "$1"
}

# Description:
# Parse the content of stdin/file
#
# Parameters:
# <$1> - mode('1' - one-to-one copy,
#             '2' - wrap parsed lines in one leading/trailing whitespace char,
#             '3' - wrap parsed lines in two leading/trailing whitespace chars,
#             '4' - skip empty lines,
#             '5' - strip trailing/leading whitespace chars)
# ["$2"] - file
#
# Returns:
# (0) output | empty output (stdin/file)
# (1) file does not exist | file permission error
#
parse() {
    if [ $# -eq 2 ]; then
        i=$(
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf -- "%s\n" "${LINE}"
            done < "$2"
        )
    else
        i=$(
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf -- "%s\n" "${LINE}"
            done
        )
    fi

    case $1 in
        "1")
            printf "%s\n" "$i" | while IFS= read -r LINE; do
                printf -- "%s\n" "${LINE}"
            done
        ;;
        "2")
            printf "%s\n" "$i" | while read -r LINE; do
                printf -- " %s \n" "${LINE}"
            done
        ;;
        "3")
            printf "%s\n" "$i" | while read -r LINE; do
                printf -- "  %s  \n" "${LINE}"
            done
        ;;
        "4")
            printf "%s\n" "$i" | while IFS= read -r LINE; do
                if [ -n "$LINE" ]; then printf -- "%s\n" "${LINE}"; fi
            done
        ;;
        "5")
            printf "%s\n" "$i" | while read -r LINE; do
                printf -- "%s\n" "${LINE}"
            done
        ;;
    esac

    return $?
}

# Description:
# Print specific line in stdin/file
#
# Parameters:
# <$1> - line number
# ["$2"] - file
#
# Returns:
# (0) line's content
# (1) line empty | line does not exist | file permission error
#
pline() {
    x=0

    if [ $# -eq 2 ]; then
        i=$(
            while read -r LINE || [ -n "$LINE" ]; do
                printf -- "%s\n" "${LINE}"
            done < "$2"
        )
    else
        i=$(
            while read -r LINE || [ -n "$LINE" ]; do
                printf -- "%s\n" "${LINE}"
            done
        )
    fi

    printf "%s\n" "$i" | while read -r LINE; do
        x=$((x + 1))
        if [ $x -eq $1 ]; then
            printf -- "%s" "${LINE}" && return 0
        fi
    done

    return 1
}

# Description:
# Remove specific character(s) in a string
#
# Parameters:
# <"$1"> - character(s)
# <"$2"> - string
#
# Returns:
# $2 without $1 characters,
# $2
#
remchars() {
    i=$IFS

    IFS=$1
    set -- $2

    IFS=""
    set -- $*

    printf "%s\n" "$*"

    IFS=$i
}

# Description:
# Get substring after (from / up to) specific (N)character(s) in a string
#
# Parameters:
# [$1] - from left to right N $2 character(s)
# <"$2"> - from character(s)
# [$3] - up to N $4 character(s)
# ["$4"] - up to character(s)
# <"$5"> - string
#
# Returns:
# (0) substring of $5 | undefined behaviour if $2/$4 not present
# (1) undefined behaviour
#
substr_after() {
    x=0

    if [ $# -eq 5 ]; then
        i=$(printf "%s" "$5")
        until [ $x -eq $1 ]; do
            i=$(printf "%s" "${i#*$2}")
            x=$((x + 1))
        done
        x=0
        ii="$i"
        until [ $x -eq $3 ]; do
            i=$(printf "%s" "${i#*$4}")
            x=$((x + 1))
        done
        i=$(printf "%s" "${ii%$i}")
    elif [ $# -eq 4 ]; then
        i=$(printf "%s" "$4")
        case "$1" in
            '' | *[!0-9]*)
                i=$(printf "%s" "${i##*$1}")
                ii="$i"
                until [ $x -eq $2 ]; do
                    i=$(printf "%s" "${i#*$3}")
                    x=$((x + 1))
                done
                i=$(printf "%s" "${ii%$i}")
            ;;
            *)
                until [ $x -eq $1 ]; do
                    i=$(printf "%s" "${i#*$2}")
                    x=$((x + 1))
                done
                ii="$i"
                i=$(printf "%s" "${i##*$3}")
                i=$(printf "%s" "${ii%$i}")
            ;;
        esac
    elif [ $# -eq 3 ]; then
        i=$(printf "%s" "$3")
        case "$1" in
            '' | *[!0-9]*)
                i=$(printf "%s" "${i##*$1}")
                ii="$i"
                i=$(printf "%s" "${i##*$2}")
                i=$(printf "%s" "${ii%$i}")
            ;;
            *)
                until [ $x -eq $1 ]; do
                    i=$(printf "%s" "${i#*$2}")
                    x=$((x + 1))
                done
            ;;
        esac
    else
        i=$(printf "%s" "${2##*$1}")
    fi

    if [ -n "$i" ]; then
        case "$i" in
            " "*) i=$(printf "%s" "${i# }") ;;
        esac
        case "$i" in
            *" ") i=$(printf "%s" "${i% }") ;;
        esac

        printf "%s" "${i}"
        return 0
    fi

    return 1
}

# Description:
# Get substring before (from / back to) specific (N)character(s) in a string
#
# Parameters:
# [$1] - from left to right N $2 character(s)
# <"$2"> - from character(s)
# [$3] - back to N $4 character(s)
# ["$4"] - back to character(s)
# <"$5"> - string
#
# Returns:
# (0) substring of $5 | undefined behaviour if $2/$4 not present
# (1) undefined behaviour
#
substr_before() {
    x=0

    if [ $# -eq 5 ]; then
        i=$(printf "%s" "$5")
        ii="$i"
        until [ $x -eq $1 ]; do
            i=$(printf "%s" "${i#*$2}")
            x=$((x + 1))
        done
        i=$(printf "%s" "${ii%$i}")
        x=0
        ii="$i"
        until [ $x -eq $3 ]; do
            i=$(printf "%s" "${i%$4*}")
            x=$((x + 1))
        done
        i=$(printf "%s" "${ii#*$i}")
    elif [ $# -eq 4 ]; then
        i=$(printf "%s" "$4")
        case "$1" in
            '' | *[!0-9]*)
                ii="$i"
                i=$(printf "%s" "${i##*$1}")
                i=$(printf "%s" "${ii%$i}")
                ii="$i"
                until [ $x -eq $2 ]; do
                    i=$(printf "%s" "${i%$3*}")
                    x=$((x + 1))
                done
                i=$(printf "%s" "${ii#*$i}")
            ;;
            *)
                ii="$i"
                until [ $x -eq $1 ]; do
                    i=$(printf "%s" "${i#*$2}")
                    x=$((x + 1))
                done
                i=$(printf "%s" "${ii%$i}")
                ii="$i"
                i=$(printf "%s" "${i%%$3*}")
                i=$(printf "%s" "${ii#*$i}")
            ;;
        esac
    elif [ $# -eq 3 ]; then
        i=$(printf "%s" "$3")
        case "$1" in
            '' | *[!0-9]*)
                ii="$i"
                i=$(printf "%s" "${i##*$1}")
                i=$(printf "%s" "${ii%$i}")
                ii="$i"
                i=$(printf "%s" "${i%%$2*}")
                i=$(printf "%s" "${ii#*$i}")
            ;;
            *)
                ii="$i"
                until [ $x -eq $1 ]; do
                    i=$(printf "%s" "${i#*$2}")
                    x=$((x + 1))
                done
                i=$(printf "%s" "${ii%$i}")
            ;;
        esac
    else
        i=$(printf "%s" "${2%$1*}")
    fi

    if [ -n "$i" ]; then
        case "$i" in
            " "*) i=$(printf "%s" "${i# }") ;;
        esac
        case "$i" in
            *" ") i=$(printf "%s" "${i% }") ;;
        esac

        printf "%s" "${i}"
        return 0
    fi

    return 1
}

# Description:
# Print a warning
#
# Parameters:
# <"$1"> - text
#
warn() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$1"
}

spatch_env() {
    FILE="$1"
}

spatch_check() {
    if [ ! -f "$FILE" ]; then
        err "'$FILE' is not a file." 1
    fi
}

spatch_work() {
    TMP_DIR=/tmp

    if cmd_avail curl; then
        URL_TOOL='curl'
        URL_TOOL_ARGS='-Of'
    elif cmd_avail aria2c; then
        URL_TOOL='aria2c'
        URL_TOOL_ARGS=''
    elif cmd_avail wget; then
        URL_TOOL='wget'
        URL_TOOL_ARGS=''
    elif cmd_avail axel; then
        URL_TOOL='axel'
        URL_TOOL_ARGS=''
    else
        err "No URL download tool available. (curl/aria2/wget/axel)" 127
    fi
    hash_cmd $URL_TOOL

    rm -f "$TMP_DIR"/*.patch
    cd "$TMP_DIR" || err "Line '$LINENO' failed." 1
}

spatch_exec() {
    while read -r LINE || [ -n "$LINE" ]; do
        if ! grep_str "://" " $LINE "; then
            if [ -n "$LINE" ] && [ -n "$verbose" ]; then
                warn "'$LINE' has no URL. (*://*)"
            fi
            continue
        fi

        TMP=$(substr_before "://" 1 " " " $LINE ")
        URL=$(substr_after "://" 1 " " " $LINE ")
        URL=$(printf "%s%s" "${TMP}" "${URL}")

        if [ -z $durl ]; then
            if ! grep_str ".patch" "$URL"; then
                URL=${URL}.patch
            fi
        fi

        if [ -n "$verbose" ]; then
            NUM=$((1 + CNT))
            CNT=$NUM
            info "URL ($NUM) - '$URL'."
        fi

        $URL_TOOL ${URL_TOOL_ARGS} $URL > /dev/null 2>&1 &
    done < "$FILE"; wait && if [ -n "$verbose" ]; then unset CNT; fi

    if ! fcount "$TMP_DIR" '1.patch' > /dev/null 2>&1; then
        spatch_post;
        err "No patches found." 1
    else
        FILE=$(
            for PATCH in "$TMP_DIR"/*.patch; do
                CSTR=$(pline 1 "$PATCH")
                CSTR=$(substr_after 1 " " 1 " " "$CSTR")
                DSTR=$(pline 3 "$PATCH")
                DSTR=$(substr_after 2 " " 4 " " "$DSTR")

                if [ -n "$purl" ]; then
                    TMP=$(parse 3 "$FILE")
                    CSTR=$(substr_before "$CSTR" 1 " " "$TMP")
                fi

                echo "$CSTR $DSTR"
            done
        )
    fi

    FILE=$(printf "%s" "$FILE" | sort -t " " -k4.1,4.4 -k3.1,3.3M -k2.1n \
                                             -k5.1,5.2 -k5.4,5.5 -k5.7,5.8)

    if [ -n "$invert" ]; then
        FILE=$(printf "%s" "$FILE" | \
               awk '{a[i++]=$0;} END {for (j=i-1; j>=0;) print a[j--];}')
    fi

    if [ -n "$lnumbers" ]; then
        FILE=$(echo "$FILE" | \
            while read -r LINE; do
                NUM=$((1 + CNT))
                CNT=$NUM
                echo "$NUM - $LINE"
            done;
        )
    fi

    if [ -n "$tstamp" ]; then
        FILE=$(printf "%s\nTIMESTAMP: %s\n" "${FILE}" \
                      "$(date '+%b %-e, %T %:z %Y')")
    fi

    if [ -n "$tfile" ]; then
        echo "$FILE" > "$tfile"
    else
        echo "$FILE"
    fi
}

spatch_post() {
    rm -f "$TMP_DIR"/*.patch
}

spatch() {
    spatch_env "$1"
    spatch_check;
    spatch_work;
    spatch_exec;
    spatch_post;
}

main() {
    # For security reasons, unset conditional variables if they exist
    if [ -n "$CNT" ]; then unset CNT; fi
    if [ -n "$tfile" ]; then unset tfile; fi
    if [ -n "$durl" ]; then unset durl; fi
    if [ -n "$invert" ]; then unset invert; fi
    if [ -n "$lnumbers" ]; then unset lnumbers; fi
    if [ -n "$purl" ]; then unset purl; fi
    if [ -n "$tstamp" ]; then unset tstamp; fi
    if [ -n "$verbose" ]; then unset verbose; fi
    if [ -n "$RC" ]; then unset RC; fi

    # Serve the script until no script parameters passed
    while [ "$1" ]; do
        # Reset variables from previous loop run
        if [ -n "$grepstr" ]; then unset grepstr; fi

        case "$1" in
            # Parse specific options first
            "--") shift && break ;;
            "--help") usage && return 0 ;;

            # Parse options
            "--"*)
                i=$(substr_after 1 "--" "$1")

                if grep_str "output" "$i" 1; then
                    if grep_str "output=" "$i" 1; then
                        tfile=$(substr_after 1 "=" "$i")
                        tfile=$(get_fpath "$tfile")
                        shift && continue
                    elif ! grep_str "output " "$i " 1; then
                        tfile=$(substr_after 2 "t" "$i")
                        tfile=$(get_fpath "$tfile")
                        shift && continue
                    elif [ "$2" ]; then
                        tfile="$2"
                        tfile=$(get_fpath "$tfile")
                        shift 2 && continue
                    fi
                fi

                if grep_str "direct-url" "$i" 3; then durl=1; fi
                if grep_str "invert-sort" "$i" 3; then invert=1; fi
                if grep_str "line-numbers" "$i" 3; then lnumbers=1; fi
                if grep_str "preserve-url" "$i" 3; then purl=1; fi
                if grep_str "timestamp" "$i" 3; then tstamp=1; fi
                if grep_str "verbose" "$i" 3; then verbose=1; fi

                if [ ! $grepstr ]; then
                    warn "Unrecognized option: '$1'. See --help"
                fi
                shift
            ;;
            "-"*)
                i=$(substr_after 1 "-" "$1")

                if grep_str "o" "$i" 1; then
                    if grep_str "o=" "$i" 1; then
                        tfile=$(substr_after 1 "=" "$i")
                        tfile=$(get_fpath "$tfile")
                        shift && continue
                    elif ! grep_str "o " "$i " 1; then
                        tfile=$(substr_after 1 "o" "$i")
                        tfile=$(get_fpath "$tfile")
                        shift && continue
                    elif [ "$2" ]; then
                        tfile="$2"
                        tfile=$(get_fpath "$tfile")
                        shift 2 && continue
                    fi
                fi

                if grep_str "d" "$i"; then durl=1; fi
                if grep_str "i" "$i"; then invert=1; fi
                if grep_str "l" "$i"; then lnumbers=1; fi
                if grep_str "p" "$i"; then purl=1; fi
                if grep_str "t" "$i"; then tstamp=1; fi
                if grep_str "v" "$i"; then verbose=1; fi

                i=$(remchars "dilptv" "$i")
                if [ -n "$i" ]; then
                    warn "Unrecognized option(s): '-$i'. See --help"
                fi
                shift
            ;;

            *) break ;;
        esac
    done

    # Catch wrong input
    if [ ! "$1" ]; then
        err "No file specified." 2
    elif [ "$2" ]; then
        err "Too many operands. ($#)" 2
    fi

    # Convert relative path to absolute path
    TMP=$(get_fpath "$1")
    set -- "$TMP"

    # Execute the core function
    spatch "$1"

    # Check if RC is set, otherwise explicit success
    if [ -n "$RC" ]; then
        return $RC
    fi
    return 0
}

main "$@"
