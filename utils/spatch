#!/bin/sh
# SPDX-License-Identifier: GPL-3.0
# shellcheck disable=SC2030 # ShellCheck is wrong (on the intention)
# shellcheck disable=SC2031 # ShellCheck wrong parse order
# shellcheck disable=SC2048 # ShellCheck incorrect pedantic warning

_copyright() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'COPYRIGHT'
Copyright (C) 2020-2022 Dimitar Yurukov <mscalindt@protonmail.com>
COPYRIGHT
}

_description() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'DESCRIPTION'
Sort commit/patch URLs by date.
DESCRIPTION
}

_license() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'LICENSE'
License GPLv3: GNU GPL version 3
LICENSE
}

_misc() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'MISC'
The sort output, when '-o'/'--output' is not given, is written to file
descriptor 1; if file descriptor 3 is open, the sort output will be written
there as well.

External utilities hard dependency list:
curl, rm, sort.
External utilities soft dependency list:
awk, date.
MISC
}

_notice() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'NOTICE'
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
NOTICE
}

_options() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'OPTIONS'
Options:
  -d, --direct-url           assume URLs are valid patch links even if they do
                             not end with .patch
  -i, --invert-sort          sort from newest to oldest
  -l, --line-numbers         append line numbers to the sort output
      --no-color             colorless output on all streams
  -o, --output <PATH>        PATH is an absolute or relative location to which
                             the sort output shall be written; if the parent
                             does not exist, output will be written to stdout
  -p, --preserve-url         preserve the URLs
  -s, --short-commit         print a shorter SHA-1 (12 characters) of the
                             commits
  -t, --timestamp            append timestamp to the sort output
  -v, --verbose              show additional information unrelated to the sort
                             output
      --help     display this help text and exit
      --version  display version information and exit
      --         specify end of options
OPTIONS
}

_usage() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'USAGE'
Usage: spatch [options] [--] FILE
USAGE
}

_version() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'VERSION'
spatch 0.0.0
VERSION
}

usage() {
    _usage; _description; echo
    _options; echo
    _misc;
}

version() {
    _version; echo
    _copyright; echo
    _license; _notice;
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err() {
    i=$1 && shift
    printf "\nERROR: %s\n\n" "$*" 1>&2
    exit $i
}

# Description:
# Print colorful error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err_clr() {
    i=$1 && shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $i
}

# Description:
# Count files and directories in a directory
#
# Parameters:
# <"$1"> - directory
# ["$2"] - mode('0X' - count files and directories ending with "X",
#               '1' - count only files,
#               '1X' - count only files ending with "X",
#               '2' - count only directories,
#               '2X' - count only directories ending with "X")
# [$3] - mode('3' - exclude hidden files/directories)
#
# Returns:
# (0) count
# (1) not a directory | directory does not exist
#
# Caveats:
# 1. The number of files/directories the function (i.e. system) can process
#    varies. The files/directories are stored as arguments, which means that the
#    amount of things that can be processed depends on the system and version,
#    on the number of files and their respective argument size, and on the
#    number and size of environment variable names. For more information,
#    related limits shall be checked: ARG_MAX.
#    Fix: none; not applicable.
#
fcount() {
    [ -d "$1" ] && i="$1" || return 1
    iiii=0

    if [ $# -eq 1 ]; then
        set -- "$i"/*
        [ -e "$1" ] && iiii=$#

        set -- "$i"/.*
        [ $# -ge 3 ] && iiii=$((iiii + $# - 2))
    elif [ $# -eq 2 ] && [ "$2" = 3 ]; then
        set -- "$i"/*
        [ -e "$1" ] && iiii=$#
    elif [ $# -eq 3 ]; then
        case "$2" in
            0*)
                ii="${2#?}"

                set -- "$i"/*"$ii"
                [ -e "$1" ] && iiii=$#
            ;;
            1)
                set -- "$i"/*
                [ -e "$1" ] && iiii=$#

                set -- "$i"/*/
                [ -e "$1" ] && iiii=$((iiii - $#))
            ;;
            1*)
                ii="${2#?}"

                set -- "$i"/*"$ii"
                [ -e "$1" ] && iiii=$#

                set -- "$i"/*"$ii"/
                [ -e "$1" ] && iiii=$((iiii - $#))
            ;;
            2)
                set -- "$i"/*/
                [ -e "$1" ] && iiii=$#
            ;;
            2*)
                ii="${2#?}"

                set -- "$i"/*"$ii"/
                [ -e "$1" ] && iiii=$#
            ;;
        esac
    else
        case "$2" in
            0*)
                ii="${2#?}"

                set -- "$i"/*"$ii"
                [ -e "$1" ] && iiii=$#

                set -- "$i"/.*"$ii"
                case "$ii" in
                    ".") [ -e "$2" ] && iiii=$((iiii + $# - 1)) ;;
                    "..") [ -e "$1" ] && iiii=$((iiii + $#)) ;;
                    *)
                        [ -e "$i/$ii" ] && iiii=$((iiii + 1))
                        [ -e "$1" ] && iiii=$((iiii + $#))
                    ;;
                esac
            ;;
            1)
                set -- "$i"/*
                [ -e "$1" ] && iiii=$#

                set -- "$i"/*/
                [ -e "$1" ] && iiii=$((iiii - $#))

                set -- "$i"/.*
                [ -e "$3" ] && iiii=$((iiii + $# - 2))

                set -- "$i"/.*/
                [ -e "$3" ] && iiii=$((iiii - $# + 2))
            ;;
            1*)
                ii="${2#?}"

                [ -f "$i/$ii" ] && iiii=1

                set -- "$i"/*"$ii"
                [ -e "$1" ] && iiii=$((iiii + $#))

                set -- "$i"/.*"$ii"
                case "$ii" in
                    ".") [ -e "$2" ] && iiii=$((iiii + $# - 1)) ;;
                    *) [ -e "$1" ] && iiii=$((iiii + $#)) ;;
                esac

                set -- "$i"/.*"$ii"/
                case "$ii" in
                    ".") [ -e "$2" ] && iiii=$((iiii - $# + 1)) ;;
                    *) [ -e "$1" ] && iiii=$((iiii - $#)) ;;
                esac

                set -- "$i"/*"$ii"/
                [ -e "$1" ] && iiii=$((iiii - $#))
            ;;
            2)
                set -- "$i"/*/
                [ -e "$1" ] && iiii=$#

                set -- "$i"/.*/
                [ -e "$3" ] && iiii=$((iiii + $# - 2))
            ;;
            2*)
                ii="${2#?}"

                set -- "$i"/*"$ii"/
                [ -e "$1" ] && iiii=$#

                set -- "$i"/.*"$ii"/
                case "$ii" in
                    ".") [ -e "$2" ] && iiii=$((iiii + $# - 1)) ;;
                    "..") [ -e "$1" ] && iiii=$((iiii + $#)) ;;
                    *)
                        [ -d "$i/$ii" ] && iiii=$((iiii + 1))
                        [ -e "$1" ] && iiii=$((iiii + $#))
                    ;;
                esac
            ;;
        esac
    fi

    printf "%d" "$iiii" && return 0
}

# Description:
# Convert relative path to absolute path
#
# Parameters:
# <"$1"> - path
#
# Returns:
# (0) absolute path / path is already absolute
#
get_fpath() {
    case "$1" in
        "/"*) printf "%s" "$1" ;;
        *) printf "%s/%s" "$PWD" "$1" ;;
    esac

    return 0
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <"$1"> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is, on its own, $2)
#
# Returns:
# (0) substring exists
# (1) no match
#
grep_str() {
    if [ $# -eq 3 ]; then
        if [ $3 -eq 1 ]; then
            case "$2" in "$1"*) grep_str=0 && return 0 ;; esac
        elif [ $3 -eq 2 ]; then
            case "$2" in *"$1") grep_str=0 && return 0 ;; esac
        elif [ $3 -eq 3 ]; then
            case "$2" in "$1") grep_str=0 && return 0 ;; esac
        fi
    else
        case "$2" in *"$1"*) grep_str=0 && return 0 ;; esac
    fi

    return 1
}

# Description:
# Print info
#
# Parameters:
# <"$1"+> - text
#
info() {
    printf "INFO: %s\n" "$*"
}

# Description:
# Print colorful info
#
# Parameters:
# <"$1"+> - text
#
info_clr() {
    printf "%bINFO:%b %s\n" "\033[1;37m" "\033[0m" "$*"
}

# Description:
# Get positional substring, (from&to LTL) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <"$2"> - from "X" character(s)
# <$3> - to "N" $2-TL character('0' - max)
# <"$4"> - to "X" character(s)
# <"$5"> - string
# [$6] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$7] - mode('3' - keep $2,
#             '4' - keep $4,
#             '5' - keep $2/$4)
# [$8] - mode('6' - verify the expansion)
#
# Returns:
# (0) substring
# (1) empty expansion (empty, or unspecified, or wrong -- shell specific)
# (2) unspecified expansion (unspecified, or empty, or wrong -- shell specific)
#
# Returns (mode '6'):
# (0) substring
# (1) unspecified expansion ($2 is the first character by the given ruleset)
# (2) unspecified expansion ($2 is not present at all)
# (3) wrong expansion ($1 is greater than the total $2 in the string)
# (4) empty expansion (empty expansion by the given ruleset)
# (5) unspecified expansion ($4 is not present at all)
# (6) wrong expansion ($3 is greater than the total $4 in the string)
#
# Caveats:
# 1. If mode 6 is NOT passed, you should NOT assume the expansion is
#    respectively correct, even if the return code is 0. This is because every
#    shell has its own unique string expander and unspecified results will vary
#    between them; for example, if $2/$4 is not present anymore or at all, one
#    shell might return the same expansion, while another might return empty
#    expansion. Also, the string expander on its own does NOT guarantee correct
#    expansion at all.
#    Fix: Use mode '6'. When mode 6 is passed, the function will do various
#    checks on each expansion to accurately determine what the expansion will
#    result into; this guarantees respectively correct expansion on any shell.
#    Performance cost should be negligible on most shells.
#
ltl_substr1() {
    if [ $# -eq 8 ] || \
       [ $# -ge 7 ] && [ $7 -eq 6 ] || \
       [ $# -ge 6 ] && [ $6 -eq 6 ]; then
        case $1 in
            0)
                case "$5" in
                    *"$2"*"$2"*) : ;;
                    "$2"*) return 1 ;;
                    *"$2"*) : ;;
                    *) return 2 ;;
                esac

                i="${5%"$2"*}"
            ;;
            *)
                case $1"$5" in
                    1"$2"*) return 1 ;;
                    $1*"$2"*) : ;;
                    *) return 2 ;;
                esac

                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"

                    case "$i" in
                        *"$2"*) : ;;
                        *) [ $((x + 1)) -ne $1 ] && return 3 ;;
                    esac

                    x=$((x + 1))
                done
                [ -z "$i" ] && i="${5%"$2"}" || i="${5%"$2""$i"}"
            ;;
        esac

        case $3 in
            0)
                case "$i" in
                    *"$4"*"$4"*) : ;;
                    *"$4") return 4 ;;
                    *"$4"*) : ;;
                    *) return 5 ;;
                esac

                i="${i#*"$4"}"
            ;;
            *)
                case $3"$i" in
                    1*"$4") return 4 ;;
                    $3*"$4"*) : ;;
                    *) return 5 ;;
                esac

                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i%"$4"*}"

                    case "$i" in
                        *"$4"*) : ;;
                        *) [ $((x + 1)) -ne $3 ] && return 6 ;;
                    esac

                    x=$((x + 1))
                done
                [ -z "$i" ] && i="${ii#"$4"}" || i="${ii#"$i""$4"}"
            ;;
        esac
    else
        case $1 in
            0)
                i="${5%"$2"*}"
            ;;
            *)
                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"
                    x=$((x + 1))
                done
                i="${5%"$2""$i"}"
            ;;
        esac

        case $3 in
            0)
                i="${i#*"$4"}"
            ;;
            *)
                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i%"$4"*}"
                    x=$((x + 1))
                done
                i="${ii#"$i""$4"}"
            ;;
        esac

        [ "$i" = "$5" ] && return 2
    fi

    if [ -n "$i" ]; then
        if [ $# -ge 6 ] && [ $6 -eq 0 ]; then
            i="${i#${i%%[![:space:]]*}}"
        elif [ $# -ge 6 ] && [ $6 -eq 1 ]; then
            i="${i%${i##*[![:space:]]}}"
        elif [ $# -ge 6 ] && [ $6 -eq 2 ]; then
            i="${i#${i%%[![:space:]]*}}"
            i="${i%${i##*[![:space:]]}}"
        fi

        if [ $# -ge 7 ] && [ $7 -eq 3 ] || \
           [ $# -ge 6 ] && [ $6 -eq 3 ]; then
            i="$i$2"
        elif [ $# -ge 7 ] && [ $7 -eq 4 ] || \
             [ $# -ge 6 ] && [ $6 -eq 4 ]; then
            i="$4$i"
        elif [ $# -ge 7 ] && [ $7 -eq 5 ] || \
             [ $# -ge 6 ] && [ $6 -eq 5 ]; then
            i="$4$i$2"
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Get positional substring, (from&to LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <"$2"> - from "X" character(s)
# <$3> - to "N" $2-TR character('0' - max)
# <"$4"> - to "X" character(s)
# <"$5"> - string
# [$6] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$7] - mode('3' - keep $2,
#             '4' - keep $4,
#             '5' - keep $2/$4)
# [$8] - mode('6' - verify the expansion)
#
# Returns:
# (0) substring
# (1) empty expansion (empty, or unspecified, or wrong -- shell specific)
# (2) unspecified expansion (unspecified, or empty, or wrong -- shell specific)
#
# Returns (mode '6'):
# (0) substring
# (1) unspecified expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion ($2 is not present at all)
# (3) wrong expansion ($1 is greater than the total $2 in the string)
# (4) empty expansion (empty expansion by the given ruleset)
# (5) unspecified expansion ($4 is not present at all)
# (6) wrong expansion ($3 is greater than the total $4 in the string)
#
# Caveats:
# 1. If mode 6 is NOT passed, you should NOT assume the expansion is
#    respectively correct, even if the return code is 0. This is because every
#    shell has its own unique string expander and unspecified results will vary
#    between them; for example, if $2/$4 is not present anymore or at all, one
#    shell might return the same expansion, while another might return empty
#    expansion. Also, the string expander on its own does NOT guarantee correct
#    expansion at all.
#    Fix: Use mode '6'. When mode 6 is passed, the function will do various
#    checks on each expansion to accurately determine what the expansion will
#    result into; this guarantees respectively correct expansion on any shell.
#    Performance cost should be negligible on most shells.
#
ltr_substr1() {
    if [ $# -eq 8 ] || \
       [ $# -ge 7 ] && [ $7 -eq 6 ] || \
       [ $# -ge 6 ] && [ $6 -eq 6 ]; then
        case $1 in
            0)
                case "$5" in
                    *"$2") return 1 ;;
                    *"$2"*) : ;;
                    *) return 2 ;;
                esac

                i="${5##*"$2"}"
            ;;
            *)
                case $1"$5" in
                    $1*"$2"*"$2"*) : ;;
                    1*"$2") return 1 ;;
                    $1*"$2"*) : ;;
                    *) return 2 ;;
                esac

                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"

                    case "$i" in
                        *"$2"*"$2"*) : ;;
                        *"$2") [ $((x + 2)) -eq $1 ] && return 1 ;;
                        *"$2"*) : ;;
                        *) [ $((x + 1)) -ne $1 ] && return 3 ;;
                    esac

                    x=$((x + 1))
                done
            ;;
        esac

        case $3 in
            0)
                case "$i" in
                    *"$4"*"$4"*) : ;;
                    "$4"*) return 4 ;;
                    *"$4"*) : ;;
                    *) return 5 ;;
                esac

                i="${i%"$4"*}"
            ;;
            *)
                case $3"$i" in
                    1"$4"*) return 4 ;;
                    $3*"$4"*) : ;;
                    *) return 5 ;;
                esac

                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i#*"$4"}"

                    case "$i" in
                        *"$4"*) : ;;
                        *) [ $((x + 1)) -ne $3 ] && return 6 ;;
                    esac

                    x=$((x + 1))
                done
                [ -z "$i" ] && i="${ii%"$4"}" || i="${ii%"$4""$i"}"
            ;;
        esac
    else
        case $1 in
            0)
                i="${5##*"$2"}"
            ;;
            *)
                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"
                    x=$((x + 1))
                done
            ;;
        esac

        case $3 in
            0)
                i="${i%"$4"*}"
            ;;
            *)
                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i#*"$4"}"
                    x=$((x + 1))
                done
                i="${ii%"$4""$i"}"
            ;;
        esac

        [ "$i" = "$5" ] && return 2
    fi

    if [ -n "$i" ]; then
        if [ $# -ge 6 ] && [ $6 -eq 0 ]; then
            i="${i#${i%%[![:space:]]*}}"
        elif [ $# -ge 6 ] && [ $6 -eq 1 ]; then
            i="${i%${i##*[![:space:]]}}"
        elif [ $# -ge 6 ] && [ $6 -eq 2 ]; then
            i="${i#${i%%[![:space:]]*}}"
            i="${i%${i##*[![:space:]]}}"
        fi

        if [ $# -ge 7 ] && [ $7 -eq 3 ] || \
           [ $# -ge 6 ] && [ $6 -eq 3 ]; then
            i="$2$i"
        elif [ $# -ge 7 ] && [ $7 -eq 4 ] || \
             [ $# -ge 6 ] && [ $6 -eq 4 ]; then
            i="$i$4"
        elif [ $# -ge 7 ] && [ $7 -eq 5 ] || \
             [ $# -ge 6 ] && [ $6 -eq 5 ]; then
            i="$2$i$4"
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Parse the lines of a file
#
# Parameters:
# <$1> - mode('0' - one-to-one copy,
#             '1' - wrap parsed lines in one leading/trailing whitespace
#                   character,
#             '2' - wrap parsed lines in two leading/trailing whitespace
#                   characters,
#             '3' - skip empty lines,
#             '4' - strip trailing/leading whitespace characters)
# <"$2"> - file
# [$3] - mode('5N' - stop parsing further than specified "N" line)
#
# Returns:
# (0) output | empty output (file)
# (1) not a file | file does not exist
# (2) file access error
#
parse() {
    [ -f "$2" ] || return 1
    [ -r "$2" ] || return 2

    case $# in
    3)
        x=0
        set -- $1 "$2" ${3#?}
        case $1 in
            0)
                while IFS= read -r LINE; do
                    x=$((x + 1))
                    [ $x -eq $3 ] && break
                    printf "%s\n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "%s\n" "$LINE" || printf '\n'
            ;;
            1)
                while IFS= read -r LINE; do
                    x=$((x + 1))
                    [ $x -eq $3 ] && break
                    printf " %s \n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf " %s \n" "$LINE" || printf '\n'
            ;;
            2)
                while IFS= read -r LINE; do
                    x=$((x + 1))
                    [ $x -eq $3 ] && break
                    printf "  %s  \n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "  %s  \n" "$LINE" || printf '\n'
            ;;
            3)
                while IFS= read -r LINE || [ -n "$LINE" ] ; do
                    x=$((x + 1))
                    [ -n "$LINE" ] && printf "%s\n" "$LINE"
                    [ $x -eq $3 ] && break
                done < "$2"
            ;;
            4)
                while read -r LINE; do
                    x=$((x + 1))
                    [ $x -eq $3 ] && break
                    printf "%s\n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "%s\n" "$LINE" || printf '\n'
            ;;
        esac
    ;;
    *)
        case $1 in
            0)
                while IFS= read -r LINE; do
                    printf "%s\n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "%s\n" "$LINE" || printf '\n'
            ;;
            1)
                while IFS= read -r LINE; do
                    printf " %s \n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf " %s \n" "$LINE" || printf '\n'
            ;;
            2)
                while IFS= read -r LINE; do
                    printf "  %s  \n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "  %s  \n" "$LINE" || printf '\n'
            ;;
            3)
                while IFS= read -r LINE || [ -n "$LINE" ] ; do
                    [ -n "$LINE" ] && printf "%s\n" "$LINE"
                done < "$2"
            ;;
            4)
                while read -r LINE; do
                    printf "%s\n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "%s\n" "$LINE" || printf '\n'
            ;;
        esac
    ;;
    esac

    return 0
}

# Description:
# Print specific line in file
#
# Parameters:
# <$1> - line number
# <"$2"> - file
#
# Returns:
# (0) line's content | line empty
# (1) line does not exist
# (2) not a file | file does not exist
# (3) file access error
#
pline() {
    x=0

    [ -f "$2" ] || return 2
    [ -r "$2" ] || return 3

    while read -r LINE; do
        x=$((x + 1))
        [ $x -eq $1 ] && printf "%s" "$LINE" && return 0
    done < "$2"
    [ $((x + 1)) -eq $1 ] && printf "%s" "$LINE" && return 0

    return 1
}

# Description:
# Print a warning
#
# Parameters:
# <"$1"+> - text
#
warn() {
    printf "WARNING: %s\n" "$*"
}

# Description:
# Print a colorful warning
#
# Parameters:
# <"$1"+> - text
#
warn_clr() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$*"
}

_spatch() {
    case ":$ncolor$NO_COLOR" in
        :)
            err() { err_clr "$@"; }
            info() { info_clr "$@"; }
            warn() { warn_clr "$@"; }
        ;;
    esac
}

spatch_env() {
    FILE="$1"
}

spatch_check() {
    [ ! -f "$FILE" ] && err 2 "'$FILE' is not a file."
}

spatch_work() {
    if command -v curl > /dev/null 2>&1; then
        URL_TOOL='curl'
        URL_TOOL_ARGS='-Of'
    elif command -v wget > /dev/null 2>&1; then
        URL_TOOL='wget'
        URL_TOOL_ARGS=''
    else
        err 127 "No URL download tool available. (curl/wget)"
    fi; hash $URL_TOOL > /dev/null 2>&1

    rm -f ${TMPDIR:-/tmp}/*.patch
    cd ${TMPDIR:-/tmp} || err 1 "Line '$LINENO' failed."
}

spatch_exec() {
    while read -r LINE || [ -n "$LINE" ]; do
        if ! grep_str '://' " $LINE "; then
            if [ -n "$LINE" ] && [ -n "$verbose" ]; then
                warn "'$LINE' has no URL. (*://*)"
            fi
            continue
        fi

        LINE=$(ltl_substr1 0 '://' 1 ' ' " $LINE" 3;
               ltr_substr1 0 '://' 1 ' ' "$LINE ")

        [ -z "$durl" ] && \
            ! grep_str '.patch' "$LINE" && LINE="$LINE".patch

        [ -n "$verbose" ] && \
            NUM=$((1 + CNT)) && CNT=$NUM && info "URL ($NUM): '$LINE'."

        $URL_TOOL ${URL_TOOL_ARGS} "$LINE" > /dev/null 2>&1 &
    done < "$FILE"; wait && [ -n "$verbose" ] && unset CNT

    case $(fcount "${TMPDIR:-/tmp}" '1.patch' 3) in
    0) spatch_post; err 1 "No patches found." ;;
    *)
        [ -n "$purl" ] && SFILE=$(parse 1 "$FILE")
        SFILE=$(
            for PATCH in ${TMPDIR:-/tmp}/*.patch; do
                CSTR=$(pline 1 "$PATCH")
                CSTR=$(ltr_substr1 1 ' ' 1 ' ' "$CSTR")

                [ -n "$scommit" ] && CSTR="${CSTR%????????????????????????????}"

                DSTR=$(pline 3 "$PATCH")
                DSTR=$(ltr_substr1 2 ' ' 4 ' ' "$DSTR")

                [ -n "$purl" ] && CSTR=$(ltl_substr1 0 "$CSTR" 1 ' ' "$SFILE" 3)

                echo "$CSTR $DSTR"
            done
        )
    ;;
    esac

    SFILE=$(echo "$SFILE" | sort -t " " -k4.1,4.4 -k3.1,3.3M -k2.1n \
                                        -k5.1,5.2 -k5.4,5.5 -k5.7,5.8)

    if [ -n "$invert" ]; then
        SFILE=$(echo "$SFILE" | \
                awk '{a[i++]=$0;} END {for (j=i-1; j>=0;) print a[j--];}')
    fi

    if [ -n "$lnumbers" ]; then
        SFILE=$(echo "$SFILE" | \
            while read -r LINE; do
                NUM=$((1 + CNT))
                CNT=$NUM
                echo "$NUM - $LINE"
            done
        )
    fi

    if [ -n "$tstamp" ]; then
        SFILE=$(printf "%s\nTIMESTAMP: %s\n" "$SFILE" \
                       "$(date '+%b %-e, %T %:z %Y')")
    fi

    if [ -n "$tfile" ]; then
        if [ -d "${tfile%/*}" ]; then
            echo "$SFILE" 2> /dev/null > "$tfile" || {
                warn "Error code $? while trying to write output to '$tfile'."
                echo "$SFILE"
            }
        else
            warn "'${tfile%/*}' is not a valid directory."
            echo "$SFILE"
        fi
    else
        echo "$SFILE"
        if { >&3; } 2> /dev/null; then
            echo "$SFILE" 1>&3
        fi
    fi
}

spatch_post() {
    rm -f ${TMPDIR:-/tmp}/*.patch
}

spatch() {
    _spatch;
    spatch_env "$1"
    spatch_check;
    spatch_work;
    spatch_exec;
    spatch_post;
}

main_functions() {
    # Description:
    # Signify invalid operand count (min)[0>X]
    #
    opd_min() {
        set -- "${0##*/}"
        printf "%s: No operand specified.\n" "$1" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[X>1]
    #
    # Parameters:
    # <"$1"> - count
    #
    opd_cmax() {
        set -- "${0##*/}" "$1"
        printf "%s: Too many operands: %d\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[2>1]
    #
    # Parameters:
    # <"$1"> - first operand
    # <"$2"> - second operand
    #
    opd_max() {
        set -- "${0##*/}" "$1" "$2"
        printf "%s: Too many operands: '[%s]; [%s]'\n" "$1" "$2" "$3" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_invalid() {
        set -- "${0##*/}" "$1"
        printf "%s: Invalid option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unknown (*) option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unknown() {
        set -- "${0##*/}" "$1"
        printf "%s: Unknown option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unrecognized ('--') option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unrecognized() {
        set -- "${0##*/}" "$1"
        printf "%s: Unrecognized option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Return 0 if complex (arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # <"$ii"> - option argument
    # <"$n"> - shift count
    #
    copt() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        esac

        case "$ii:$i " in
            :"$1 ")
                printf "%s: Option '%s' requires an argument.\n" \
                       "${0##*/}" "$1" 1>&2
                printf "%s: Try '%s --help' for more information.\n" \
                       "${0##*/}" "${0##*/}" 1>&2
                exit 2
           ;;
        esac

        case "$i" in
        "--"*)
            case "$i " in
                "$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1 ")
                    n=2
                    unset i; return 0
                ;;
                "$1="*)
                    ii="${i#"$1"=}"; n=1
                    unset i; return 0
                ;;
            esac
        ;;
        "-"*)
            case "$i " in
                "$1 ")
                    n=2
                    unset i; return 0
                ;;
                "$1"*)
                    ii="${i#"$1"}"; n=1
                    unset i; return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if perhaps complex (arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # ["$ii"] - option argument
    # <"$n"> - shift count
    #
    copt_optional() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    n=1
                    unset i ii; return 0
                ;;
                "$1="*)
                    ii="${i#"$1"=}"; n=1
                    unset i; return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1")
                    n=1
                    unset i ii; return 0
                ;;
                "$1"*)
                    ii="${i#"$1"}"; n=1
                    unset i; return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific complex (arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # <"$ii"> - option argument
    # <"$n"> - shift count
    #
    scopt() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$ii:$i " in
                :"$1 ")
                    printf "%s: Option '%s' requires an argument.\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$ii:$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$ii:$1 ")
                    n=2
                    unset i; return 0
                ;;
                "$ii:$1="*)
                    ii="${i#"$1"=}"; n=1
                    unset i; return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if specific perhaps complex (arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # ["$ii"] - option argument
    # <"$n"> - shift count
    #
    scopt_optional() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$i" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    n=1
                    unset i ii; return 0
                ;;
                "$1="*)
                    ii="${i#"$1"=}"; n=1
                    unset i; return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if simple (!arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    sopt() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1")
                    n=1
                    unset i; return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1"*)
                    case ":$optind" in
                        :) optind="@$1@" ;;
                        *) optind="$optind @$1@" ;;
                    esac

                    i="-${i#??}"; n=1
                    return 0
               ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific simple (!arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    ssopt() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$i" in
                "$1")
                    n=1
                    unset i; return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }
}

# Description:
# Substitute the function call with script options
#
# Parameters:
# <"$1"> - mode('0' - print standard ('-'; '--') utility options)
#
main_options() {
    case $1 in
    0)
        sopt "--no-color" && { ncolor=1; }
        sopt "-d" "--direct-url" && { durl=1; }
        sopt "-i" "--invert-sort" && { invert=1; }
        sopt "-l" "--line-numbers" && { lnumbers=1; }
        sopt "-p" "--preserve-url" && { purl=1; }
        sopt "-s" "--short-commit" && { scommit=1; }
        sopt "-t" "--timestamp" && { tstamp=1; }
        sopt "-v" "--verbose" && { verbose=1; }

        copt "-o" "--output" && {
            tfile=$(get_fpath "$ii")
        }
    ;;
    esac
}

main() {
    # For practical reasons, unset conditional variables if they exist
    # > special:
    unset RC CNT
    # > options:
    unset ncolor durl invert lnumbers purl scommit tstamp verbose tfile

    # Source common functions
    main_functions;

    # Parse options
    while [ "$1" ]; do
        # Simulate global $N (positional parameters) shift
        #  > option functions modify when appropriate
        n=1

        # Simulate global $1/$2 (option/argument) handling
        #  > option functions modify when appropriate
        i="$1"; ii="$2"

        # Parse standard options
        #  > required to parse them first
        ssopt "-" && { opt_invalid "$1"; exit 2; }
        ssopt "--" && { shift && break; }
        ssopt "--help" && { usage; exit 0; }
        ssopt "--version" && { version; exit 0; }

        # Loop on the option holder until fully parsed
        #  > as we might need to loop on its characters
        while [ -n "$i" ]; do
            unset optind

            case "$i" in
                "-"*) main_options 0 ;;
            esac

            case ":$i" in
            :)
                :
            ;;
            :"--"*)
                opt_unrecognized "$i"; exit 2
            ;;
            :"-"*)
                case ":$optind" in
                    :) opt_invalid "${i%"${i#??}"}"; exit 2 ;;
                esac

                case ${#i} in
                    1) unset optind && break ;;
                esac
            ;;
            *)
                break 2
            ;;
            esac
        done

        # Move on positional parameters
        #  > either with default value or with option value
        shift $n
    done

    # Catch wrong input
    if [ ! "$1" ]; then
        opd_min; exit 2
    elif [ "$2" ]; then
        opd_cmax $#; exit 2
    fi

    # Convert relative path to absolute path
    set -- $(get_fpath "$1")

    # Execute the core function
    spatch "$1"

    # Check if RC is set, otherwise explicit success
    [ -n "$RC" ] && return $RC || return 0
}

main "$@"
