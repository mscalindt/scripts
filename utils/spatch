#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-only
# shellcheck disable=SC2030 # ShellCheck is wrong (on the intention)
# shellcheck disable=SC2031 # ShellCheck wrong parse order
# shellcheck disable=SC2048 # ShellCheck incorrect pedantic warning

_copyright() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'COPYRIGHT'
Copyright (C) 2020-2022 Dimitar Yurukov <mscalindt@protonmail.com>
COPYRIGHT
}

_description() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'DESCRIPTION'
Sort commit/patch URLs by date.
DESCRIPTION
}

_license() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'LICENSE'
License GPLv3: GNU GPL version 3
LICENSE
}

_misc() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'MISC'
The sort output, when '-o'/'--output' is not given, is written in the output;
if file descriptor 3 is open, the sort output will be written there as well.

External utilities hard dependency list:
curl, rm, sort.
External utilities soft dependency list:
awk, date.
MISC
}

_notice() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'NOTICE'
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
NOTICE
}

_options() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'OPTIONS'
Options:
  -d, --direct-url           assume URLs are valid patch links even if they do
                             not end with .patch
  -i, --invert-sort          sort from newest to oldest
  -l, --line-numbers         append line numbers to the sort output
  -o, --output <PATH>        PATH is an absolute or relative location to which
                             the sort output shall be written; if the parent
                             does not exist, output will be written to stdout
  -p, --preserve-url         preserve the URLs
  -s, --short-commit         print a shorter SHA-1 (12 characters) of the
                             commits
  -t, --timestamp            append timestamp to the sort output
  -v, --verbose              show additional information unrelated to the sort
                             output
      --no-color             colorless output on all streams
      --help     display this help text and exit
      --version  display version information and exit
      --         specify end of options
OPTIONS
}

_usage() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'USAGE'
Usage: spatch [options] [--] FILE
USAGE
}

_version() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'VERSION'
spatch 0.0.0
VERSION
}

usage() {
    _usage; _description; echo
    _options; echo
    _misc;
}

version() {
    _version; echo
    _copyright; echo
    _license; _notice;
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err() {
    _rc="$1"; shift
    printf "ERROR: %s\n" "$*" 1>&2
    exit "$_rc"
}

# Description:
# Colorfully print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err_clr() {
    _rc="$1"; shift
    printf "%bERROR:%b %s\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit "$_rc"
}

# Description:
# Count files and directories in a directory
#
# Parameters:
# <"$1"> - directory
# ["$2"] - mode0-2("0X" - count files and directories ending with "X",
#                  '1' - count only files,
#                  "1X" - count only files ending with "X",
#                  '2' - count only directories,
#                  "2X" - count only directories ending with "X")
# [$3] - mode3('3' - exclude hidden files/directories)
#
# Provides:
# (0) <$_count> - the count
#
# Returns:
# (0) count
# (1) not a directory | directory does not exist
#
# Caveats:
# 1. The number of files/directories the function (i.e. system) can process
#    varies. The files/directories are stored as arguments, which means that the
#    amount of things that can be processed depends on the system and version,
#    on the number of files and their respective argument size, and on the
#    number and size of environment variable names. For more information,
#    related limits shall be checked: ARG_MAX.
#    Fix: none; not applicable.
#
fcount() {
    [ -d "$1" ] || return 1

    case "$1" in
        *"/") _dir="${1%?}" ;;
        *) _dir="$1" ;;
    esac
    _count=0

    case "$2" in
        0*|1*|2*) _sfix="${2#?}" ;;
    esac

    case $#:"$2" in
        1:)
            set -- "$_dir"/*
            [ -e "$1" ] && _count=$#

            set -- "$_dir"/.*
            [ "$#" -ge 3 ] && _count=$((_count + $# - 2))
        ;;
        2:0*)
            set -- "$_dir"/*"$_sfix"
            [ -e "$1" ] && _count=$#

            set -- "$_dir"/.*"$_sfix"
            case "$_sfix" in
                ".")
                    [ -e "$2" ] && _count=$((_count + $# - 1))
                ;;
                "..")
                    [ -e "$1" ] && _count=$((_count + $#))
                ;;
                *)
                    [ -e "$_dir/$_sfix" ] && _count=$((_count + 1))
                    [ -e "$1" ] && _count=$((_count + $#))
                ;;
            esac
        ;;
        2:1)
            set -- "$_dir"/*
            [ -e "$1" ] && _count=$#

            set -- "$_dir"/*/
            [ -e "$1" ] && _count=$((_count - $#))

            set -- "$_dir"/.*
            [ -e "$3" ] && _count=$((_count + $# - 2))

            set -- "$_dir"/.*/
            [ -e "$3" ] && _count=$((_count - $# + 2))
        ;;
        2:1*)
            [ -f "$_dir/$_sfix" ] && _count=1

            set -- "$_dir"/*"$_sfix"
            [ -e "$1" ] && _count=$((_count + $#))

            set -- "$_dir"/.*"$_sfix"
            case "$_sfix" in
                ".") [ -e "$2" ] && _count=$((_count + $# - 1)) ;;
                *) [ -e "$1" ] && _count=$((_count + $#)) ;;
            esac

            set -- "$_dir"/.*"$_sfix"/
            case "$_sfix" in
                ".") [ -e "$2" ] && _count=$((_count - $# + 1)) ;;
                *) [ -e "$1" ] && _count=$((_count - $#)) ;;
            esac

            set -- "$_dir"/*"$_sfix"/
            [ -e "$1" ] && _count=$((_count - $#))
        ;;
        2:2)
            set -- "$_dir"/*/
            [ -e "$1" ] && _count=$#

            set -- "$_dir"/.*/
            [ -e "$3" ] && _count=$((_count + $# - 2))
        ;;
        2:2*)
            set -- "$_dir"/*"$_sfix"/
            [ -e "$1" ] && _count=$#

            set -- "$_dir"/.*"$_sfix"/
            case "$_sfix" in
                ".")
                    [ -e "$2" ] && _count=$((_count + $# - 1))
                ;;
                "..")
                    [ -e "$1" ] && _count=$((_count + $#))
                ;;
                *)
                    [ -d "$_dir/$_sfix" ] && _count=$((_count + 1))
                    [ -e "$1" ] && _count=$((_count + $#))
                ;;
            esac
        ;;
        2:3)
            set -- "$_dir"/*
            [ -e "$1" ] && _count=$#
        ;;
        3:0*)
            set -- "$_dir"/*"$_sfix"
            [ -e "$1" ] && _count=$#
        ;;
        3:1)
            set -- "$_dir"/*
            [ -e "$1" ] && _count=$#

            set -- "$_dir"/*/
            [ -e "$1" ] && _count=$((_count - $#))
        ;;
        3:1*)
            set -- "$_dir"/*"$_sfix"
            [ -e "$1" ] && _count=$#

            set -- "$_dir"/*"$_sfix"/
            [ -e "$1" ] && _count=$((_count - $#))
        ;;
        3:2)
            set -- "$_dir"/*/
            [ -e "$1" ] && _count=$#
        ;;
        3:2*)
            set -- "$_dir"/*"$_sfix"/
            [ -e "$1" ] && _count=$#
        ;;
    esac

    printf "%d" "$_count"
}

# Description:
# Convert relative path to absolute path
#
# Parameters:
# <"$1"> - path
#
# Provides:
# <"$_str"> - the absolute path | path
#
# Returns:
# (0) absolute $1 | $1
#
get_fpath() {
    case "$1" in
        /*) _str="$1"; printf "%s" "$1" ;;
        *) _str="$PWD/$1"; printf "%s" "$PWD/$1" ;;
    esac
}

# Description:
# Print info
#
# Parameters:
# <"$1"+> - text
#
# Returns:
# (0) text
#
info() {
    printf "INFO: %s\n" "$*"
}

# Description:
# Colorfully print info
#
# Parameters:
# <"$1"+> - text
#
# Returns:
# (0) text
#
info_clr() {
    printf "%bINFO:%b %s\n" "\033[1;37m" "\033[0m" "$*"
}

# Description:
# Get positional substring, (from&to LTL) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <"$2"> - from "X" character(s)
# <$3> - to "N" $2-TL character('0' - max)
# <"$4"> - to "X" character(s)
# <"$5"> - string
# [$6] - mode0-2('0' - strip all leading whitespace characters,
#                '1' - strip all trailing whitespace characters,
#                '2' - strip all leading/trailing whitespace characters)
# [$7] - mode3-5('3' - keep $2,
#                '4' - keep $4,
#                '5' - keep $2/$4)
# [$8] - mode6('6' - verify the expansion)
#
# Provides:
# (0) <"$_str"> - the modified string
# [$_i] - the iterations completed;
#         whole number
#
# Returns:
# (0) substring | incorrect substring ($1/$3 > $2/$4)
# (1) empty <unspecified/incorrect> expansion
# (2) unspecified <empty/incorrect> expansion
# (255) bad input
#
# Returns (mode '6'):
# (0) substring
# (1) unspecified expansion ($2 is the first character by the given ruleset)
# (2) unspecified expansion (! $2)
# (3) incorrect expansion ($1 > $2)
# (4) empty expansion ($2..$4)
# (5) unspecified expansion (! $4)
# (6) incorrect expansion ($3 > $4)
# (255) bad input
#
ltl_substr1() {
    case "$1:${1#*[!0123456789]}" in
        :) return 255 ;;
        0:0) : ;;
        0*) return 255 ;;
        "$1:$1") : ;;
        *) return 255 ;;
    esac

    case "$3:${3#*[!0123456789]}" in
        :) return 255 ;;
        0:0) : ;;
        0*) return 255 ;;
        "$3:$3") : ;;
        *) return 255 ;;
    esac

    _str="$5"

    case $#:$7$6 in
        8:*|7:6*|6:6)
            case $1 in
                0)
                    case "$_str" in
                        *"$2"*"$2"*) : ;;
                        "$2"*) return 1 ;;
                        *"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    _str="${_str%"$2"*}"
                ;;
                *)
                    case $1"$_str" in
                        1"$2"*) return 1 ;;
                        "$1"*"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    _sfix="$_str"; _i=0; until [ "$_i" -eq "$1" ]; do
                        _sfix="${_sfix#*"$2"}"

                        case "$_sfix" in
                            *"$2"*) : ;;
                            *) [ "$((_i + 1))" -eq "$1" ] || return 3 ;;
                        esac

                        _i=$((_i + 1))
                    done

                    _str="${_str%"$2$_sfix"}"
                ;;
            esac

            case $3 in
                0)
                    case "$_str" in
                        *"$4"*"$4"*) : ;;
                        *"$4") return 4 ;;
                        *"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    _str="${_str#*"$4"}"
                ;;
                *)
                    case $3"$_str" in
                        1*"$4") return 4 ;;
                        "$3"*"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    _pfix="$_str"; _i=0; until [ "$_i" -eq "$3" ]; do
                        _pfix="${_pfix%"$4"*}"

                        case "$_pfix" in
                            *"$4"*) : ;;
                            *) [ "$((_i + 1))" -eq "$3" ] || return 6 ;;
                        esac

                        _i=$((_i + 1))
                    done

                    _str="${_str#"$_pfix$4"}"
                ;;
            esac
        ;;
        *)
            case $1 in
                0)
                    _str="${_str%"$2"*}"
                ;;
                *)
                    _sfix="$_str"; _i=0; until [ "$_i" -eq "$1" ]; do
                        _sfix="${_sfix#*"$2"}"
                        _i=$((_i + 1))
                    done

                    _str="${_str%"$2$_sfix"}"
                ;;
            esac

            [ "$_str" = "$5" ] && return 2
            _old_str="$_str"

            case $3 in
                0)
                    _str="${_str#*"$4"}"
                ;;
                *)
                    _pfix="$_str"; _i=0; until [ "$_i" -eq "$3" ]; do
                        _pfix="${_pfix%"$4"*}"
                        _i=$((_i + 1))
                    done

                    _str="${_str#"$_pfix$4"}"
                ;;
            esac

            [ "$_str" = "$_old_str" ] && return 2
        ;;
    esac

    [ "$_str" ] || return 1

    case $6 in
        0)
            _str="${_str#"${_str%%[![:space:]]*}"}"
        ;;
        1)
            _str="${_str%"${_str##*[![:space:]]}"}"
        ;;
        2)
            _str="${_str#"${_str%%[![:space:]]*}"}"
            _str="${_str%"${_str##*[![:space:]]}"}"
        ;;
    esac

    case $7$6 in
        *3*) _str="$_str$2" ;;
        *4*) _str="$4$_str" ;;
        *5*) _str="$4$_str$2" ;;
    esac

    printf "%s" "$_str"
}

# Description:
# Get positional substring, (from&to LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <"$2"> - from "X" character(s)
# <$3> - to "N" $2-TR character('0' - max)
# <"$4"> - to "X" character(s)
# <"$5"> - string
# [$6] - mode0-2('0' - strip all leading whitespace characters,
#                '1' - strip all trailing whitespace characters,
#                '2' - strip all leading/trailing whitespace characters)
# [$7] - mode3-5('3' - keep $2,
#                '4' - keep $4,
#                '5' - keep $2/$4)
# [$8] - mode6('6' - verify the expansion)
#
# Provides:
# (0) <"$_str"> - the modified string
# [$_i] - the iterations completed;
#         whole number
#
# Returns:
# (0) substring | incorrect substring ($1/$3 > $2/$4)
# (1) empty <unspecified/incorrect> expansion
# (2) unspecified <empty/incorrect> expansion
# (255) bad input
#
# Returns (mode '6'):
# (0) substring
# (1) unspecified expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion (! $2)
# (3) incorrect expansion ($1 > $2)
# (4) empty expansion ($2..$4)
# (5) unspecified expansion (! $4)
# (6) incorrect expansion ($3 > $4)
# (255) bad input
#
ltr_substr1() {
    case "$1:${1#*[!0123456789]}" in
        :) return 255 ;;
        0:0) : ;;
        0*) return 255 ;;
        "$1:$1") : ;;
        *) return 255 ;;
    esac

    case "$3:${3#*[!0123456789]}" in
        :) return 255 ;;
        0:0) : ;;
        0*) return 255 ;;
        "$3:$3") : ;;
        *) return 255 ;;
    esac

    _str="$5"

    case $#:$7$6 in
        8:*|7:6*|6:6)
            case $1 in
                0)
                    case "$_str" in
                        *"$2") return 1 ;;
                        *"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    _str="${_str##*"$2"}"
                ;;
                *)
                    case $1"$_str" in
                        "$1"*"$2"*"$2"*) : ;;
                        1*"$2") return 1 ;;
                        "$1"*"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    _i=0; until [ "$_i" -eq "$1" ]; do
                        _str="${_str#*"$2"}"

                        case "$_str" in
                            *"$2"*"$2"*) : ;;
                            *"$2") [ "$((_i + 2))" -eq "$1" ] && return 1 ;;
                            *"$2"*) : ;;
                            *) [ "$((_i + 1))" -eq "$1" ] || return 3 ;;
                        esac

                        _i=$((_i + 1))
                    done
                ;;
            esac

            case $3 in
                0)
                    case "$_str" in
                        *"$4"*"$4"*) : ;;
                        "$4"*) return 4 ;;
                        *"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    _str="${_str%"$4"*}"
                ;;
                *)
                    case $3"$_str" in
                        1"$4"*) return 4 ;;
                        "$3"*"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    _sfix="$_str"; _i=0; until [ "$_i" -eq "$3" ]; do
                        _sfix="${_sfix#*"$4"}"

                        case "$_sfix" in
                            *"$4"*) : ;;
                            *) [ "$((_i + 1))" -eq "$3" ] || return 6 ;;
                        esac

                        _i=$((_i + 1))
                    done

                    _str="${_str%"$4$_sfix"}"
                ;;
            esac
        ;;
        *)
            case $1 in
                0)
                    _str="${_str##*"$2"}"
                ;;
                *)
                    _i=0; until [ "$_i" -eq "$1" ]; do
                        _str="${_str#*"$2"}"
                        _i=$((_i + 1))
                    done
                ;;
            esac

            [ "$_str" = "$5" ] && return 2
            _old_str="$_str"

            case $3 in
                0)
                    _str="${_str%"$4"*}"
                ;;
                *)
                    _sfix="$_str"; _i=0; until [ "$_i" -eq "$3" ]; do
                        _sfix="${_sfix#*"$4"}"
                        _i=$((_i + 1))
                    done

                    _str="${_str%"$4$_sfix"}"
                ;;
            esac

            [ "$_str" = "$_old_str" ] && return 2
        ;;
    esac

    [ "$_str" ] || return 1

    case $6 in
        0)
            _str="${_str#"${_str%%[![:space:]]*}"}"
        ;;
        1)
            _str="${_str%"${_str##*[![:space:]]}"}"
        ;;
        2)
            _str="${_str#"${_str%%[![:space:]]*}"}"
            _str="${_str%"${_str##*[![:space:]]}"}"
        ;;
    esac

    case $7$6 in
        *3*) _str="$2$_str" ;;
        *4*) _str="$_str$4" ;;
        *5*) _str="$2$_str$4" ;;
    esac

    printf "%s" "$_str"
}

# Description:
# Parse the content of a file
#
# Parameters:
# <"$1"> - file
# [$2] - mode1-4('1' - add one leading/trailing whitespace character,
#                '2' - add two leading/trailing whitespace characters,
#                '3' - skip empty lines,
#                '4' - strip trailing/leading whitespace characters)
# ["$3"] - mode5("5 N" - stop parsing further than "N" line)
#
# Returns:
# (0) output | empty output (file) | empty output (by the given ruleset)
# (1) not a file | file does not exist
# (2) file access error
#
# Caveats:
# 1. NULL character.
# 2. Reading /proc is unreliable.
#
parse() {
    [ -f "$1" ] || return 1
    [ -r "$1" ] || return 2

    case $#:"$3$2" in
        1:)
            while IFS= read -r _line; do
                printf "%s\n" "$_line"
            done < "$1"
        ;;
        2:1)
            while IFS= read -r _line; do
                printf " %s \n" "$_line"
            done < "$1"
        ;;
        2:2)
            while IFS= read -r _line; do
                printf "  %s  \n" "$_line"
            done < "$1"
        ;;
        2:3)
            while IFS= read -r _line; do
                case ":$_line" in :) : ;; *) printf "%s\n" "$_line" ;; esac
            done < "$1"
        ;;
        2:4)
            while read -r _line; do
                printf "%s\n" "$_line"
            done < "$1"
        ;;
        2:5*)
            _maxN="${2#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                printf "%s\n" "$_line"
            done < "$1"
        ;;
        3:5*1)
            _maxN="${3#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                printf " %s \n" "$_line"
            done < "$1"
        ;;
        3:5*2)
            _maxN="${3#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                printf "  %s  \n" "$_line"
            done < "$1"
        ;;
        3:5*3)
            _maxN="${3#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                case ":$_line" in :) : ;; *) printf "%s\n" "$_line" ;; esac
            done < "$1"
        ;;
        3:5*4)
            _maxN="${3#??}"; _i=0; while read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                printf "%s\n" "$_line"
            done < "$1"
        ;;
    esac

    case $#:"$3$2" in
        1:|2:3|2:4|2:5*|3:5*3|3:5*4)
            printf "%s" "$_line"
        ;;
        2:1|3:5*1)
            [ "$_line" ] && printf " %s " "$_line"
        ;;
        2:2|3:5*2)
            [ "$_line" ] && printf "  %s  " "$_line"
        ;;
    esac
}

# Description:
# Print specific line in file
#
# Parameters:
# <$1> - line number
# <"$2"> - file
#
# Provides:
# (0) <"$_line"> - the line
#
# Returns:
# (0) line's content | line empty
# (1) line does not exist
# (2) not a file | file does not exist
# (3) file access error
#
# Caveats:
# 1. NULL character.
# 2. Reading /proc is unreliable.
#
pline() {
    [ -f "$2" ] || return 2
    [ -r "$2" ] || return 3

    _i=0; while read -r _line || [ "$_line" ]; do
        _i=$((_i + 1))
        case $_i in "$1") printf "%s" "$_line"; return 0 ;; esac
    done < "$2"

    return 1
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <"$1"> - substring
# <"$2"> - string
# [$3] - mode1-3('1' - $1 is first character(s) of $2,
#                '2' - $1 is last character(s) of $2,
#                '3' - $1 is, on its own, $2)
#
# Returns:
# (0) match
# (1) no match
#
str() {
    case $#:$3 in
        2:) case "$2" in *"$1"*) return 0 ;; esac ;;
        3:1) case "$2" in "$1"*) return 0 ;; esac ;;
        3:2) case "$2" in *"$1") return 0 ;; esac ;;
        3:3) case "$2" in "$1") return 0 ;; esac ;;
    esac

    return 1
}

# Description:
# Print a warning
#
# Parameters:
# <"$1"+> - text
#
# Returns:
# (0) text
#
warn() {
    printf "WARNING: %s\n" "$*"
}

# Description:
# Colorfully print a warning
#
# Parameters:
# <"$1"+> - text
#
# Returns:
# (0) text
#
warn_clr() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$*"
}

# Description:
# Save URL content as a file in $PWD
#
# Parameters:
# <"$1"+> - URL
#
# Requires:
# <err> ()
#
# Uses:
# <"$@"> - {state - URL(s)}; []
#
_get_url() {
    if command -v curl > /dev/null 2>&1; then
        set -- 'curl' '-Of' "$@"
    elif command -v wget > /dev/null 2>&1; then
        set -- 'wget' "$@"
    else
        err 127 "No URL download tool available. (curl/wget)"
    fi

    "$@"
}

_spatch() {
    case ":$ncolor$NO_COLOR" in
        :)
            err() { err_clr "$@"; }
            info() { info_clr "$@"; }
            warn() { warn_clr "$@"; }
        ;;
    esac
}

spatch_env() {
    FILE="$1"
}

spatch_check() {
    [ -f "$FILE" ] || err 2 "'$FILE' is not a file."
}

spatch_work() {
    rm -f "${TMPDIR:-/tmp}"/*.patch
    cd "${TMPDIR:-/tmp}" || err 1 "Line '$LINENO' failed."
}

spatch_exec() {
    while read -r LINE || [ "$LINE" ]; do
        if ! str '://' " $LINE "; then
            if [ "$LINE" ] && [ "$verbose" ]; then
                warn "'$LINE' has no URL. (*://*)"
            fi
            continue
        fi

        LINE=$(
            ltl_substr1 0 '://' 1 ' ' " $LINE" 3
            ltr_substr1 0 '://' 1 ' ' "$LINE "
        )

        if [ -z "$durl" ]; then
            str '.patch' "$LINE" || LINE="$LINE".patch
        fi

        if [ "$verbose" ]; then
            NUM=$((1 + CNT)); CNT=$NUM
            info "URL ($NUM): '$LINE'."
        fi

        _get_url "$LINE" > /dev/null 2>&1 &
    done < "$FILE"; wait; [ "$verbose" ] && unset CNT

    case $(fcount "${TMPDIR:-/tmp}" '1.patch' 3) in
        0) spatch_post; err 1 "No patches found." ;;
    esac

    [ "$purl" ] && SFILE=$(parse "$FILE" 1)
    SFILE=$(
        for PATCH in "${TMPDIR:-/tmp}"/*.patch; do
            CSTR=$(pline 1 "$PATCH")
            CSTR=$(ltr_substr1 1 ' ' 1 ' ' "$CSTR")

            [ "$scommit" ] && CSTR="${CSTR%????????????????????????????}"

            DSTR=$(pline 3 "$PATCH")
            DSTR=$(ltr_substr1 2 ' ' 4 ' ' "$DSTR")

            [ "$purl" ] && CSTR=$(ltl_substr1 0 "$CSTR" 1 ' ' "$SFILE" 3)

            echo "$CSTR $DSTR"
        done
    )

    SFILE=$(
        echo "$SFILE" | sort -t " " -k4.1,4.4 -k3.1,3.3M -k2.1n \
                                    -k5.1,5.2 -k5.4,5.5 -k5.7,5.8
    )

    if [ "$invert" ]; then
        SFILE=$(
            echo "$SFILE" | \
            awk '{a[i++]=$0;} END {for (j=i-1; j>=0;) print a[j--];}'
        )
    fi

    if [ "$lnumbers" ]; then
        SFILE=$(
            echo "$SFILE" | \
            while read -r LINE; do
                NUM=$((1 + CNT)); CNT=$NUM
                echo "$NUM - $LINE"
            done
        )
    fi

    if [ "$tstamp" ]; then
        SFILE=$(
            printf "%s\nTIMESTAMP: %s\n" "$SFILE" "$(date '+%b %-e, %T %:z %Y')"
        )
    fi

    if [ "$tfile" ]; then
        if [ -d "${tfile%/*}" ]; then
            echo "$SFILE" 2> /dev/null > "$tfile" || {
                warn "Error code $? while trying to write output to '$tfile'."
                echo "$SFILE"
            }
        else
            warn "'${tfile%/*}' is not a valid directory."
            echo "$SFILE"
        fi
    else
        echo "$SFILE"
    fi

    if { >&3; } 2> /dev/null; then
        echo "$SFILE" 1>&3
    fi
}

spatch_post() {
    rm -f "${TMPDIR:-/tmp}"/*.patch
}

spatch() {
    _spatch
    spatch_env "$1"
    spatch_check
    spatch_work
    spatch_exec
    spatch_post
}

main_functions() {
    # Description:
    # Assert a string
    #
    # Parameters:
    # <$1> - mode1-3('1' - N [0,1,00,01...],
    #                '2' - whole N [0,1...],
    #                '3' - natural N [1...])
    # <"$2"> - string
    #
    # Returns:
    # (0) true
    # (1) false
    #
    assert() {
        case $1 in
            1)
                case "$2:${2#*[!0123456789]}" in
                    :) return 1 ;;
                    "$2:$2") : ;;
                    *) return 1 ;;
                esac
            ;;
            2)
                case "$2:${2#*[!0123456789]}" in
                    :) return 1 ;;
                    0:0) : ;;
                    0*) return 1 ;;
                    "$2:$2") : ;;
                    *) return 1 ;;
                esac
            ;;
            3)
                case "$2:${2#*[!0123456789]}" in
                    : | 0*) return 1 ;;
                    "$2:$2") : ;;
                    *) return 1 ;;
                esac
            ;;
        esac
    }

    # Description:
    # True if complex (argument) option
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Requires:
    # <_opt> $ - the first positional parameter of the main environment
    # <_opt_arg> $ - the second positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_arg"> - the option argument
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    copt() {
        [ "$_opt" ] || return 1

        case "$_opt" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        esac

        case "$_opt_arg:$_opt " in
            :"$1 ")
                printf "%s: Option '%s' requires an argument.\n" \
                       "${0##*/}" "$1" 1>&2
                printf "%s: Try '%s --help' for more information.\n" \
                       "${0##*/}" "${0##*/}" 1>&2
                exit 2
           ;;
        esac

        case "$_opt" in
        "--"*)
            case "$_opt " in
                "$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1 ")
                    _opt=; _opt_match="$1"; _shiftN=2
                    return 0
                ;;
                "$1="*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$_opt " in
                "$1 ")
                    _opt=; _opt_match="$1"; _shiftN=2
                    return 0
                ;;
                "$1"*)
                    _opt_arg="${_opt#"$1"}"; _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # True if optional-complex (possible argument) option
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Requires:
    # <_opt> $ - the first positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    # ["$_opt_arg"] - the option argument
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    copt_optional() {
        [ "$_opt" ] || return 1

        case "$_opt" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$_opt" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    _opt=; _opt_arg=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
                "$1="*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$_opt" in
                "$1")
                    _opt=; _opt_arg=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
                "$1"*)
                    _opt_arg="${_opt#"$1"}"; _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Within single quotes escape single quote(s) in string
    #
    # Parameters:
    # <"$1"+> - string
    #
    # Provides:
    # <"$_str"> - the escaped string | string
    #
    # Returns:
    # (0) escaped string | string
    #
    esc_sq() {
        [ "$1" ] || return 0

        _str="$1"

        case "$_str" in
            *"'"*)
                _str_ref="${_str%%\'*}'\\''"
                _str="${_str_ref}${_str#*\'}"

                while :; do case "$_str" in
                    "$_str_ref"*"'"*)
                        _str="${_str#*"$_str_ref"}"
                        _str_ref="$_str_ref${_str%%\'*}'\\''"
                        _str="$_str_ref${_str#*\'}"
                    ;;
                    *)
                        break
                    ;;
                esac done
            ;;
        esac

        _str="'$_str'"; printf "%s" "$_str"; shift

        while [ "$1" ]; do
            case "$1" in
                *"'"*) : ;;
                *) _str="$_str '$1'"; printf " '%s'" "$1"; shift && continue ;;
            esac

            _str_ref="${1%%\'*}'\\''"
            __str="${_str_ref}${1#*\'}"

            while :; do case "$__str" in
                "$_str_ref"*"'"*)
                    __str="${__str#*"$_str_ref"}"
                    _str_ref="$_str_ref${__str%%\'*}'\\''"
                    __str="$_str_ref${__str#*\'}"
                ;;
                *)
                    break
                ;;
            esac done

            _str="$_str '$__str'"; printf " '%s'" "$__str"; shift
        done
    }

    # Description:
    # Signify invalid operand count (max)[X>1]
    #
    # Parameters:
    # <"$1"> - count
    #
    opd_cmax() {
        set -- "${0##*/}" "$1"
        printf "%s: Too many operands: %d\n" "$1" "$2"
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1"
    } 1>&2

    # Description:
    # Signify invalid operand count (max)[2>1]
    #
    # Parameters:
    # <"$1"> - first operand
    # <"$2"> - second operand
    #
    opd_max() {
        set -- "${0##*/}" "$1" "$2"
        printf "%s: Too many operands: '[%s]; [%s]'\n" "$1" "$2" "$3"
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1"
    } 1>&2

    # Description:
    # Signify invalid operand count (min)[0>X]
    #
    opd_min() {
        set -- "${0##*/}"
        printf "%s: No operand specified.\n" "$1"
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1"
    } 1>&2

    # Description:
    # Signify invalid option argument
    #
    # Parameters:
    # <"$1"> - option
    # <"$2"> - argument
    # ["$3"+] - valid arguments
    #
    opt_err() {
        printf "%s: Invalid argument '%s' for '%s'\n" \
               "${0##*/}" "$2" "$1"
        shift 2

        if [ "$1" ]; then
            printf "Valid arguments are:\n"

            while [ "$1" ]; do
                printf " > '%s'\n" "$1"; shift
            done
        fi

        printf "%s: Try '%s --help' for more information.\n" \
               "${0##*/}" "${0##*/}"
    } 1>&2

    # Description:
    # Signify invalid option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_invalid() {
        set -- "${0##*/}" "$1"
        printf "%s: Invalid option: '%s'\n" "$1" "$2"
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1"
    } 1>&2

    # Description:
    # Signify unknown (*) option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unknown() {
        set -- "${0##*/}" "$1"
        printf "%s: Unknown option: '%s'\n" "$1" "$2"
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1"
    } 1>&2

    # Description:
    # Signify unrecognized ('--') option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unrecognized() {
        set -- "${0##*/}" "$1"
        printf "%s: Unrecognized option: '%s'\n" "$1" "$2"
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1"
    } 1>&2

    # Description:
    # True if specific complex (argument) option
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Requires:
    # <_opt> $ - the first positional parameter of the main environment
    # <_opt_arg> $ - the second positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_arg"> - the option argument
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    scopt() {
        [ "$_opt" ] || return 1

        while [ "$1" ]; do
            case "$_opt_arg:$_opt " in
                :"$1 ")
                    printf "%s: Option '%s' requires an argument.\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$_opt_arg:$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$_opt_arg:$1 ")
                    _opt=; _opt_match="$1"; _shiftN=2
                    return 0
                ;;
                "$_opt_arg:$1="*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # True if specific optional-complex (possible argument) option
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Requires:
    # <_opt> $ - the first positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    # ["$_opt_arg"] - the option argument
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    scopt_optional() {
        [ "$_opt" ] || return 1

        while [ "$1" ]; do
            case "$_opt" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    _opt=; _opt_arg=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
                "$1="*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # True if simple (no argument) option
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Requires:
    # <_opt> $ - the first positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    # ["$_sopt_index"] - an index with encountered short options
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    sopt() {
        [ "$_opt" ] || return 1

        case "$_opt" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$_opt" in
                "$1")
                    _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$_opt" in
                "$1"*)
                    case ":$_sopt_index" in
                        :) _sopt_index="${1#?}" ;;
                        *) _sopt_index="$_sopt_index${1#?}" ;;
                    esac

                    _opt="-${_opt#??}"; _opt_match="$1"; _shiftN=1
                    return 0
               ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # True if specific simple (no argument) option
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Requires:
    # <_opt> $ - the first positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    ssopt() {
        [ "$_opt" ] || return 1

        while [ "$1" ]; do
            case "$_opt" in
                "$1")
                    _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }
}

# Description:
# Reorder positional parameters (string priority = LIFO)
#
# Parameters:
# <$1> - mode1-2('1' - normal operation,
#                '2' - respect end of options)
# <"$2"+> - string
# <$3> - --
# <"$4"> - $@
#
# Requires:
# <esc_sq> ()
#
# Provides:
# <"$args"> - the modified $@ | $@ - (eval set -- "$args")
#
# Returns:
# (0) success
# (!) FATAL ERROR >> $opts is an invalid string
#
args_ro() {
    mode=$1; shift

    while :; do case "$1" in
        "--")
            shift && break
        ;;
        *)
            case "$1" in
                *"'"*) esc_sq "$1" > /dev/null ;;
                *) _str="'$1'" ;;
            esac

            case "$opts" in
                :) opts="$_str" ;;
                *) opts="$opts $_str" ;;
            esac

            shift
        ;;
    esac done

    if [ "$1" ]; then
        esc_sq "$@" > /dev/null && args="$_str"
    else
        args=; return 0
    fi

    eval set -- "$opts"
    while [ "$1" ]; do
        opt="$1"; str_ref="$args"

        case "$opt" in
            *"'"*) esc_sq "$opt" > /dev/null && opt="$_str" ;;
            *) opt="'$opt'" ;;
        esac

        case "$mode:$args" in
            2:"'--'"*) return 0 ;;
            2:*" '--'"*) str_ref="${args%% "'--'"*}" ;;
        esac

        case "$str_ref" in
            "$opt"*)
                shift && continue
            ;;
            *" $opt")
                args="$opt ${args%% "$opt"*}${args#*"$opt"}"
                shift && continue
            ;;
            *" $opt "*)
                args="$opt ${args%%"$opt"*}${args#*"$opt" }"
                shift && continue
            ;;
        esac

        case "$opt" in
            "'--"*)
                :
            ;;
            "'-"*)
                opt="${opt%?}"
                sfix=" $str_ref"

                case "$sfix" in
                    *" $opt"*)
                        sfix="${sfix#* "$opt"*\'}"

                        while :; do case "$sfix" in
                            "\\"*) sfix="${sfix#???*\'}" ;;
                            *) break ;;
                        esac done

                        pfix="$str_ref"
                        pfix="${pfix%"$sfix"}"
                        pfix="${pfix%\'*\'*}"

                        while :; do case "${pfix#"${pfix%??}"}" in
                            "\\'") pfix="${pfix%\'*???}" ;;
                            *) break ;;
                        esac done

                        arg="$str_ref"
                        arg="${arg#"$pfix"}"
                        arg="${arg%"$sfix"}"
                        arg="'-${arg#"$opt"}"

                        case "$mode:$args" in
                            2:*" '--'"*)
                                str_ref="${args#"$str_ref"}"
                                args="$opt' $pfix$arg$sfix$str_ref"
                            ;;
                            *)
                                args="$opt' $pfix$arg$sfix"
                            ;;
                        esac
                    ;;
                esac
            ;;
        esac

        shift
    done
}

# Description:
# Parse utility options
#
# Uses:
# <"$_opt"> - {state - anything}; [iteration - X]
#
# Returns:
# (0) $_opt has been parsed
# (1) $_opt is not an option
#
options() {
    unset _sopt_index

    case "$_opt" in
        "-"*)
            sopt "--no-color" && { ncolor=1; }
            sopt "-d" "--direct-url" && { durl=1; }
            sopt "-i" "--invert-sort" && { invert=1; }
            sopt "-l" "--line-numbers" && { lnumbers=1; }
            sopt "-p" "--preserve-url" && { purl=1; }
            sopt "-s" "--short-commit" && { scommit=1; }
            sopt "-t" "--timestamp" && { tstamp=1; }
            sopt "-v" "--verbose" && { verbose=1; }

            copt "-o" "--output" && {
                tfile=$(get_fpath "$_opt_arg")
            }
        ;;
    esac

    [ "$_opt" ] || return 0

    case "$_opt" in
        "--"*)
            opt_unrecognized "$_opt"; exit 2
        ;;
        "-"*)
            case ":$_sopt_index" in
                :) opt_invalid "${_opt%"${_opt#??}"}"; exit 2 ;;
            esac

            case ${#_opt} in
                1) unset _opt _sopt_index; return 0 ;;
            esac

            options;
        ;;
    esac

    return 1
}

main() {
    # Source common functions
    main_functions;

    # Parse options
    while [ "$1" ]; do
        # Simulate global $N (positional parameters) shift
        #  > option functions modify when appropriate
        _shiftN=1

        # Simulate global $1/$2 (option/argument) handling
        #  > option functions modify when appropriate
        _opt="$1"; _opt_arg="$2"

        # Parse standard options
        #  > required to parse them first
        ssopt "-" && { opt_invalid "$1"; exit 2; }
        ssopt "--" && { shift && break; }
        ssopt "--help" && { usage; exit 0; }
        ssopt "--version" && { version; exit 0; }

        # Parse utility options
        #  > rc 1 if $_opt is not a valid option
        options || {
            break
        }

        # Move on positional parameters
        #  > either with default value or with option value
        shift "$_shiftN"
    done

    # Catch wrong input
    if [ ! "$1" ]; then
        opd_min; exit 2
    elif [ "$2" ]; then
        opd_cmax "$#"; exit 2
    fi

    # Convert relative path to absolute path
    set -- "$(get_fpath "$1")"

    # Execute the core function
    spatch "$1"

    # Check if RC is set, otherwise explicit success
    [ "$RC" ] && return "$RC" || return 0
}

main "$@"
