#!/bin/sh
# shellcheck disable=SC2030
# shellcheck disable=SC2031
# shellcheck disable=SC2048
# shellcheck disable=SC2086
# shellcheck disable=SC2181
# shellcheck disable=SC2254

: <<'notice'
 * SPDX-License-Identifier: GPL-3.0
 *
 * Copyright (C) 2020-2021 Dimitar Yurukov <mscalindt@protonmail.com>
 *
notice

usage() {
printf "%s" "\
Usage: spatch [options] [--] FILE
Sort commit/patch URLs by date.

Options:
  -d, --direct-url           assume URLs are valid patch links even if they do
                             not end with .patch
  -i, --invert-sort          sort from newest to oldest
  -l, --line-numbers         append line numbers to the sort output
  -o, --output PATH          PATH is an absolute or relative location to which
                             the sort output shall be written
  -p, --preserve-url         preserve the URLs
  -t, --timestamp            append timestamp to the sort output
  -v, --verbose              show additional information unrelated to the sort
                             output
      --help     display this help text and exit
      --         specify end of options

External utilities dependency list:
awk, curl, date, rm, sort.
"
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2+"> - text
#
err() {
    i=$1 && shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $i
}

# Description:
# Count files and directories in a directory
#
# Parameters:
# <"$1"> - directory
# ['$2'] - mode('0X' - count files and directories ending with "X",
#               '1' - count only files,
#               '1X' - count only files ending with "X",
#               '2' - count only directories,
#               '2X' - count only directories ending with "X")
#
# Returns:
# (0) count
# (1) directory is empty
#
fcount() {
    i="$1"

    if [ $# -eq 2 ]; then
        case "$2" in
            0*)
                ii="${2#0}"
                set -- "$i"/*"$ii" && iii="$1" && ii=$#
            ;;
            1)
                set -- "$i"/* && iii="$1" && ii=$#
                set -- "$i"/*/ && i=$# && ii=$((ii - i))
            ;;
            1*)
                ii="${2#1}"
                set -- "$i"/*"$ii" && iii="$1" && iiii=$#
                set -- "$i"/*"$ii"/ && i=$# && ii=$((iiii - i))
            ;;
            2)
                set -- "$i"/*/ && iii="$1" && ii=$#
            ;;
            2*)
                ii="${2#2}"
                set -- "$i"/*"$ii"/ && iii="$1" && ii=$#
            ;;
        esac
    else
        set -- "$i"/* && iii="$1" && ii=$#
    fi

    [ -e "$iii" ] && printf "%d" "$ii" && return 0
    return 1
}

# Description:
# Convert relative path to absolute path
#
# Parameters:
# <"$1"> - path
#
# Returns:
# (0) absolute path
# (1) path is already absolute
#
get_fpath() {
    case "$1" in "/"*) printf "%s" "$1" && return 1 ;; esac
    printf "%s/%s" "$PWD" "$1" && return 0
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <'$1'> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is, on its own, $2)
#
# Returns:
# (0) substring exists
# (1) no substring
#
grep_str() {
    if [ $# -eq 3 ]; then
        if [ $3 -eq 1 ]; then
            case "$2" in
                "$1"*) grep_str=0 && return 0 ;;
            esac
        elif [ $3 -eq 2 ]; then
            case "$2" in
                *"$1") grep_str=0 && return 0 ;;
            esac
        elif [ $3 -eq 3 ]; then
            case "$2" in
                "$1") grep_str=0 && return 0 ;;
            esac
        fi
    else
        case "$2" in
            *"$1"*) grep_str=0 && return 0 ;;
        esac
    fi

    return 1
}

# Description:
# Check the existence/position of a substring in stdin
#
# Parameters:
# <'$1'> - substring
# [$2] - mode('1' - $1 is first character(s) of stdin,
#             '2' - $1 is last character(s) of stdin,
#             '3' - $1 is, on its own, stdin)
#
# Returns:
# (0) substring exists
# (1) no substring
#
grep_str_fd1() {
    if [ $# -eq 2 ]; then
        if [ $2 -eq 1 ]; then
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                case "$LINE" in
                    "$1"*) return 0 ;;
                esac
            done
        elif [ $2 -eq 2 ]; then
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                case "$LINE" in
                    *"$1") return 0 ;;
                esac
            done
        elif [ $2 -eq 3 ]; then
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                case "$LINE" in
                    "$1") return 0 ;;
                esac
            done
        fi
    else
        while IFS= read -r LINE || [ -n "$LINE" ]; do
            case "$LINE" in
                *"$1"*) return 0 ;;
            esac
        done
    fi

    return 1
}

# Description:
# Print info
#
# Parameters:
# <"$1+"> - text
#
info() {
    printf "%bINFO:%b %s\n" "\033[1;37m" "\033[0m" "$*"
}

# Description:
# Get positional substring, (from LTL) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <'$2'> - from "X" character(s)
# <"$3"> - string
# [$4] - mode('0' - strip trailing/leading whitespace character)
# [$5] - mode('1' - keep $2)
# [$6] - mode('2' - verify expansion; may cost performance)
#
# Returns:
# (0) substring
# (1) empty expansion
# (2) bad expansion
#
# Returns (mode '2'):
# (0) substring
# (1) empty expansion
# (2) bad expansion
# (3) wrong expansion
#
ltl_substr0() {
    if [ $# -eq 6 ] || \
       [ $# -ge 5 ] && [ $5 -eq 2 ] || \
       [ $# -ge 4 ] && [ $4 -eq 2 ]; then
        case $1 in
            0) i="${3%$2*}" ;;
            *) x=0 && i="$3" && ii="$i"
               until [ $x -eq $1 ]; do
                   iii="$i" && i="${i#*$2}"
                   [ "$iii" = "$i" ] && return 3
                   x=$((x + 1))
               done
               i="${ii%$2$i}"
            ;;
        esac
    else
        case $1 in
            0) i="${3%$2*}" ;;
            *) x=0 && i="$3" && ii="$i"
               until [ $x -eq $1 ]; do
                   i="${i#*$2}"
                   x=$((x + 1))
               done
               i="${ii%$2$i}"
            ;;
        esac
    fi
    [ "$i" = "$3" ] && return 2

    if [ -n "$i" ]; then
        if [ $# -ge 5 ]; then
            case $5 in
                0) case "$i" in " "*) i="${i# }" ;; esac
                   case "$i" in *" ") i="${i% }" ;; esac
                ;;
                1) i="$i$2" ;;
            esac
        fi
        if [ $# -ge 4 ]; then
            case $4 in
                0) case "$i" in " "*) i="${i# }" ;; esac
                   case "$i" in *" ") i="${i% }" ;; esac
                ;;
                1) i="$i$2" ;;
            esac
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Get positional substring, (from&to LTL) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <'$2'> - from "X" character(s)
# <$3> - to "N" $1-TL character('0' - max)
# <'$4'> - to "X" character(s)
# <"$5"> - string
# [$6] - mode('0' - strip trailing/leading whitespace character)
# [$7] - mode('1' - keep $2,
#             '2' - keep $4,
#             '3' - keep $2/$4)
# [$8] - mode('4' - verify expansion; may cost performance)
#
# Returns:
# (0) substring
# (1) empty expansion
# (2) bad expansion
#
# Returns (mode '4'):
# (0) substring
# (1) empty expansion
# (2) bad expansion
# (3) wrong expansion
#
ltl_substr1() {
    if [ $# -eq 8 ] || \
       [ $# -ge 7 ] && [ $7 -eq 4 ] || \
       [ $# -ge 6 ] && [ $6 -eq 4 ]; then
        case $1 in
            0) i="${5%$2*}" ;;
            *) x=0 && i="$5" && ii="$i"
               until [ $x -eq $1 ]; do
                   iii="$i" && i="${i#*$2}"
                   [ "$iii" = "$i" ] && return 3
                   x=$((x + 1))
               done
               i="${ii%$2$i}"
            ;;
        esac
        ii="$i"
        case $3 in
            0) i="${i%%$4*}" && i="${ii#$i$4}" ;;
            *) x=0
               until [ $x -eq $3 ]; do
                   iii="$i" && i="${i%$4*}"
                   [ "$iii" = "$i" ] && return 3
                   x=$((x + 1))
               done
               i="${ii#$i$4}"
            ;;
        esac
    else
        case $1 in
            0) i="${5%$2*}" ;;
            *) x=0 && i="$5" && ii="$i"
               until [ $x -eq $1 ]; do
                   i="${i#*$2}"
                   x=$((x + 1))
               done
               i="${ii%$2$i}"
            ;;
        esac
        ii="$i"
        case $3 in
            0) i="${i%%$4*}" && i="${ii#$i$4}" ;;
            *) x=0
               until [ $x -eq $3 ]; do
                   i="${i%$4*}"
                   x=$((x + 1))
               done
               i="${ii#$i$4}"
            ;;
        esac
    fi
    [ "$i" = "$5" ] && return 2

    if [ -n "$i" ]; then
        if [ $# -ge 7 ]; then
            case $7 in
                0) case "$i" in " "*) i="${i# }" ;; esac
                   case "$i" in *" ") i="${i% }" ;; esac
                ;;
                1) i="$i$2" ;;
                2) i="$4$i" ;;
                3) i="$4$i$2" ;;
            esac
        fi
        if [ $# -ge 6 ]; then
            case $6 in
                0) case "$i" in " "*) i="${i# }" ;; esac
                   case "$i" in *" ") i="${i% }" ;; esac
                ;;
                1) i="$i$2" ;;
                2) i="$4$i" ;;
                3) i="$4$i$2" ;;
            esac
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Get positional substring, (from LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <'$2'> - from "X" character(s)
# <"$3"> - string
# [$4] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$5] - mode('3' - keep $2)
# [$6] - mode('4' - verify the expansion)
#
# Returns:
# (0) substring
# (1) empty expansion (empty, or unspecified, or wrong -- shell specific)
# (2) unspecified expansion (unspecified, or empty, or wrong -- shell specific)
#
# Returns (mode '4'):
# (0) substring
# (1) empty expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion ($2 is not present at all)
# (3) wrong expansion ($1 is greater than the total $2 in the string)
#
# Caveats:
# 1. If mode 4 is NOT passed, you should NOT assume the expansion is
#    respectively correct, even if the return code is 0. This is because every
#    shell has its own unique string expander and unspecified results will vary
#    between them; for example, if $2 is not present anymore or at all, one
#    shell might return the same expansion, while another might return empty
#    expansion. Also, the string expander on its own does NOT guarantee correct
#    expansion at all.
#    Fix: Use mode '4'. When mode 4 is passed, the function will do various
#    checks on each expansion to accurately determine what the expansion will
#    result into; this guarantees respectively correct expansion on any shell.
#    Performance cost should be negligible on most shells.
#
ltr_substr0() {
    if [ $# -eq 6 ] || \
       [ $# -ge 5 ] && [ $5 -eq 4 ] || \
       [ $# -ge 4 ] && [ $4 -eq 4 ]; then
        case $1 in
            0)
                case "$3" in
                    *"$2") return 1 ;;
                    *"$2"*) : ;;
                    *) return 2 ;;
                esac

                i="${3##*"$2"}"
            ;;
            *)
                case $1"$3" in
                    $1*"$2"*"$2"*) : ;;
                    1*"$2") return 1 ;;
                    $1*"$2"*) : ;;
                    *) return 2 ;;
                esac

                x=0 && i="$3"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"

                    case "$i" in
                        *"$2"*"$2"*) : ;;
                        *"$2") [ $((x + 2)) -eq $1 ] && return 1 ;;
                        *"$2"*) : ;;
                        *) [ $((x + 1)) -ne $1 ] && return 3 ;;
                    esac

                    x=$((x + 1))
                done
            ;;
        esac
    else
        case $1 in
            0)
                i="${3##*"$2"}"
            ;;
            *)
                x=0 && i="$3"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"
                    x=$((x + 1))
                done
            ;;
        esac

        [ "$i" = "$3" ] && return 2
    fi

    if [ -n "$i" ]; then
        if [ $# -ge 4 ] && [ $4 -eq 0 ]; then
            i="${i#${i%%[![:space:]]*}}"
        elif [ $# -ge 4 ] && [ $4 -eq 1 ]; then
            i="${i%${i##*[![:space:]]}}"
        elif [ $# -ge 4 ] && [ $4 -eq 2 ]; then
            i="${i#${i%%[![:space:]]*}}"
            i="${i%${i##*[![:space:]]}}"
        fi

        if [ $# -ge 5 ] && [ $5 -eq 3 ] || \
           [ $# -ge 4 ] && [ $4 -eq 3 ]; then
            i="$2$i"
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Get positional substring, (from&to LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <'$2'> - from "X" character(s)
# <$3> - to "N" $2-TR character('0' - max)
# <'$4'> - to "X" character(s)
# <"$5"> - string
# [$6] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$7] - mode('3' - keep $2,
#             '4' - keep $4,
#             '5' - keep $2/$4)
# [$8] - mode('6' - verify the expansion)
#
# Returns:
# (0) substring
# (1) empty expansion (empty, or unspecified, or wrong -- shell specific)
# (2) unspecified expansion (unspecified, or empty, or wrong -- shell specific)
#
# Returns (mode '6'):
# (0) substring
# (1) unspecified expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion ($2 is not present at all)
# (3) wrong expansion ($1 is greater than the total $2 in the string)
# (4) empty expansion (empty expansion by the given ruleset)
# (5) unspecified expansion ($4 is not present at all)
# (6) wrong expansion ($3 is greater than the total $4 in the string)
#
# Caveats:
# 1. If mode 6 is NOT passed, you should NOT assume the expansion is
#    respectively correct, even if the return code is 0. This is because every
#    shell has its own unique string expander and unspecified results will vary
#    between them; for example, if $2/$4 is not present anymore or at all, one
#    shell might return the same expansion, while another might return empty
#    expansion. Also, the string expander on its own does NOT guarantee correct
#    expansion at all.
#    Fix: Use mode '6'. When mode 6 is passed, the function will do various
#    checks on each expansion to accurately determine what the expansion will
#    result into; this guarantees respectively correct expansion on any shell.
#    Performance cost should be negligible on most shells.
#
ltr_substr1() {
    if [ $# -eq 8 ] || \
       [ $# -ge 7 ] && [ $7 -eq 6 ] || \
       [ $# -ge 6 ] && [ $6 -eq 6 ]; then
        case $1 in
            0)
                case "$5" in
                    *"$2") return 1 ;;
                    *"$2"*) : ;;
                    *) return 2 ;;
                esac

                i="${5##*"$2"}"
            ;;
            *)
                case $1"$5" in
                    $1*"$2"*"$2"*) : ;;
                    1*"$2") return 1 ;;
                    $1*"$2"*) : ;;
                    *) return 2 ;;
                esac

                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"

                    case "$i" in
                        *"$2"*"$2"*) : ;;
                        *"$2") [ $((x + 2)) -eq $1 ] && return 1 ;;
                        *"$2"*) : ;;
                        *) [ $((x + 1)) -ne $1 ] && return 3 ;;
                    esac

                    x=$((x + 1))
                done
            ;;
        esac

        case $3 in
            0)
                case "$i" in
                    *"$4"*"$4"*) : ;;
                    "$4"*) return 4 ;;
                    *"$4"*) : ;;
                    *) return 5 ;;
                esac

                i="${i%"$4"*}"
            ;;
            *)
                case $3"$i" in
                    1"$4"*) return 4 ;;
                    $3*"$4"*) : ;;
                    *) return 5 ;;
                esac

                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i#*"$4"}"

                    case "$i" in
                        *"$4"*) : ;;
                        *) [ $((x + 1)) -ne $3 ] && return 6 ;;
                    esac

                    x=$((x + 1))
                done
                [ -z "$i" ] && i="${ii%"$4"}" || i="${ii%"$4""$i"}"
            ;;
        esac
    else
        case $1 in
            0)
                i="${5##*"$2"}"
            ;;
            *)
                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"
                    x=$((x + 1))
                done
            ;;
        esac

        case $3 in
            0)
                i="${i%"$4"*}"
            ;;
            *)
                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i#*"$4"}"
                    x=$((x + 1))
                done
                i="${ii%"$4""$i"}"
            ;;
        esac

        [ "$i" = "$5" ] && return 2
    fi

    if [ -n "$i" ]; then
        if [ $# -ge 6 ] && [ $6 -eq 0 ]; then
            i="${i#${i%%[![:space:]]*}}"
        elif [ $# -ge 6 ] && [ $6 -eq 1 ]; then
            i="${i%${i##*[![:space:]]}}"
        elif [ $# -ge 6 ] && [ $6 -eq 2 ]; then
            i="${i#${i%%[![:space:]]*}}"
            i="${i%${i##*[![:space:]]}}"
        fi

        if [ $# -ge 7 ] && [ $7 -eq 3 ] || \
           [ $# -ge 6 ] && [ $6 -eq 3 ]; then
            i="$2$i"
        elif [ $# -ge 7 ] && [ $7 -eq 4 ] || \
             [ $# -ge 6 ] && [ $6 -eq 4 ]; then
            i="$i$4"
        elif [ $# -ge 7 ] && [ $7 -eq 5 ] || \
             [ $# -ge 6 ] && [ $6 -eq 5 ]; then
            i="$2$i$4"
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Parse the content of file
#
# Parameters:
# <$1> - mode('0' - one-to-one copy,
#             '1' - wrap parsed lines in one leading/trailing whitespace char,
#             '2' - wrap parsed lines in two leading/trailing whitespace chars,
#             '3' - skip empty lines,
#             '4' - strip trailing/leading whitespace chars)
# <"$2"> - file
#
# Returns:
# (0) output | empty output (file)
# (1) file does not exist | file permission error
#
parse() {
    case $1 in
        0)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf "%s\n" "$LINE"
            done < "$2"
        ;;
        1)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf " %s \n" "$LINE"
            done < "$2"
        ;;
        2)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf "  %s  \n" "$LINE"
            done < "$2"
        ;;
        3)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                [ -n "$LINE" ] && printf "%s\n" "$LINE"
            done < "$2"
        ;;
        4)
            while read -r LINE || [ -n "$LINE" ]; do
                printf "%s\n" "$LINE"
            done < "$2"
        ;;
    esac

    return $?
}

# Description:
# Parse the content of stdin
#
# Parameters:
# <$1> - mode('0' - one-to-one copy,
#             '1' - wrap parsed lines in one leading/trailing whitespace char,
#             '2' - wrap parsed lines in two leading/trailing whitespace chars,
#             '3' - skip empty lines,
#             '4' - strip trailing/leading whitespace chars)
#
# Returns:
# (0) output | empty output (stdin)
#
parse_fd1() {
    case $1 in
        0)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf "%s\n" "$LINE"
            done
        ;;
        1)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf " %s \n" "$LINE"
            done
        ;;
        2)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf "  %s  \n" "$LINE"
            done
        ;;
        3)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                [ -n "$LINE" ] && printf "%s\n" "$LINE"
            done
        ;;
        4)
            while read -r LINE || [ -n "$LINE" ]; do
                printf "%s\n" "$LINE"
            done
        ;;
    esac

    return 0
}

# Description:
# Print specific line in file
#
# Parameters:
# <$1> - line number
# <"$2"> - file
#
# Returns:
# (0) line's content | line empty
# (1) line does not exist | file permission error
#
pline() {
    x=0

    while read -r LINE || [ -n "$LINE" ]; do
        x=$((x + 1))
        [ $x -eq $1 ] && printf "%s" "$LINE" && return 0
    done < "$2"

    return 1
}

# Description:
# Print specific line in stdin
#
# Parameters:
# <$1> - line number
#
# Returns:
# (0) line's content | line empty
# (1) line does not exist
#
pline_fd1() {
    x=0

    while read -r LINE || [ -n "$LINE" ]; do
        x=$((x + 1))
        [ $x -eq $1 ] && printf "%s" "$LINE" && return 0
    done

    return 1
}

# Description:
# Remove specific character(s) in string
#
# Parameters:
# <'$1'> - character(s)
# <"$2"> - string
#
# Returns:
# $2 without $1 characters,
# $2
#
remchars() {
    set -f

    i=$IFS

    IFS=$1
    set -- $2

    IFS=
    set -- $*

    printf "%s\n" "$*"

    IFS=$i

    set +f
}

# Description:
# Print a warning
#
# Parameters:
# <"$1+"> - text
#
warn() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$*"
}

spatch_env() {
    FILE="$1"
}

spatch_check() {
    [ ! -f "$FILE" ] && err 1 "'$FILE' is not a file."
}

spatch_work() {
    SFILE=

    if command -v curl > /dev/null 2>&1; then
        URL_TOOL='curl'
        URL_TOOL_ARGS='-Of'
    elif command -v wget > /dev/null 2>&1; then
        URL_TOOL='wget'
        URL_TOOL_ARGS=''
    else
        err 127 "No URL download tool available. (curl/wget)"
    fi; hash $URL_TOOL > /dev/null 2>&1

    rm -f /tmp/*.patch
    cd /tmp || err 1 "Line '$LINENO' failed."
}

spatch_exec() {
    while read -r LINE || [ -n "$LINE" ]; do
        ! grep_str '://' " $LINE " && \
            [ -n "$LINE" ] && [ -n "$verbose" ] && \
                warn "'$LINE' has no URL. (*://*)" && continue

        TMP=$(ltl_substr1 0 '://' 1 ' ' " $LINE" 1)
        URL=$(ltr_substr1 0 '://' 1 ' ' "$LINE ")
        URL="$TMP$URL"

        [ -z $durl ] && \
            ! grep_str '.patch' "$URL" && URL=${URL}.patch

        [ -n "$verbose" ] && \
            NUM=$((1 + CNT)) && CNT=$NUM && info "URL ($NUM) - '$URL'."

        $URL_TOOL ${URL_TOOL_ARGS} $URL > /dev/null 2>&1 &
    done < "$FILE"; wait && [ -n "$verbose" ] && unset CNT

    if ! fcount "/tmp" '1.patch' > /dev/null 2>&1; then
        spatch_post;
        err 1 "No patches found."
    else
        SFILE=$(
            for PATCH in /tmp/*.patch; do
                CSTR=$(pline 1 "$PATCH")
                CSTR=$(ltr_substr1 1 ' ' 1 ' ' "$CSTR")
                DSTR=$(pline 3 "$PATCH")
                DSTR=$(ltr_substr1 2 ' ' 4 ' ' "$DSTR")

                if [ -n "$purl" ]; then
                    SFILE=$(parse 1 "$FILE")
                    CSTR=$(ltl_substr1 0 "$CSTR" 1 ' ' "$SFILE" 1)
                fi

                echo "$CSTR $DSTR"
            done
        )
    fi

    SFILE=$(echo "$SFILE" | sort -t " " -k4.1,4.4 -k3.1,3.3M -k2.1n \
                                        -k5.1,5.2 -k5.4,5.5 -k5.7,5.8)

    if [ -n "$invert" ]; then
        SFILE=$(echo "$SFILE" | \
                awk '{a[i++]=$0;} END {for (j=i-1; j>=0;) print a[j--];}')
    fi

    if [ -n "$lnumbers" ]; then
        SFILE=$(echo "$SFILE" | \
            while read -r LINE; do
                NUM=$((1 + CNT))
                CNT=$NUM
                echo "$NUM - $LINE"
            done
        )
    fi

    if [ -n "$tstamp" ]; then
        SFILE=$(printf "%s\nTIMESTAMP: %s\n" "$SFILE" \
                       "$(date '+%b %-e, %T %:z %Y')")
    fi

    [ -n "$tfile" ] && echo "$SFILE" > "$tfile" || echo "$SFILE"
}

spatch_post() {
    rm -f /tmp/*.patch
}

spatch() {
    spatch_env "$1"
    spatch_check;
    spatch_work;
    spatch_exec;
    spatch_post;
}

main() {
    # For security reasons, unset conditional variables if they exist
    [ -n "$CNT" ] && unset CNT
    [ -n "$tfile" ] && unset tfile
    [ -n "$durl" ] && unset durl
    [ -n "$invert" ] && unset invert
    [ -n "$lnumbers" ] && unset lnumbers
    [ -n "$purl" ] && unset purl
    [ -n "$tstamp" ] && unset tstamp
    [ -n "$verbose" ] && unset verbose
    [ -n "$RC" ] && unset RC

    # Serve the script until no script parameters passed
    while [ "$1" ]; do
        # Reset variables from previous loop run
        [ -n "$grep_str" ] && unset grep_str

        case "$1" in
            # Parse specific options first
            "--") shift && break ;;
            "--help") usage && return 0 ;;

            # Parse options
            "--"*)
                i=$(ltr_substr0 1 '--' "$1")

                if grep_str 'output' "$i" 1; then
                    if grep_str 'output=' "$i" 1; then
                        tfile=$(ltr_substr0 1 '=' "$i")
                        tfile=$(get_fpath "$tfile")
                        shift && continue
                    elif ! grep_str 'output ' "$i " 1; then
                        tfile=$(ltr_substr0 2 't' "$i")
                        tfile=$(get_fpath "$tfile")
                        shift && continue
                    elif [ "$2" ]; then
                        tfile="$2"
                        tfile=$(get_fpath "$tfile")
                        shift 2 && continue
                    fi
                fi

                if grep_str 'direct-url' "$i" 3; then durl=1; fi
                if grep_str 'invert-sort' "$i" 3; then invert=1; fi
                if grep_str 'line-numbers' "$i" 3; then lnumbers=1; fi
                if grep_str 'preserve-url' "$i" 3; then purl=1; fi
                if grep_str 'timestamp' "$i" 3; then tstamp=1; fi
                if grep_str 'verbose' "$i" 3; then verbose=1; fi

                if [ ! $grep_str ]; then
                    warn "Unrecognized option: '$1'. See --help"
                fi
                shift
            ;;
            "-"*)
                i=$(ltr_substr0 1 '-' "$1")

                if grep_str 'o' "$i" 1; then
                    if grep_str 'o=' "$i" 1; then
                        tfile=$(ltr_substr0 1 '=' "$i")
                        tfile=$(get_fpath "$tfile")
                        shift && continue
                    elif ! grep_str 'o ' "$i " 1; then
                        tfile=$(ltr_substr0 1 'o' "$i")
                        tfile=$(get_fpath "$tfile")
                        shift && continue
                    elif [ "$2" ]; then
                        tfile="$2"
                        tfile=$(get_fpath "$tfile")
                        shift 2 && continue
                    fi
                fi

                if grep_str 'd' "$i"; then durl=1; fi
                if grep_str 'i' "$i"; then invert=1; fi
                if grep_str 'l' "$i"; then lnumbers=1; fi
                if grep_str 'p' "$i"; then purl=1; fi
                if grep_str 't' "$i"; then tstamp=1; fi
                if grep_str 'v' "$i"; then verbose=1; fi

                i=$(remchars 'dilptv' "$i")
                if [ -n "$i" ]; then
                    warn "Unrecognized option(s): '-$i'. See --help"
                fi
                shift
            ;;

            *) break ;;
        esac
    done

    # Catch wrong input
    if [ ! "$1" ]; then
        err 2 "No file specified."
    elif [ "$2" ]; then
        err 2 "Too many operands. ($#)"
    fi

    # Convert relative path to absolute path
    TMP=$(get_fpath "$1") && set -- "$TMP"

    # Execute the core function
    spatch "$1"

    # Check if RC is set, otherwise explicit success
    [ -n "$RC" ] && return $RC || return 0
}

main "$@"
