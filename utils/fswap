#!/bin/sh
# shellcheck disable=SC2046
# shellcheck disable=SC2048
# shellcheck disable=SC2086

: <<'notice'
 * SPDX-License-Identifier: GPL-3.0
 *
 * Copyright (C) 2021 Dimitar Yurukov <mscalindt@protonmail.com>
 *
notice

usage() {
printf "%s" "\
Usage: fswap [options] [-c]
Create a swap file.

Options:
  -c, --check                only check for an existing swap file and remove
                             it; this option disregards other options
  -l, --location=PATH        PATH is an absolute or relative location at which
                             the swap file shall be created
  -s, --size=SIZE            specify size for the swap file; see SIZE format
                             below
  -S, --swappiness=[0-200]   specify swap intensity; value persists until
                             reboot
  -v, --verbose              increase script message verbosity
  -V, --vfs-cache-pressure=[0-2147483647]
                             specify VFS cache reclaim priority; value persists
                             until reboot
      --help     display this help text and exit

The SIZE argument is an integer followed by a unit.
Units are M, G (powers of 1024) or MB, GB (powers of 1000).
Binary prefixes can also be used: MiB=M, GiB=G.

If '-l' is not specified, default value is '\$HOME/.swapfile'.
If '-s' is not specified, default value is '1G'.

External utilities dependency list:
cat, chmod, dd, id, mkswap, rm, swapoff, swapon.
"
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2+"> - text
#
err() {
    i=$1 && shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $i
}

# Description:
# Convert relative path to absolute path
#
# Parameters:
# <"$1"> - path
#
# Returns:
# (0) absolute path
# (1) path is already absolute
#
get_fpath() {
    case "$1" in "/"*) printf "%s" "$1" && return 1 ;; esac
    printf "%s/%s" "$PWD" "$1" && return 0
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <'$1'> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is, on its own, $2)
#
# Returns:
# (0) substring exists
# (1) no substring
#
grep_str() {
    if [ $# -eq 3 ]; then
        if [ $3 -eq 1 ]; then
            case "$2" in
                "$1"*) grep_str=0 && return 0 ;;
            esac
        elif [ $3 -eq 2 ]; then
            case "$2" in
                *"$1") grep_str=0 && return 0 ;;
            esac
        elif [ $3 -eq 3 ]; then
            case "$2" in
                "$1") grep_str=0 && return 0 ;;
            esac
        fi
    else
        case "$2" in
            *"$1"*) grep_str=0 && return 0 ;;
        esac
    fi

    return 1
}

# Description:
# Check the existence/position of a substring in stdin
#
# Parameters:
# <'$1'> - substring
# [$2] - mode('1' - $1 is first character(s) of stdin,
#             '2' - $1 is last character(s) of stdin,
#             '3' - $1 is, on its own, stdin)
#
# Returns:
# (0) substring exists
# (1) no substring
#
grep_str_fd1() {
    if [ $# -eq 2 ]; then
        if [ $2 -eq 1 ]; then
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                case "$LINE" in
                    "$1"*) return 0 ;;
                esac
            done
        elif [ $2 -eq 2 ]; then
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                case "$LINE" in
                    *"$1") return 0 ;;
                esac
            done
        elif [ $2 -eq 3 ]; then
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                case "$LINE" in
                    "$1") return 0 ;;
                esac
            done
        fi
    else
        while IFS= read -r LINE || [ -n "$LINE" ]; do
            case "$LINE" in
                *"$1"*) return 0 ;;
            esac
        done
    fi

    return 1
}

# Description:
# Print info
#
# Parameters:
# <"$1+"> - text
#
info() {
    printf "%bINFO:%b %s\n" "\033[1;37m" "\033[0m" "$*"
}

# Description:
# Get positional substring, (from LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <'$2'> - from "X" character(s)
# <"$3"> - string
# [$4] - mode('0' - strip trailing/leading whitespace character)
# [$5] - mode('1' - keep $2)
# [$6] - mode('2' - verify expansion; may cost performance)
#
# Returns:
# (0) substring
# (1) empty expansion
# (2) bad expansion
#
# Returns (mode '2'):
# (0) substring
# (1) empty expansion
# (2) bad expansion
# (3) wrong expansion
#
ltr_substr0() {
    if [ $# -eq 6 ] || \
       [ $# -eq 5 ] && [ $5 -eq 2 ] || \
       [ $# -eq 4 ] && [ $4 -eq 2 ]; then
        case $1 in
            0) i="${3##*$2}" ;;
            *) x=0 && i="$3"
               until [ $x -eq $1 ]; do
                   iii="$i" && i="${i#*$2}"
                   [ "$iii" = "$i" ] && return 3
                   x=$((x + 1))
               done
            ;;
        esac
    else
        case $1 in
            0) i="${3##*$2}" ;;
            *) x=0 && i="$3"
               until [ $x -eq $1 ]; do
                   i="${i#*$2}"
                   x=$((x + 1))
               done
            ;;
        esac
    fi
    [ "$i" = "$3" ] && return 2

    if [ -n "$i" ]; then
        if [ $# -eq 5 ]; then
            case $5 in
                0) case "$i" in " "*) i="${i# }" ;; esac
                   case "$i" in *" ") i="${i% }" ;; esac
                ;;
                1) i="$2$i" ;;
            esac
        fi
        if [ $# -eq 4 ]; then
            case $4 in
                0) case "$i" in " "*) i="${i# }" ;; esac
                   case "$i" in *" ") i="${i% }" ;; esac
                ;;
                1) i="$2$i" ;;
            esac
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Get positional substring, (from&to LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <'$2'> - from "X" character(s)
# <$3> - to "N" $1-TR character('0' - max)
# <'$4'> - to "X" character(s)
# <"$5"> - string
# [$6] - mode('0' - strip trailing/leading whitespace character,
#             '1' - keep $2,
#             '2' - keep $4,
#             '3' - keep $2/$4)
# [$7] - mode('4' - verify expansion (may cost performance))
#
# Returns:
# (0) substring
# (1) empty expansion
# (2) bad expansion
#
# Returns (mode '4'):
# (0) substring
# (1) empty expansion
# (2) bad expansion
# (3) wrong expansion
#
ltr_substr1() {
    if [ $# -eq 7 ] && [ $7 -eq 4 ] || [ $# -eq 6 ] && [ $6 -eq 4 ]; then
        case $1 in
            0) i="${5##*$2}" ;;
            *) x=0 && i="$5"
            until [ $x -eq $1 ]; do
                iii="$i" && i="${i#*$2}"
                [ "$iii" = "$i" ] && return 3
                x=$((x + 1))
            done
            ;;
        esac
        ii="$i"
        case $3 in
            0) i="${i##*$4}" && i="${ii%$4$i}" ;;
            *) x=0
            until [ $x -eq $3 ]; do
                iii="$i" && i="${i#*$4}"
                [ "$iii" = "$i" ] && return 3
                x=$((x + 1))
            done
            i="${ii%$4$i}"
            ;;
        esac
    else
        case $1 in
            0) i="${5##*$2}" ;;
            *) x=0 && i="$5"
            until [ $x -eq $1 ]; do
                i="${i#*$2}"
                x=$((x + 1))
            done
            ;;
        esac
        ii="$i"
        case $3 in
            0) i="${i##*$4}" && i="${ii%$4$i}" ;;
            *) x=0
            until [ $x -eq $3 ]; do
                i="${i#*$4}"
                x=$((x + 1))
            done
            i="${ii%$4$i}"
            ;;
        esac
    fi
    [ "$i" = "$5" ] && return 2

    if [ -n "$i" ]; then
        if [ $# -eq 6 ]; then
            case $6 in
                0) case "$i" in " "*) i="${i# }" ;; esac
                   case "$i" in *" ") i="${i% }" ;; esac
                ;;
                1) i="$2$i" ;;
                2) i="$i$4" ;;
                3) i="$2$i$4" ;;
            esac
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Remove specific character(s) in string
#
# Parameters:
# <'$1'> - character(s)
# <"$2"> - string
#
# Returns:
# $2 without $1 characters,
# $2
#
remchars() {
    i=$IFS

    IFS=$1
    set -- $2

    IFS=
    set -- $*

    printf "%s\n" "$*"

    IFS=$i
}

# Description:
# Print a warning
#
# Parameters:
# <"$1+"> - text
#
warn() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$*"
}

# Description:
# Apply value to location
#
# Parameters:
# <"$1"> - value
# <$2> - location
#
_fwrite() {
    [ -w "$2" ] && printf -- "%s\n" "$1" > "$2" || \
    warn "Could not apply '$1' on '$2'. (!-w)"
}

fswap_env() {
    [ -z $ssize ] && ssize=1G
    [ -z $sfile ] && sfile="$HOME"/.swapfile
}

fswap_info() {
    hash cat > /dev/null 2>&1

    info "Swap size: '$ssize'."
    info "Swap file: '$sfile'."

    if [ -n "$swappiness" ]; then
        info "Swap intensity: '$swappiness'."
    else
        TMP=$(cat /proc/sys/vm/swappiness 2> /dev/null)
        [ -n "$TMP" ] && info "Swap intensity: '$TMP'."
    fi
 
    if [ -n "$vfscp" ]; then
        info "VFS cache reclaim priority: '$vfscp'."
    else
        TMP=$(cat /proc/sys/vm/vfs_cache_pressure 2> /dev/null)
        [ -n "$TMP" ] && info "VFS cache reclaim priority: '$TMP'."
    fi

    TMP=$(cat /sys/module/zswap/parameters/enabled 2> /dev/null)
    [ -n "$TMP" ] && info "zswap: '$TMP'."

    TMP=$(cat /sys/module/zswap/parameters/compressor 2> /dev/null)
    [ -n "$TMP" ] && info "zswap compressor: '$TMP'."

    TMP=$(cat /sys/module/zswap/parameters/zpool 2> /dev/null)
    [ -n "$TMP" ] && info "zswap allocator: '$TMP'."
}

fswap_check() {
    [ $(id -u) -ne 0 ] && err 1 "EUID is not 0. (no root)"
    swapoff -a; [ -f "$sfile" ] && rm -fv "$sfile"
}

fswap_work() {
    case "$ssize" in
        *"M" | *"MiB") ssize="${ssize%M*}" && ssize="${ssize}K" ;;
        *"G" | *"GiB") ssize="${ssize%G*}" && ssize="${ssize}M" ;;

        *"MB") ssize="${ssize%MB}" && ssize="${ssize}KB" ;;
        *"GB") ssize="${ssize%GB}" && ssize="${ssize}MB" ;;

        *) err 2 "Wrong swap size specified. Supported units: M,G[B]" ;;
    esac

    case "$ssize" in
        *"B") bscount=1000 ;;
        *) bscount=1024 ;;
    esac

    dd_args='if=/dev/zero'
    dd_args="${dd_args} of=${sfile}"
    dd_args="${dd_args} bs=${ssize}"
    dd_args="${dd_args} count=${bscount}"
    dd_args="${dd_args} status=progress"
}

fswap_exec() {
    dd ${dd_args}
    chmod 600 "$sfile"
    mkswap "$sfile"
    swapon "$sfile"
}

fswap_post() {
    [ -n "$swappiness" ] && _fwrite $swappiness /proc/sys/vm/swappiness
    [ -n "$vfscp" ] && _fwrite $vfscp /proc/sys/vm/vfs_cache_pressure
}

fswap() {
    fswap_env;
    [ -n "$verbose" ] && fswap_info;
    fswap_check;
    fswap_work;
    fswap_exec;
    fswap_post;
}

main() {
    # For security reasons, unset conditional variables if they exist
    [ -n "$sfile" ] && unset sfile
    [ -n "$ssize" ] && unset ssize
    [ -n "$swappiness" ] && unset swappiness
    [ -n "$vfscp" ] && unset vfscp
    [ -n "$check" ] && unset check
    [ -n "$verbose" ] && unset verbose
    [ -n "$RC" ] && unset RC

    # Serve the script until no script parameters passed
    while [ "$1" ]; do
        # Reset variables from previous loop run
        [ -n "$grep_str" ] && unset grep_str

        case "$1" in
            # Parse specific options first
            "--help") usage && return 0 ;;

            # Parse options
            "--"*)
                i=$(ltr_substr0 1 '--' "$1")

                if grep_str 'location' "$i" 1; then
                    if grep_str 'location=' "$i" 1; then
                        sfile=$(ltr_substr0 1 '=' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif ! grep_str 'location ' "$i " 1; then
                        sfile=$(ltr_substr0 1 'n' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif [ "$2" ]; then
                        sfile="$2"
                        sfile=$(get_fpath "$sfile")
                        shift 2 && continue
                    fi
                fi
                if grep_str 'size' "$i" 1; then
                    if grep_str 'size=' "$i" 1; then
                        ssize=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'size ' "$i " 1; then
                        ssize=$(ltr_substr0 1 'e' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        ssize="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'swappiness' "$i" 1; then
                    if grep_str 'swappiness=' "$i" 1; then
                        swappiness=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'swappiness ' "$i " 1; then
                        swappiness=$(ltr_substr0 3 's' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        swappiness="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'vfs-cache-pressure' "$i" 1; then
                    if grep_str 'vfs-cache-pressure=' "$i" 1; then
                        vfscp=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'vfs-cache-pressure ' "$i " 1; then
                        vfscp=$(ltr_substr0 3 'e' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        vfscp="$2"
                        shift 2 && continue
                    fi
                fi

                if grep_str 'check' "$i" 3; then check=1; fi 
                if grep_str 'verbose' "$i" 3; then verbose=1; fi 

                if [ ! $grep_str ]; then
                    warn "Unrecognized option: '$1'. See --help"
                fi
                shift
            ;;
            "-"*)
                i=$(ltr_substr0 1 '-' "$1")

                if grep_str 'l' "$i" 1; then
                    if grep_str 'l=' "$i" 1; then
                        sfile=$(ltr_substr0 1 '=' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif ! grep_str 'l ' "$i " 1; then
                        sfile=$(ltr_substr0 1 'l' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif [ "$2" ]; then
                        sfile="$2"
                        sfile=$(get_fpath "$sfile")
                        shift 2 && continue
                    fi
                fi
                if grep_str 's' "$i" 1; then
                    if grep_str 's=' "$i" 1; then
                        ssize=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 's ' "$i " 1; then
                        ssize=$(ltr_substr0 1 's' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        ssize="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'S' "$i" 1; then
                    if grep_str 'S=' "$i" 1; then
                        swappiness=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'S ' "$i " 1; then
                        swappiness=$(ltr_substr0 1 'S' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        swappiness="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'V' "$i" 1; then
                    if grep_str 'V=' "$i" 1; then
                        vfscp=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'V ' "$i " 1; then
                        vfscp=$(ltr_substr0 1 'V' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        vfscp="$2"
                        shift 2 && continue
                    fi
                fi

                if grep_str 'c' "$i"; then check=1; fi
                if grep_str 'v' "$i"; then verbose=1; fi

                i=$(remchars 'cv' "$i")
                if [ -n "$i" ]; then
                    warn "Unrecognized option(s): '-$i'. See --help"
                fi
                shift
            ;;

            *)
               warn "Unrecognized option(s): '$1'. See --help"
               shift && continue
            ;;
        esac
    done

    # Take specific actions for special options
    if [ -n "$check" ]; then
        fswap_env && fswap_check
        return 0
    fi

    # Execute the core function
    fswap;

    # Check if RC is set, otherwise explicit success
    [ -n "$RC" ] && return $RC || return 0
}

main "$@"
