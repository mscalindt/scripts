#!/bin/sh
# shellcheck disable=SC2046 # ShellCheck incorrect pedantic warning
# shellcheck disable=SC2048 # ShellCheck incorrect pedantic warning

: <<'notice'
 * SPDX-License-Identifier: GPL-3.0
 *
 * Copyright (C) 2021 Dimitar Yurukov <mscalindt@protonmail.com>
 *
notice

usage() {
printf "%s" "\
Usage: fswap [options] [-c]
Create a swap file.

Options:
  -c, --check                only check for an existing swap file and remove
                             it; this option disregards other options
  -l, --location <PATH>      PATH is an absolute or relative location at which
                             the swap file shall be created
  -s, --size <SIZE>          specify size for the swap file; see SIZE format
                             below
  -S, --swappiness <0-200>   specify swap intensity; value persists until
                             reboot
  -v, --vfs-cache-pressure <0-2147483647>
                             specify VFS cache reclaim priority; value persists
                             until reboot
      --help     display this help text and exit

The SIZE argument is an integer followed by a unit.
Units are M, G (powers of 1024) or MB, GB (powers of 1000).
Binary prefixes can also be used: MiB=M, GiB=G.

If '-l' is not specified, default value is '\$HOME/.swapfile'.
If '-s' is not specified, default value is '1G'.

External utilities hard dependency list:
chmod, dd, id, mkswap, rm, swapoff, swapon.
External utilities soft dependency list:
cat.
"
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2+"> - text
#
err() {
    i=$1 && shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $i
}

# Description:
# Convert relative path to absolute path
#
# Parameters:
# <"$1"> - path
#
# Returns:
# (0) absolute path / path is already absolute
#
get_fpath() {
    case "$1" in
        "/"*) printf "%s" "$1" ;;
        *) printf "%s/%s" "$PWD" "$1" ;;
    esac

    return 0
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <"$1"> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is, on its own, $2)
#
# Returns:
# (0) substring exists
# (1) no match
#
grep_str() {
    if [ $# -eq 3 ]; then
        if [ $3 -eq 1 ]; then
            case "$2" in "$1"*) grep_str=0 && return 0 ;; esac
        elif [ $3 -eq 2 ]; then
            case "$2" in *"$1") grep_str=0 && return 0 ;; esac
        elif [ $3 -eq 3 ]; then
            case "$2" in "$1") grep_str=0 && return 0 ;; esac
        fi
    else
        case "$2" in *"$1"*) grep_str=0 && return 0 ;; esac
    fi

    return 1
}

# Description:
# Print info
#
# Parameters:
# <"$1+"> - text
#
info() {
    printf "%bINFO:%b %s\n" "\033[1;37m" "\033[0m" "$*"
}

# Description:
# Print info with printf prefix before text
#
# Parameters:
# <"$1"> - printf prefix
# <"$2+"> - text
#
info_px() {
    i="$1" && shift
    printf "%bINFO:%b $i%s\n" "\033[1;37m" "\033[0m" "$*"
}

# Description:
# Get positional substring, (from LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <"$2"> - from "X" character(s)
# <"$3"> - string
# [$4] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$5] - mode('3' - keep $2)
# [$6] - mode('4' - verify the expansion)
#
# Returns:
# (0) substring
# (1) empty expansion (empty, or unspecified, or wrong -- shell specific)
# (2) unspecified expansion (unspecified, or empty, or wrong -- shell specific)
#
# Returns (mode '4'):
# (0) substring
# (1) empty expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion ($2 is not present at all)
# (3) wrong expansion ($1 is greater than the total $2 in the string)
#
# Caveats:
# 1. If mode 4 is NOT passed, you should NOT assume the expansion is
#    respectively correct, even if the return code is 0. This is because every
#    shell has its own unique string expander and unspecified results will vary
#    between them; for example, if $2 is not present anymore or at all, one
#    shell might return the same expansion, while another might return empty
#    expansion. Also, the string expander on its own does NOT guarantee correct
#    expansion at all.
#    Fix: Use mode '4'. When mode 4 is passed, the function will do various
#    checks on each expansion to accurately determine what the expansion will
#    result into; this guarantees respectively correct expansion on any shell.
#    Performance cost should be negligible on most shells.
#
ltr_substr0() {
    if [ $# -eq 6 ] || \
       [ $# -ge 5 ] && [ $5 -eq 4 ] || \
       [ $# -ge 4 ] && [ $4 -eq 4 ]; then
        case $1 in
            0)
                case "$3" in
                    *"$2") return 1 ;;
                    *"$2"*) : ;;
                    *) return 2 ;;
                esac

                i="${3##*"$2"}"
            ;;
            *)
                case $1"$3" in
                    $1*"$2"*"$2"*) : ;;
                    1*"$2") return 1 ;;
                    $1*"$2"*) : ;;
                    *) return 2 ;;
                esac

                x=0 && i="$3"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"

                    case "$i" in
                        *"$2"*"$2"*) : ;;
                        *"$2") [ $((x + 2)) -eq $1 ] && return 1 ;;
                        *"$2"*) : ;;
                        *) [ $((x + 1)) -ne $1 ] && return 3 ;;
                    esac

                    x=$((x + 1))
                done
            ;;
        esac
    else
        case $1 in
            0)
                i="${3##*"$2"}"
            ;;
            *)
                x=0 && i="$3"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"
                    x=$((x + 1))
                done
            ;;
        esac

        [ "$i" = "$3" ] && return 2
    fi

    if [ -n "$i" ]; then
        if [ $# -ge 4 ] && [ $4 -eq 0 ]; then
            i="${i#${i%%[![:space:]]*}}"
        elif [ $# -ge 4 ] && [ $4 -eq 1 ]; then
            i="${i%${i##*[![:space:]]}}"
        elif [ $# -ge 4 ] && [ $4 -eq 2 ]; then
            i="${i#${i%%[![:space:]]*}}"
            i="${i%${i##*[![:space:]]}}"
        fi

        if [ $# -ge 5 ] && [ $5 -eq 3 ] || \
           [ $# -ge 4 ] && [ $4 -eq 3 ]; then
            i="$2$i"
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Remove specific character(s) in string
#
# Parameters:
# <"$1"> - character(s)
# <"$2"> - string
#
# Returns:
# $2 without $1 characters,
# $2
#
# Caveats:
# 1. Multibyte characters are not suitable as a delimiter ($1), as the removal
#    of the characters is done by IFS splitting; any characters in a multibyte
#    character will be stripped from the string. Essentially, this means that,
#    for example, a multibyte character consisting of a whitespace character
#    will remove all the whitespace characters in the string ($2).
#    Fix: none; shell limitation.
# 2. If the delimiter ($1) contains <whitespace> (' ') and the string ($2)
#    contains multibyte characters consisting of a whitespace character, the
#    multibyte characters will be rendered incorrect, resulting in a bad string.
#    Fix: none; shell limitation.
#
remchars() {
    set -f

    i=$IFS

    IFS=$1
    set -- $2
    printf "%s" "$@"

    IFS=$i

    set +f
}

# Description:
# Print a warning
#
# Parameters:
# <"$1+"> - text
#
warn() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$*"
}

# Description:
# Apply value to location
#
# Parameters:
# <"$1"> - value
# <$2> - location
#
_fwrite() {
    [ -w "$2" ] && printf -- "%s\n" "$1" > "$2" || \
    warn "Could not apply '$1' on '$2'. (!-w)"
}

fswap_env() {
    [ -z "$ssize" ] && ssize=1G
    [ -z "$sfile" ] && sfile="$HOME"/.swapfile
}

fswap_check() {
    case $(id -u) in
        0) : ;;
        *) err 2 "EUID is not 0. (no root)" ;;
    esac

    swapoff -a || exit $?

    [ -f "$sfile" ] && rm -f "$sfile"
}

fswap_info() {
    hash cat > /dev/null 2>&1

    TMP=$(cat /sys/module/zswap/parameters/enabled 2> /dev/null)
    [ -n "$TMP" ] && info_px "\033[1;36mMISC:\033[0m " "zswap: '$TMP'."

    TMP=$(cat /sys/module/zswap/parameters/compressor 2> /dev/null)
    [ -n "$TMP" ] && info_px "\033[1;36mMISC:\033[0m " "zswap compressor:" \
                             "'$TMP'."

    TMP=$(cat /sys/module/zswap/parameters/zpool 2> /dev/null)
    [ -n "$TMP" ] && info_px "\033[1;36mMISC:\033[0m " "zswap allocator:" \
                             "'$TMP'."

    TMP=$(cat /proc/sys/vm/swappiness 2> /dev/null)
    if [ -n "$TMP" ] && [ -n "$swappiness" ]; then
        case $TMP in
        $swappiness) info "Swap intensity: '$TMP'." ;;
        *)
            info_px "\033[1;35mOLD:\033[0m " "Swap intensity: '$TMP'."
            info_px "\033[1;34mNEW:\033[0m " "Swap intensity: '$swappiness'."
        ;;
        esac
    elif [ -n "$TMP" ]; then
        info "Swap intensity: '$TMP'."
    fi

    TMP=$(cat /proc/sys/vm/vfs_cache_pressure 2> /dev/null)
    if [ -n "$TMP" ] && [ -n "$vfscp" ]; then
        case $TMP in
        $vfscp) info "VFS cache reclaim priority: '$TMP'." ;;
        *)
            info_px "\033[1;35mOLD:\033[0m " "VFS cache reclaim priority:" \
                    "'$TMP'."
            info_px "\033[1;34mNEW:\033[0m " "VFS cache reclaim priority:" \
                    "'$vfscp'."
        ;;
        esac
    elif [ -n "$TMP" ]; then
        info "VFS cache reclaim priority: '$TMP'."
    fi

    info "Swap size: '$ssize'."
    info "Swap file: '$sfile'."
}

fswap_work() {
    case "$ssize" in
        *"M" | *"MiB") ssize="${ssize%M*}" && ssize="${ssize}K" ;;
        *"G" | *"GiB") ssize="${ssize%G*}" && ssize="${ssize}M" ;;

        *"MB") ssize="${ssize%MB}" && ssize="${ssize}KB" ;;
        *"GB") ssize="${ssize%GB}" && ssize="${ssize}MB" ;;

        *) err 2 "Wrong swap size specified. Supported units: M,G[B]" ;;
    esac

    case "$ssize" in
        *"B") bscount=1000 ;;
        *) bscount=1024 ;;
    esac
}

fswap_exec() {
    dd if=/dev/zero of="$sfile" \
       bs="$ssize" count=$bscount \
       status=progress || exit $?
    chmod 600 "$sfile" || exit $?
    mkswap "$sfile" || exit $?
    swapon "$sfile" || exit $?
}

fswap_post() {
    [ -n "$swappiness" ] && _fwrite $swappiness /proc/sys/vm/swappiness
    [ -n "$vfscp" ] && _fwrite $vfscp /proc/sys/vm/vfs_cache_pressure
}

fswap() {
    fswap_env;
    fswap_check;
    fswap_info;
    fswap_work;
    fswap_exec;
    fswap_post;
}

main() {
    # For security reasons, unset conditional variables if they exist
    [ -n "$sfile" ] && unset sfile
    [ -n "$ssize" ] && unset ssize
    [ -n "$swappiness" ] && unset swappiness
    [ -n "$vfscp" ] && unset vfscp
    [ -n "$RC" ] && unset RC

    # Serve the script until no script parameters passed
    while [ "$1" ]; do
        # Reset variables from previous loop run
        [ -n "$grep_str" ] && unset grep_str

        case "$1" in
            # Parse specific options first
            "--help") usage && return 0 ;;

            # Parse options
            "--"*)
                i=$(ltr_substr0 1 '--' "$1")

                # Parse options
                if grep_str 'location' "$i" 1; then
                    if grep_str 'location=' "$i" 1; then
                        sfile=$(ltr_substr0 1 '=' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif ! grep_str 'location ' "$i " 1; then
                        sfile=$(ltr_substr0 1 'n' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif [ "$2" ]; then
                        sfile="$2"
                        sfile=$(get_fpath "$sfile")
                        shift 2 && continue
                    fi
                fi
                if grep_str 'size' "$i" 1; then
                    if grep_str 'size=' "$i" 1; then
                        ssize=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'size ' "$i " 1; then
                        ssize=$(ltr_substr0 1 'e' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        ssize="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'swappiness' "$i" 1; then
                    if grep_str 'swappiness=' "$i" 1; then
                        swappiness=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'swappiness ' "$i " 1; then
                        swappiness=$(ltr_substr0 3 's' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        swappiness="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'vfs-cache-pressure' "$i" 1; then
                    if grep_str 'vfs-cache-pressure=' "$i" 1; then
                        vfscp=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'vfs-cache-pressure ' "$i " 1; then
                        vfscp=$(ltr_substr0 3 'e' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        vfscp="$2"
                        shift 2 && continue
                    fi
                fi

                # Parse specific options
                if grep_str 'check' "$i" 3; then
                    fswap_env; fswap_check
                    return 0
                fi

                if [ -n "$i" ] && [ ! $grep_str ]; then
                    warn "Unrecognized option: '$1'. See --help"
                fi
                shift
            ;;
            "-"*)
                i=$(ltr_substr0 1 '-' "$1")

                # Parse options
                if grep_str 'l' "$i" 1; then
                    if grep_str 'l=' "$i" 1; then
                        sfile=$(ltr_substr0 1 '=' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif ! grep_str 'l ' "$i " 1; then
                        sfile=$(ltr_substr0 1 'l' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif [ "$2" ]; then
                        sfile="$2"
                        sfile=$(get_fpath "$sfile")
                        shift 2 && continue
                    fi
                fi
                if grep_str 's' "$i" 1; then
                    if grep_str 's=' "$i" 1; then
                        ssize=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 's ' "$i " 1; then
                        ssize=$(ltr_substr0 1 's' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        ssize="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'S' "$i" 1; then
                    if grep_str 'S=' "$i" 1; then
                        swappiness=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'S ' "$i " 1; then
                        swappiness=$(ltr_substr0 1 'S' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        swappiness="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'V' "$i" 1; then
                    if grep_str 'V=' "$i" 1; then
                        vfscp=$(ltr_substr0 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'V ' "$i " 1; then
                        vfscp=$(ltr_substr0 1 'V' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        vfscp="$2"
                        shift 2 && continue
                    fi
                fi

                # Parse specific options
                if grep_str 'c' "$i"; then
                    fswap_env; fswap_check
                    return 0
                fi

                if [ -n "$i" ]; then
                    warn "Unrecognized option(s): '-$i'. See --help"
                fi
                shift
            ;;

            *)
               warn "Unrecognized option(s): '$1'. See --help"
               shift && continue
            ;;
        esac
    done

    # Execute the core function
    fswap;

    # Check if RC is set, otherwise explicit success
    [ -n "$RC" ] && return $RC || return 0
}

main "$@"
