#!/bin/sh
# shellcheck disable=SC2046
# shellcheck disable=SC2048
# shellcheck disable=SC2086

: <<'notice'
 * SPDX-License-Identifier: GPL-3.0
 *
 * Copyright (C) 2021 Dimitar Yurukov <mscalindt@protonmail.com>
 *
notice

usage() {
printf "%s" "\
Usage: fswap [options] [-c]
Create a swap file.

Options:
  -c, --check                only check for an existing swap file and remove
                             it; this option disregards other options
  -l, --location=PATH        PATH is an absolute or relative location at which
                             the swap file shall be created
  -s, --size=SIZE            specify size for the swap file; see SIZE format
                             below
  -S, --swappiness=[0-200]   specify swap intensity; value persists until
                             reboot
  -v, --verbose              increase script message verbosity
  -V, --vfs-cache-pressure=[0-2147483647]
                             specify VFS cache reclaim priority; value persists
                             until reboot
      --help     display this help text and exit

The SIZE argument is an integer followed by a unit.
Units are M, G (powers of 1024) or MB, GB (powers of 1000).
Binary prefixes can also be used: MiB=M, GiB=G.

If '-l' is not specified, default value is '\$HOME/.swapfile'.
If '-s' is not specified, default value is '1G'.

External utilities dependency list:
cat, chmod, dd, id, mkswap, rm, swapoff, swapon.
"
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2+"> - text
#
err() {
    i=$1 && shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $i
}

# Description:
# Convert relative path to absolute path
#
# Parameters:
# <"$1"> - path
#
# Returns:
# $PWD/$1,
# $1
#
get_fpath() {
    case "$1" in
        "/"*) ;;
        *) i=$(printf "%s/%s" "$PWD" "$1") && set -- "$i" ;;
    esac

    printf "%s" "$1"
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <'$1'> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is, on its own, $2)
#
# Returns:
# (0) substring exists
# (1) no substring
#
grep_str() {
    if [ $# -eq 3 ]; then
        if [ $3 -eq 1 ]; then
            case "$2" in
                "$1"*) grep_str=0 && return 0 ;;
            esac
        elif [ $3 -eq 2 ]; then
            case "$2" in
                *"$1") grep_str=0 && return 0 ;;
            esac
        elif [ $3 -eq 3 ]; then
            case "$2" in
                "$1") grep_str=0 && return 0 ;;
            esac
        fi
    else
        case "$2" in
            *"$1"*) grep_str=0 && return 0 ;;
        esac
    fi

    return 1
}

# Description:
# Check the existence/position of a substring in stdin
#
# Parameters:
# <'$1'> - substring
# [$2] - mode('1' - $1 is first character(s) of stdin,
#             '2' - $1 is last character(s) of stdin,
#             '3' - $1 is, on its own, stdin)
#
# Returns:
# (0) substring exists
# (1) no substring
#
grep_str_fd1() {
    if [ $# -eq 2 ]; then
        if [ $2 -eq 1 ]; then
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                case "$LINE" in
                    "$1"*) return 0 ;;
                esac
            done
        elif [ $2 -eq 2 ]; then
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                case "$LINE" in
                    *"$1") return 0 ;;
                esac
            done
        elif [ $2 -eq 3 ]; then
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                case "$LINE" in
                    "$1") return 0 ;;
                esac
            done
        fi
    else
        while IFS= read -r LINE || [ -n "$LINE" ]; do
            case "$LINE" in
                *"$1"*) return 0 ;;
            esac
        done
    fi

    return 1
}

# Description:
# Print info
#
# Parameters:
# <"$1"> - text
#
info() {
    printf "%bINFO:%b %s\n" "\033[1;37m" "\033[0m" "$1"
}

# Description:
# Remove specific character(s) in string
#
# Parameters:
# <'$1'> - character(s)
# <"$2"> - string
#
# Returns:
# $2 without $1 characters,
# $2
#
remchars() {
    i=$IFS

    IFS=$1
    set -- $2

    IFS=
    set -- $*

    printf "%s\n" "$*"

    IFS=$i
}

# Description:
# Get substring after (from / up to) specific (N)character(s) in a string
#
# Parameters:
# [$1] - from left to right N $2 character(s)
# <'$2'> - from character(s)
# [$3] - up to N $4 character(s)
# ['$4'] - up to character(s)
# <"$5"> - string
#
# Returns:
# (0) substring of $5 | undefined behaviour if $2/$4 not present
# (1) undefined behaviour
#
substr_after() {
    x=0

    if [ $# -eq 5 ]; then
        i=$(printf "%s" "$5")
        until [ $x -eq $1 ]; do
            i=$(printf "%s" "${i#*$2}")
            x=$((x + 1))
        done
        x=0
        ii="$i"
        until [ $x -eq $3 ]; do
            i=$(printf "%s" "${i#*$4}")
            x=$((x + 1))
        done
        i=$(printf "%s" "${ii%$i}")
    elif [ $# -eq 4 ]; then
        i=$(printf "%s" "$4")
        case "$1" in
            '' | *[!0-9]*)
                i=$(printf "%s" "${i##*$1}")
                ii="$i"
                until [ $x -eq $2 ]; do
                    i=$(printf "%s" "${i#*$3}")
                    x=$((x + 1))
                done
                i=$(printf "%s" "${ii%$i}")
            ;;
            *)
                until [ $x -eq $1 ]; do
                    i=$(printf "%s" "${i#*$2}")
                    x=$((x + 1))
                done
                ii="$i"
                i=$(printf "%s" "${i##*$3}")
                i=$(printf "%s" "${ii%$i}")
            ;;
        esac
    elif [ $# -eq 3 ]; then
        i=$(printf "%s" "$3")
        case "$1" in
            '' | *[!0-9]*)
                i=$(printf "%s" "${i##*$1}")
                ii="$i"
                i=$(printf "%s" "${i##*$2}")
                i=$(printf "%s" "${ii%$i}")
            ;;
            *)
                until [ $x -eq $1 ]; do
                    i=$(printf "%s" "${i#*$2}")
                    x=$((x + 1))
                done
            ;;
        esac
    else
        i=$(printf "%s" "${2##*$1}")
    fi

    if [ -n "$i" ]; then
        case "$i" in
            " "*) i=$(printf "%s" "${i# }") ;;
        esac
        case "$i" in
            *" ") i=$(printf "%s" "${i% }") ;;
        esac

        printf "%s" "${i}"
        return 0
    fi

    return 1
}

# Description:
# Print a warning
#
# Parameters:
# <"$1"> - text
#
warn() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$1"
}

# Description:
# Apply value to location
#
# Parameters:
# <"$1"> - value
# <$2> - location
#
_fwrite() {
    [ -w "$2" ] && printf -- "%s\n" "$1" > "$2" || \
    warn "Could not apply '$1' on '$2'. (!-w)"
}

fswap_env() {
    [ -z $ssize ] && ssize=1G
    [ -z $sfile ] && sfile="$HOME"/.swapfile
}

fswap_info() {
    hash cat > /dev/null 2>&1

    info "Swap size: '$ssize'."
    info "Swap file: '$sfile'."

    if [ -n "$swappiness" ]; then
        info "Swap intensity: '$swappiness'."
    else
        TMP=$(cat /proc/sys/vm/swappiness 2> /dev/null)
        [ -n "$TMP" ] && info "Swap intensity: '$TMP'."
    fi
 
    if [ -n "$vfscp" ]; then
        info "VFS cache reclaim priority: '$vfscp'."
    else
        TMP=$(cat /proc/sys/vm/vfs_cache_pressure 2> /dev/null)
        [ -n "$TMP" ] && info "VFS cache reclaim priority: '$TMP'."
    fi

    TMP=$(cat /sys/module/zswap/parameters/enabled 2> /dev/null)
    [ -n "$TMP" ] && info "zswap: '$TMP'."

    TMP=$(cat /sys/module/zswap/parameters/compressor 2> /dev/null)
    [ -n "$TMP" ] && info "zswap compressor: '$TMP'."

    TMP=$(cat /sys/module/zswap/parameters/zpool 2> /dev/null)
    [ -n "$TMP" ] && info "zswap allocator: '$TMP'."
}

fswap_check() {
    [ $(id -u) -ne 0 ] && err 1 "EUID is not 0. (no root)"
    swapoff -a; [ -f "$sfile" ] && rm -fv "$sfile"
}

fswap_work() {
    case "$ssize" in
        *"M" | *"MiB") ssize=$(printf "%s" "${ssize%M*}"); ssize="${ssize}K" ;;
        *"G" | *"GiB") ssize=$(printf "%s" "${ssize%G*}"); ssize="${ssize}M" ;;

        *"MB") ssize=$(printf "%s" "${ssize%MB}") && ssize="${ssize}KB" ;;
        *"GB") ssize=$(printf "%s" "${ssize%GB}") && ssize="${ssize}MB" ;;

        *) err 2 "Wrong swap size specified. Supported units: M,G[B]" ;;
    esac

    case "$ssize" in
        *"B") bscount=1000 ;;
        *) bscount=1024 ;;
    esac

    dd_args='if=/dev/zero'
    dd_args="${dd_args} of=${sfile}"
    dd_args="${dd_args} bs=${ssize}"
    dd_args="${dd_args} count=${bscount}"
    dd_args="${dd_args} status=progress"
}

fswap_exec() {
    dd ${dd_args}
    chmod 600 "$sfile"
    mkswap "$sfile"
    swapon "$sfile"
}

fswap_post() {
    [ -n "$swappiness" ] && _fwrite $swappiness /proc/sys/vm/swappiness
    [ -n "$vfscp" ] && _fwrite $vfscp /proc/sys/vm/vfs_cache_pressure
}

fswap() {
    fswap_env;
    [ -n "$verbose" ] && fswap_info;
    fswap_check;
    fswap_work;
    fswap_exec;
    fswap_post;
}

main() {
    # For security reasons, unset conditional variables if they exist
    [ -n "$sfile" ] && unset sfile
    [ -n "$ssize" ] && unset ssize
    [ -n "$swappiness" ] && unset swappiness
    [ -n "$vfscp" ] && unset vfscp
    [ -n "$check" ] && unset check
    [ -n "$verbose" ] && unset verbose
    [ -n "$RC" ] && unset RC

    # Serve the script until no script parameters passed
    while [ "$1" ]; do
        # Reset variables from previous loop run
        [ -n "$grep_str" ] && unset grep_str

        case "$1" in
            # Parse specific options first
            "--help") usage && return 0 ;;

            # Parse options
            "--"*)
                i=$(substr_after 1 '--' "$1")

                if grep_str 'location' "$i" 1; then
                    if grep_str 'location=' "$i" 1; then
                        sfile=$(substr_after 1 '=' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif ! grep_str 'location ' "$i " 1; then
                        sfile=$(substr_after 1 'n' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif [ "$2" ]; then
                        sfile="$2"
                        sfile=$(get_fpath "$sfile")
                        shift 2 && continue
                    fi
                fi
                if grep_str 'size' "$i" 1; then
                    if grep_str 'size=' "$i" 1; then
                        ssize=$(substr_after 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'size ' "$i " 1; then
                        ssize=$(substr_after 1 'e' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        ssize="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'swappiness' "$i" 1; then
                    if grep_str 'swappiness=' "$i" 1; then
                        swappiness=$(substr_after 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'swappiness ' "$i " 1; then
                        swappiness=$(substr_after 3 's' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        swappiness="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'vfs-cache-pressure' "$i" 1; then
                    if grep_str 'vfs-cache-pressure=' "$i" 1; then
                        vfscp=$(substr_after 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'vfs-cache-pressure ' "$i " 1; then
                        vfscp=$(substr_after 3 'e' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        vfscp="$2"
                        shift 2 && continue
                    fi
                fi

                if grep_str 'check' "$i" 3; then check=1; fi 
                if grep_str 'verbose' "$i" 3; then verbose=1; fi 

                if [ ! $grep_str ]; then
                    warn "Unrecognized option: '$1'. See --help"
                fi
                shift
            ;;
            "-"*)
                i=$(substr_after 1 '-' "$1")

                if grep_str 'l' "$i" 1; then
                    if grep_str 'l=' "$i" 1; then
                        sfile=$(substr_after 1 '=' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif ! grep_str 'l ' "$i " 1; then
                        sfile=$(substr_after 1 'l' "$i")
                        sfile=$(get_fpath "$sfile")
                        shift && continue
                    elif [ "$2" ]; then
                        sfile="$2"
                        sfile=$(get_fpath "$sfile")
                        shift 2 && continue
                    fi
                fi
                if grep_str 's' "$i" 1; then
                    if grep_str 's=' "$i" 1; then
                        ssize=$(substr_after 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 's ' "$i " 1; then
                        ssize=$(substr_after 1 's' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        ssize="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'S' "$i" 1; then
                    if grep_str 'S=' "$i" 1; then
                        swappiness=$(substr_after 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'S ' "$i " 1; then
                        swappiness=$(substr_after 1 'S' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        swappiness="$2"
                        shift 2 && continue
                    fi
                fi
                if grep_str 'V' "$i" 1; then
                    if grep_str 'V=' "$i" 1; then
                        vfscp=$(substr_after 1 '=' "$i")
                        shift && continue
                    elif ! grep_str 'V ' "$i " 1; then
                        vfscp=$(substr_after 1 'V' "$i")
                        shift && continue
                    elif [ "$2" ]; then
                        vfscp="$2"
                        shift 2 && continue
                    fi
                fi

                if grep_str 'c' "$i"; then check=1; fi
                if grep_str 'v' "$i"; then verbose=1; fi

                i=$(remchars 'cv' "$i")
                if [ -n "$i" ]; then
                    warn "Unrecognized option(s): '-$i'. See --help"
                fi
                shift
            ;;

            *)
               warn "Unrecognized option(s): '$1'. See --help"
               shift && continue
            ;;
        esac
    done

    # Take specific actions for special options
    if [ -n "$check" ]; then
        fswap_env && fswap_check
        return 0
    fi

    # Execute the core function
    fswap;

    # Check if RC is set, otherwise explicit success
    [ -n "$RC" ] && return $RC || return 0
}

main "$@"
