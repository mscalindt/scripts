#!/bin/sh
# SPDX-License-Identifier: GPL-3.0
# shellcheck disable=SC2046 # ShellCheck incorrect pedantic warning
# shellcheck disable=SC2048 # ShellCheck incorrect pedantic warning

_copyright() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'COPYRIGHT'
Copyright (C) 2021-2022 Dimitar Yurukov <mscalindt@protonmail.com>
COPYRIGHT
}

_description() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'DESCRIPTION'
Create a swap file.
DESCRIPTION
}

_license() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'LICENSE'
License GPLv3: GNU GPL version 3
LICENSE
}

_misc() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'MISC'
The SIZE argument is an integer followed by a unit.
Units are M, G (powers of 1024) or MB, GB (powers of 1000).
Binary prefixes can also be used: MiB=M, GiB=G.

If '-l'/'--location' is not specified, default value is '$HOME/.swapfile'.
If '-s'/'--size' is not specified, default value is '1G'.

External utilities hard dependency list:
chmod, dd, id, mkswap, rm, swapoff, swapon.
External utilities soft dependency list:
cat.
MISC
}

_notice() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'NOTICE'
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
NOTICE
}

_options() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'OPTIONS'
Options:
  -c, --check                only check for an existing swap file and remove
                             it; this option disregards other options
  -l, --location <PATH>      PATH is an absolute or relative location at which
                             the swap file shall be created
      --no-color             colorless output on all streams
  -s, --size <SIZE>          specify size for the swap file; see SIZE format
                             below
  -S, --swappiness <0-200>   specify swap intensity; value persists until
                             reboot
  -v, --vfs-cache-pressure <0-2147483647>
                             specify VFS cache reclaim priority; value persists
                             until reboot
      --help     display this help text and exit
      --version  display version information and exit
OPTIONS
}

_usage() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'USAGE'
Usage: fswap [options] [-c]
USAGE
}

_version() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'VERSION'
fswap 0.0.0
VERSION
}

usage() {
    _usage; _description; echo
    _options; echo
    _misc;
}

version() {
    _version; echo
    _copyright; echo
    _license; _notice;
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err() {
    i=$1 && shift
    printf "\nERROR: %s\n\n" "$*" 1>&2
    exit $i
}

# Description:
# Print colorful error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err_clr() {
    i=$1 && shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $i
}

# Description:
# Convert relative path to absolute path
#
# Parameters:
# <"$1"> - path
#
# Returns:
# (0) absolute $1 | $1
#
get_fpath() {
    case "$1" in
        /*) printf "%s" "$1" ;;
        *) printf "%s/%s" "$PWD" "$1" ;;
    esac
}

# Description:
# Print info
#
# Parameters:
# <"$1"+> - text
#
# Returns:
# (0) text
#
info() {
    printf "INFO: %s\n" "$*"
}

# Description:
# Print colorful info
#
# Parameters:
# <"$1"+> - text
#
# Returns:
# (0) text
#
info_clr() {
    printf "%bINFO:%b %s\n" "\033[1;37m" "\033[0m" "$*"
}

# Description:
# Print info with printf prefix before text
#
# Parameters:
# <"$1"> - printf prefix
# <"$2"+> - text
#
# Returns:
# (0) text
#
info_px() {
    i="$1" && shift
    printf "INFO: $i%s\n" "$*"
}

# Description:
# Print colorful info with printf prefix before text
#
# Parameters:
# <"$1"> - printf prefix
# <"$2"+> - text
#
# Returns:
# (0) text
#
info_px_clr() {
    i="$1" && shift
    printf "%bINFO:%b $i%s\n" "\033[1;37m" "\033[0m" "$*"
}

# Description:
# Print a warning
#
# Parameters:
# <"$1"+> - text
#
# Returns:
# (0) text
#
warn() {
    printf "WARNING: %s\n" "$*"
}

# Description:
# Print a colorful warning
#
# Parameters:
# <"$1"+> - text
#
# Returns:
# (0) text
#
warn_clr() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$*"
}

# Description:
# Write value to a file (overwrite)
#
# Parameters:
# <"$1"> - value
# <"$2"> - file
#
# Returns:
# (0) success
# (1) not a file | file does not exist
# (2) file access error
#
_fwrite() {
    [ -f "$2" ] || return 1

    if [ ! -w "$2" ]; then
        case "$(cat "$2" 2> /dev/null)" in
            "$1") return 0 ;;
        esac

        return 2
    fi

    printf "%s\n" "$1" > "$2"
}

_fswap() {
    case ":$ncolor$NO_COLOR" in
        :)
            ES_inf="\033[1;37m"
            ES_neg="\033[1;31m"
            ES_pos="\033[1;32m"
            ES_res="\033[0m"

            err() { err_clr "$@"; }
            info() { info_clr "$@"; }
            info_px() { info_px_clr "$@"; }
            warn() { warn_clr "$@"; }
        ;;
        *)
            ES_inf=
            ES_neg=
            ES_pos=
            ES_res=
        ;;
    esac
}

fswap_env() {
    ss_path=/proc/sys/vm/swappiness
    vfscp_path=/proc/sys/vm/vfs_cache_pressure
    zswap_path=/sys/module/zswap/parameters/enabled
    zswapar_path=/sys/module/zswap/parameters/zpool
    zswapcr_path=/sys/module/zswap/parameters/compressor

    [ "$ssize" ] || ssize=1G
    [ "$sfile" ] || sfile="$HOME"/.swapfile
}

fswap_check() {
    case $(id -u) in
        0) : ;;
        *) err 2 "EUID is not 0. (no root)" ;;
    esac

    swapoff -a || exit $?

    [ -f "$sfile" ] && rm -f "$sfile"
}

fswap_info() {
    TMP=$(cat $zswap_path 2> /dev/null)
    [ "$TMP" ] && info_px "${ES_inf}MISC:${ES_res} " "zswap: '$TMP'."

    TMP=$(cat $zswapcr_path 2> /dev/null)
    [ "$TMP" ] && info_px "${ES_inf}MISC:${ES_res} " "zswap compressor: '$TMP'."

    TMP=$(cat $zswapar_path 2> /dev/null)
    [ "$TMP" ] && info_px "${ES_inf}MISC:${ES_res} " "zswap allocator: '$TMP'."

    TMP=$(cat $ss_path 2> /dev/null)
    case "$swappiness:$TMP" in
        :)
            :
        ;;
        :"$TMP" | "$TMP":"$swappiness")
            info "Swap intensity: '$TMP'."
        ;;
        *)
            info_px "${ES_neg}OLD:${ES_res} " "Swap intensity: '$TMP'."
            info_px "${ES_pos}NEW:${ES_res} " "Swap intensity: '$swappiness'."
        ;;
    esac

    TMP=$(cat $vfscp_path 2> /dev/null)
    case "$vfscp:$TMP" in
        :)
            :
        ;;
        :"$TMP" | "$TMP":"$vfscp")
            info "VFS cache reclaim priority: '$TMP'."
        ;;
        *)
            info_px "${ES_neg}OLD:${ES_res} " "VFS cache reclaim priority:" \
                    "'$TMP'."
            info_px "${ES_pos}NEW:${ES_res} " "VFS cache reclaim priority:" \
                    "'$vfscp'."
        ;;
    esac

    info "Swap size: '$ssize'."
    info "Swap file: '$sfile'."
}

fswap_work() {
    case "$ssize" in
        *"M" | *"MiB") ssize="${ssize%M*}K" ;;
        *"G" | *"GiB") ssize="${ssize%G*}M" ;;
        *"MB") ssize="${ssize%MB}KB" ;;
        *"GB") ssize="${ssize%GB}MB" ;;
        *) err 2 "Wrong swap size specified. Supported units: M,G[B]" ;;
    esac

    case "$ssize" in
        *"B") bscount=1000 ;;
        *) bscount=1024 ;;
    esac
}

fswap_exec() {
    dd "if=/dev/zero" "of=$sfile" \
       "bs=$ssize" "count=$bscount" \
       "status=progress" && \
    chmod 600 "$sfile" && \
    mkswap "$sfile" && \
    swapon "$sfile"
}

fswap_post() {
    if [ "$swappiness" ]; then
        _fwrite $swappiness $ss_path || {
            warn "Failed to apply '$swappiness' on '$ss_path'. (RC = $?)"
        }
    fi

    if [ "$vfscp" ]; then
        _fwrite $vfscp $vfscp_path || {
            warn "Failed to apply '$vfscp' on '$vfscp_path'. (RC = $?)"
        }
    fi
}

fswap() {
    _fswap;
    fswap_env;
    fswap_check;
    fswap_info;
    fswap_work;
    fswap_exec || exit $?
    fswap_post;
}

main_functions() {
    # Description:
    # Within single quotes escape single quote(s) in string
    #
    # Parameters:
    # <"$1"+> - string
    #
    # Returns:
    # (0) escaped string | string
    #
    esc_sq() {
        case ":$1" in :) return 0 ;; esac

        case "$1" in
            *"'"*)
                ii="${1%%\'*}'\\''"
                i="${ii}${1#*\'}"

                while :; do case "$i" in
                    "$ii"*"'"*)
                        iii="${i#*"$ii"}" && iii="${iii%%\'*}"
                        i="${ii}${iii}'\\''${i#*"${ii}${iii}"\'}"
                        ii="${ii}${iii}'\\''"
                    ;;
                    *)
                        break
                    ;;
                esac done
            ;;
            *)
                i="$1"
            ;;
        esac

        printf "'%s'" "$i"; shift

        while [ "$1" ]; do
            case "$1" in
                *"'"*) : ;;
                *) printf " '%s'" "$1"; shift && continue ;;
            esac

            ii="${1%%\'*}'\\''"
            i="${ii}${1#*\'}"

            while :; do case "$i" in
                "$ii"*"'"*)
                    iii="${i#*"$ii"}" && iii="${iii%%\'*}"
                    i="${ii}${iii}'\\''${i#*"${ii}${iii}"\'}"
                    ii="${ii}${iii}'\\''"
                ;;
                *)
                    break
                ;;
            esac done

            printf " '%s'" "$i"; shift
        done
    }

    # Description:
    # Signify invalid operand count (min)[0>X]
    #
    opd_min() {
        set -- "${0##*/}"
        printf "%s: No operand specified.\n" "$1" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[X>1]
    #
    # Parameters:
    # <"$1"> - count
    #
    opd_cmax() {
        set -- "${0##*/}" "$1"
        printf "%s: Too many operands: %d\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[2>1]
    #
    # Parameters:
    # <"$1"> - first operand
    # <"$2"> - second operand
    #
    opd_max() {
        set -- "${0##*/}" "$1" "$2"
        printf "%s: Too many operands: '[%s]; [%s]'\n" "$1" "$2" "$3" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_invalid() {
        set -- "${0##*/}" "$1"
        printf "%s: Invalid option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unknown (*) option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unknown() {
        set -- "${0##*/}" "$1"
        printf "%s: Unknown option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unrecognized ('--') option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unrecognized() {
        set -- "${0##*/}" "$1"
        printf "%s: Unrecognized option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Return 0 if complex (arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # <"$ii"> - option argument
    # <"$n"> - shift count
    #
    copt() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        esac

        case "$ii:$i " in
            :"$1 ")
                printf "%s: Option '%s' requires an argument.\n" \
                       "${0##*/}" "$1" 1>&2
                printf "%s: Try '%s --help' for more information.\n" \
                       "${0##*/}" "${0##*/}" 1>&2
                exit 2
           ;;
        esac

        case "$i" in
        "--"*)
            case "$i " in
                "$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1 ")
                    i=; n=2
                    return 0
                ;;
                "$1="*)
                    i=; ii="${i#"$1"=}"; n=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$i " in
                "$1 ")
                    i=; n=2
                    return 0
                ;;
                "$1"*)
                    i=; ii="${i#"$1"}"; n=1
                    return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if perhaps complex (arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # ["$ii"] - option argument
    # <"$n"> - shift count
    #
    copt_optional() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    i=; ii=; n=1
                    return 0
                ;;
                "$1="*)
                    i=; ii="${i#"$1"=}"; n=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1")
                    i=; ii=; n=1
                    return 0
                ;;
                "$1"*)
                    i=; ii="${i#"$1"}"; n=1
                    return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific complex (arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # <"$ii"> - option argument
    # <"$n"> - shift count
    #
    scopt() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$ii:$i " in
                :"$1 ")
                    printf "%s: Option '%s' requires an argument.\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$ii:$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$ii:$1 ")
                    i=; n=2
                    return 0
                ;;
                "$ii:$1="*)
                    i=; ii="${i#"$1"=}"; n=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if specific perhaps complex (arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # ["$ii"] - option argument
    # <"$n"> - shift count
    #
    scopt_optional() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$i" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    i=; ii=; n=1
                    return 0
                ;;
                "$1="*)
                    i=; ii="${i#"$1"=}"; n=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if simple (!arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    sopt() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1")
                    i=; n=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1"*)
                    case ":$optind" in
                        :) optind="@$1@" ;;
                        *) optind="$optind @$1@" ;;
                    esac

                    i="-${i#??}"; n=1
                    return 0
               ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific simple (!arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    ssopt() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$i" in
                "$1")
                    i=; n=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }
}

# Description:
# Reorder positional parameters (string priority = LIFO)
#
# Parameters:
# <$1> - mode('0' - normal operation,
#             '1' - respect end of options)
# <"$2"+> - string
# <$3> - --
# <"$4"> - $@
#
# Provides:
# ["$i"] - string to evaluate (eval set -- "$i")
#
main_sargs_ro() {
    iii=$1; shift

    ii=$(
        esc_sq "$1"; shift

        while :; do case "$1" in
            --) shift && break ;;
            *) printf " "; esc_sq "$1"; shift ;;
        esac done
    )

    while :; do case "$1" in
        --) shift && break ;;
        *) shift ;;
    esac done

    case ":$*" in :) i=; return 0 ;; esac

    set -- "$(esc_sq "$@")"; i="$1"
    eval set -- "$ii"

    case $iii in
        0)
            while [ "$1" ]; do
                ii="$1"

                case "$ii" in
                    *"'"*) ii=$(esc_sq "$ii") ;;
                    *) ii="'$ii'" ;;
                esac

                case ":$i" in
                    :"$ii"*) : ;;
                    *"$ii") i="$ii ${i%% "$ii"*}${i#*"$ii"}" ;;
                    *"$ii"*) i="$ii ${i%%"$ii"*}${i#*"$ii" }" ;;
                esac

                shift
            done
        ;;
        1)
            case "$i" in
                "'--'"*) return 0 ;;
            esac

            while [ "$1" ]; do
                ii="$1"

                case "$ii" in
                    *"'"*) ii=$(esc_sq "$ii") ;;
                    *) ii="'$ii'" ;;
                esac

                case "$i" in
                    *"'--'"*)
                        iii="${i%% "'--'"*}"

                        case ":$iii" in
                            :"$ii"*) : ;;
                            *"$ii") i="$ii ${i%% "$ii"*}${i#*"$ii"}" ;;
                            *"$ii"*) i="$ii ${i%%"$ii"*}${i#*"$ii" }" ;;
                        esac
                    ;;
                    *)
                        case ":$i" in
                            :"$ii"*) : ;;
                            *"$ii") i="$ii ${i%% "$ii"*}${i#*"$ii"}" ;;
                            *"$ii"*) i="$ii ${i%%"$ii"*}${i#*"$ii" }" ;;
                        esac
                    ;;
                esac

                shift
            done
        ;;
    esac
}

# Description:
# Substitute the function call with script options
#
# Parameters:
# <"$1"> - mode('0' - print standard ('-'; '--') utility options)
#
main_options() {
    case $1 in
    0)
        sopt "--no-color" && { ncolor=1; }
        sopt "-c" "--check" && { _fswap; fswap_env; fswap_check; exit 0; }

        copt "-l" "--location" && {
            sfile=$(get_fpath "$ii")
        }
        copt "-s" "--size" && {
            ssize="$ii"
        }
        copt "-S" "--swappiness" && {
            swappiness="$ii"
        }
        copt "-v" "--vfs-cache-pressure" && {
            vfscp="$ii"
        }
    ;;
    esac
}

main() {
    # For practical reasons, unset conditional variables if they exist
    # > special:
    unset RC
    # > options:
    unset ncolor sfile ssize swappiness vfscp

    # Source common functions
    main_functions;

    # Reorder the positional parameters if needed
    #  > to prioritize specific options first
    main_sargs_ro 0 "--no-color" "-l" "--location" -- "$@"
    [ "$i" ] && eval set -- "$i"

    # Parse options
    while [ "$1" ]; do
        # Simulate global $N (positional parameters) shift
        #  > option functions modify when appropriate
        n=1

        # Simulate global $1/$2 (option/argument) handling
        #  > option functions modify when appropriate
        i="$1"; ii="$2"

        # Parse standard options
        #  > required to parse them first
        ssopt "-" && { opt_invalid "$1"; exit 2; }
        ssopt "--" && { opt_invalid "$1"; exit 2; }
        ssopt "--help" && { usage; exit 0; }
        ssopt "--version" && { version; exit 0; }

        # Loop on the option holder until fully parsed
        #  > as we might need to loop on its characters
        while [ "$i" ]; do
            unset optind

            case "$i" in
                "-"*) main_options 0 ;;
            esac

            case ":$i" in
            :)
                :
            ;;
            :"--"*)
                opt_unrecognized "$i"; exit 2
            ;;
            :"-"*)
                case ":$optind" in
                    :) opt_invalid "${i%"${i#??}"}"; exit 2 ;;
                esac

                case ${#i} in
                    1) unset optind && break ;;
                esac
            ;;
            *)
                opt_unknown "$i"; exit 2
            ;;
            esac
        done

        # Move on positional parameters
        #  > either with default value or with option value
        shift $n
    done

    # Execute the core function
    fswap;

    # Check if RC is set, otherwise explicit success
    [ "$RC" ] && return $RC || return 0
}

main "$@"
