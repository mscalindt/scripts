#!/bin/sh
# SPDX-License-Identifier: GPL-3.0
# shellcheck disable=SC2048 # ShellCheck incorrect pedantic warning

_copyright() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'COPYRIGHT'
Copyright (C) 2021-2022 Dimitar Yurukov <mscalindt@protonmail.com>
COPYRIGHT
}

_description() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'DESCRIPTION'
Do an advanced, better merge. (git wrapper)
DESCRIPTION
}

_license() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'LICENSE'
License GPLv3: GNU GPL version 3
LICENSE
}

_misc() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'MISC'
External utilities hard dependency list:
git, rm.
External utilities soft dependency list:
.
MISC
}

_notice() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'NOTICE'
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
NOTICE
}

_options() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'OPTIONS'
In-merge options (merge with conflicts):
  a, abort                   abort a merge in progress; this option disregards
                             other options
  c, continue                resume a merge; this option disregards other
                             options
  s, status                  show status of the current merge; this option
                             disregards other options

Options:
      --no-color             colorless output on all streams
  -s, --sign-off             add Signed-off-by line at the end of the commit
                             message; requires preconfigured signoff info for
                             seamless work
  -S, --gpg-sign             sign the merge commit; requires preconfigured key
                             and user.signingkey for seamless work
  -v, --git-version          print the git version at the end of the commit
                             message
      --help     display this help text and exit
      --version  display version information and exit
      --         specify end of options
OPTIONS
}

_usage() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'USAGE'
Usage: admerge [options] <a|c|s|BRANCH>
USAGE
}

_version() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'VERSION'
admerge 0.0.0
VERSION
}

usage() {
    _usage; _description; echo
    _options; echo
    _misc;
}

version() {
    _version; echo
    _copyright; echo
    _license; _notice;
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err() {
    i=$1 && shift
    printf "\nERROR: %s\n\n" "$*" 1>&2
    exit $i
}

# Description:
# Print colorful error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err_clr() {
    i=$1 && shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $i
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <"$1"> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is, on its own, $2)
#
# Returns:
# (0) substring exists
# (1) no match
#
grep_str() {
    if [ $# -eq 3 ]; then
        if [ $3 -eq 1 ]; then
            case "$2" in "$1"*) grep_str=0 && return 0 ;; esac
        elif [ $3 -eq 2 ]; then
            case "$2" in *"$1") grep_str=0 && return 0 ;; esac
        elif [ $3 -eq 3 ]; then
            case "$2" in "$1") grep_str=0 && return 0 ;; esac
        fi
    else
        case "$2" in *"$1"*) grep_str=0 && return 0 ;; esac
    fi

    return 1
}

# Description:
# Get positional substring, (from&to LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <"$2"> - from "X" character(s)
# <$3> - to "N" $2-TR character('0' - max)
# <"$4"> - to "X" character(s)
# <"$5"> - string
# [$6] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$7] - mode('3' - keep $2,
#             '4' - keep $4,
#             '5' - keep $2/$4)
# [$8] - mode('6' - verify the expansion)
#
# Returns:
# (0) substring
# (1) empty expansion (empty, or unspecified, or wrong -- shell specific)
# (2) unspecified expansion (unspecified, or empty, or wrong -- shell specific)
#
# Returns (mode '6'):
# (0) substring
# (1) unspecified expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion ($2 is not present at all)
# (3) wrong expansion ($1 is greater than the total $2 in the string)
# (4) empty expansion (empty expansion by the given ruleset)
# (5) unspecified expansion ($4 is not present at all)
# (6) wrong expansion ($3 is greater than the total $4 in the string)
#
# Caveats:
# 1. If mode 6 is NOT passed, you should NOT assume the expansion is
#    respectively correct, even if the return code is 0. This is because every
#    shell has its own unique string expander and unspecified results will vary
#    between them; for example, if $2/$4 is not present anymore or at all, one
#    shell might return the same expansion, while another might return empty
#    expansion. Also, the string expander on its own does NOT guarantee correct
#    expansion at all.
#    Fix: Use mode '6'. When mode 6 is passed, the function will do various
#    checks on each expansion to accurately determine what the expansion will
#    result into; this guarantees respectively correct expansion on any shell.
#    Performance cost should be negligible on most shells.
#
ltr_substr1() {
    if [ $# -eq 8 ] || \
       [ $# -ge 7 ] && [ $7 -eq 6 ] || \
       [ $# -ge 6 ] && [ $6 -eq 6 ]; then
        case $1 in
            0)
                case "$5" in
                    *"$2") return 1 ;;
                    *"$2"*) : ;;
                    *) return 2 ;;
                esac

                i="${5##*"$2"}"
            ;;
            *)
                case $1"$5" in
                    $1*"$2"*"$2"*) : ;;
                    1*"$2") return 1 ;;
                    $1*"$2"*) : ;;
                    *) return 2 ;;
                esac

                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"

                    case "$i" in
                        *"$2"*"$2"*) : ;;
                        *"$2") [ $((x + 2)) -eq $1 ] && return 1 ;;
                        *"$2"*) : ;;
                        *) [ $((x + 1)) -ne $1 ] && return 3 ;;
                    esac

                    x=$((x + 1))
                done
            ;;
        esac

        case $3 in
            0)
                case "$i" in
                    *"$4"*"$4"*) : ;;
                    "$4"*) return 4 ;;
                    *"$4"*) : ;;
                    *) return 5 ;;
                esac

                i="${i%"$4"*}"
            ;;
            *)
                case $3"$i" in
                    1"$4"*) return 4 ;;
                    $3*"$4"*) : ;;
                    *) return 5 ;;
                esac

                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i#*"$4"}"

                    case "$i" in
                        *"$4"*) : ;;
                        *) [ $((x + 1)) -ne $3 ] && return 6 ;;
                    esac

                    x=$((x + 1))
                done
                [ -z "$i" ] && i="${ii%"$4"}" || i="${ii%"$4""$i"}"
            ;;
        esac
    else
        case $1 in
            0)
                i="${5##*"$2"}"
            ;;
            *)
                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"
                    x=$((x + 1))
                done
            ;;
        esac

        case $3 in
            0)
                i="${i%"$4"*}"
            ;;
            *)
                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i#*"$4"}"
                    x=$((x + 1))
                done
                i="${ii%"$4""$i"}"
            ;;
        esac

        [ "$i" = "$5" ] && return 2
    fi

    if [ -n "$i" ]; then
        if [ $# -ge 6 ] && [ $6 -eq 0 ]; then
            i="${i#${i%%[![:space:]]*}}"
        elif [ $# -ge 6 ] && [ $6 -eq 1 ]; then
            i="${i%${i##*[![:space:]]}}"
        elif [ $# -ge 6 ] && [ $6 -eq 2 ]; then
            i="${i#${i%%[![:space:]]*}}"
            i="${i%${i##*[![:space:]]}}"
        fi

        if [ $# -ge 7 ] && [ $7 -eq 3 ] || \
           [ $# -ge 6 ] && [ $6 -eq 3 ]; then
            i="$2$i"
        elif [ $# -ge 7 ] && [ $7 -eq 4 ] || \
             [ $# -ge 6 ] && [ $6 -eq 4 ]; then
            i="$i$4"
        elif [ $# -ge 7 ] && [ $7 -eq 5 ] || \
             [ $# -ge 6 ] && [ $6 -eq 5 ]; then
            i="$2$i$4"
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Parse the lines of a file
#
# Parameters:
# <$1> - mode('0' - one-to-one copy,
#             '1' - wrap parsed lines in one leading/trailing whitespace
#                   character,
#             '2' - wrap parsed lines in two leading/trailing whitespace
#                   characters,
#             '3' - skip empty lines,
#             '4' - strip trailing/leading whitespace characters)
# <"$2"> - file
# [$3] - mode('5N' - stop parsing further than specified "N" line)
#
# Returns:
# (0) output | empty output (file)
# (1) not a file | file does not exist
# (2) file access error
#
parse() {
    [ -f "$2" ] || return 1
    [ -r "$2" ] || return 2

    case $# in
    3)
        x=0
        set -- $1 "$2" ${3#?}
        case $1 in
            0)
                while IFS= read -r LINE; do
                    x=$((x + 1))
                    [ $x -eq $3 ] && break
                    printf "%s\n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "%s\n" "$LINE" || printf '\n'
            ;;
            1)
                while IFS= read -r LINE; do
                    x=$((x + 1))
                    [ $x -eq $3 ] && break
                    printf " %s \n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf " %s \n" "$LINE" || printf '\n'
            ;;
            2)
                while IFS= read -r LINE; do
                    x=$((x + 1))
                    [ $x -eq $3 ] && break
                    printf "  %s  \n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "  %s  \n" "$LINE" || printf '\n'
            ;;
            3)
                while IFS= read -r LINE || [ -n "$LINE" ] ; do
                    x=$((x + 1))
                    [ -n "$LINE" ] && printf "%s\n" "$LINE"
                    [ $x -eq $3 ] && break
                done < "$2"
            ;;
            4)
                while read -r LINE; do
                    x=$((x + 1))
                    [ $x -eq $3 ] && break
                    printf "%s\n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "%s\n" "$LINE" || printf '\n'
            ;;
        esac
    ;;
    *)
        case $1 in
            0)
                while IFS= read -r LINE; do
                    printf "%s\n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "%s\n" "$LINE" || printf '\n'
            ;;
            1)
                while IFS= read -r LINE; do
                    printf " %s \n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf " %s \n" "$LINE" || printf '\n'
            ;;
            2)
                while IFS= read -r LINE; do
                    printf "  %s  \n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "  %s  \n" "$LINE" || printf '\n'
            ;;
            3)
                while IFS= read -r LINE || [ -n "$LINE" ] ; do
                    [ -n "$LINE" ] && printf "%s\n" "$LINE"
                done < "$2"
            ;;
            4)
                while read -r LINE; do
                    printf "%s\n" "$LINE"
                done < "$2"
                [ -n "$LINE" ] && printf "%s\n" "$LINE" || printf '\n'
            ;;
        esac
    ;;
    esac

    return 0
}

# Description:
# Print specific line in file
#
# Parameters:
# <$1> - line number
# <"$2"> - file
#
# Returns:
# (0) line's content | line empty
# (1) line does not exist
# (2) not a file | file does not exist
# (3) file access error
#
pline() {
    x=0

    [ -f "$2" ] || return 2
    [ -r "$2" ] || return 3

    while read -r LINE; do
        x=$((x + 1))
        [ $x -eq $1 ] && printf "%s" "$LINE" && return 0
    done < "$2"
    [ $((x + 1)) -eq $1 ] && printf "%s" "$LINE" && return 0

    return 1
}

# Description:
# Get N attribute in the lock file
#
# Parameters:
# <$1> - N
#
# Returns:
# (0) N attribute
# (1) N attribute does not exist
#
_aq() {
    x=$1
    i=$(pline 1 "$ALOCK")
    x=$((x - 1 + x))
    i=$(ltr_substr1 $x '@' 1 '@' "$i" 6)

    [ -n "$i" ] && printf "%s" "$i" && return 0

    return 1
}

# Description:
# Check if an attribute exists in the lock file
#
# Parameters:
# <"$1"> - attribute
#
# Returns:
# (0) attribute exists
# (1) no attribute
#
_ac() {
    i=$(pline 1 "$ALOCK") && grep_str "@$1@" "$i" && return 0

    return 1
}

# Description:
# Return lock format for an attribute
#
# Parameters:
# <"$1"> - attribute('1' - begin lock format,
#                    '2' - end lock format)
# ['$2'] - test variable
#
# Returns:
# (0) format
# (1) variable is empty/unset
#
_aw() {
    case $# in
        2) i=$(eval "printf \"%s\" \"$2\"") && [ ! "$i" ] && return 1 ;;
    esac

    case "$1" in
        1) printf " " ;;
        2) printf " \n" ;;
        *) printf "@%s@ " "$1" ;;
    esac
}

# Description:
# Run a git command for the msg file
#
# Parameters:
# <"$1"> - printf format('1' - "%s\n",
#                        '2' - "%s\n\n",
#                        '3' - "\n%s\n")
# ["$2"] - command
# ['$3'] - test variable
# [$4] - mode('0' - unique commits, "..",
#             '1' - unique commits of both, "...")
#
# Returns:
# (0) output
# (1) variable is empty/unset | no command output
#
_mc() {
    case $# in
    4)
        i=$(eval "printf \"%s\" \"$3\"") && [ ! "$i" ] && return 1
        case $4 in
            0) i=$(git $2 ${OBR}..${BRANCH} 2> /dev/null) ;;
            1) i=$(git $2 ${OBR}...${BRANCH} 2> /dev/null) ;;
        esac
    ;;
    3)
        case "$3" in
            '$'*) i=$(eval "printf \"%s\" \"$3\"") && [ ! "$i" ] && return 1 ;;
        esac
        case "$3" in
            0) i=$(git $2 ${OBR}..${BRANCH} 2> /dev/null) ;;
            1) i=$(git $2 ${OBR}...${BRANCH} 2> /dev/null) ;;
            *) i=$(git $2 2> /dev/null) ;;
        esac
    ;;
    2)
        case "$2" in
            '$'*)
                i=$(eval "printf \"%s\" \"$2\"") && [ ! "$i" ] && return 1
                printf "$1" && return 0
            ;;
            *) i=$(git $2 2> /dev/null) ;;
        esac
    ;;
    *) printf "$1" && return 0 ;;
    esac

    if [ -n "$i" ]; then
        case "$1" in
            1) printf "%s\n" "$i" ;;
            2) printf "%s\n\n" "$i" ;;
            3) printf "\n%s\n" "$i" ;;
            *) printf "$1" "$i" ;;
        esac
        return 0
    fi

    return 1
}

_admerge() {
    case ":$ncolor" in
        :)
            err() { err_clr "$@"; }
            admerge_status() { admerge_status_clr; }
            git() { command git -c color.ui=always "$@"; }
        ;;
        *)
            git() { command git -c color.ui=never "$@"; }
        ;;
    esac

    hash git > /dev/null 2>&1
}

admerge_env() {
    OBR=$(git symbolic-ref --short HEAD 2> /dev/null)
    ALOCK="$PWD"/.git/admerge_lock
    AMSG="$PWD"/.git/admerge_msg
}

admerge_check() {
    case ":$OBR" in
        :) err 2 "Failed to identify current branch. (not in .git dir?)" ;;
    esac

    if [ -r "$ALOCK" ]; then
        err 2 "A merge is already in progress. ($ALOCK)"
    fi

    if [ -r "$AMSG" ]; then
        rm -f "$AMSG"
    fi
}

admerge_lock() {
    {
    _aw "1"
    _aw "$BRANCH"
    _aw "s" '$soff'
    _aw "S" '$gsign'
    _aw "2"
    } >> "$ALOCK"
}

admerge_msg() {
    {
    _mc "Merge '$BRANCH' into '$OBR'\n\n"
    _mc "Summary of commits (%d):\n" "rev-list --count" 0
    _mc "1" "log --oneline" 0
    _mc "3" "--version" '$gver'
    } >> "$AMSG"
}

admerge_work() {
    gitm_args="--no-ff --no-commit $BRANCH"
    gitc_args="-eF $AMSG --no-edit"

    if [ -r "$ALOCK" ]; then
        _ac "s" && gitc_args="--signoff ${gitc_args}"
        _ac "S" && gitc_args="--gpg-sign ${gitc_args}"
    fi
}

admerge_exec() {
    if ! git merge ${gitm_args}; then
        if git merge HEAD > /dev/null 2>&1; then
            RC=1 && return 1
        else
            exit 1
        fi
    fi

    if git merge HEAD > /dev/null 2>&1; then
        return 0
    fi

    git commit ${gitc_args} || exit $?
}

admerge_post() {
    rm -f "$ALOCK" "$AMSG"
}

admerge_abort() {
    admerge_env;

    case ":$OBR" in
        :) err 2 "Failed to identify current branch. (not in .git dir?)" ;;
    esac

    if [ ! -r "$ALOCK" ]; then
        err 2 "No lock file found. (no merge in progress?)"
    fi

    git merge --abort || exit $?

    admerge_post;
}

admerge_continue() {
    admerge_env;

    case ":$OBR" in
        :) err 2 "Failed to identify current branch. (not in .git dir?)" ;;
    esac

    if [ ! -r "$ALOCK" ]; then
        err 2 "No lock file found. (no merge in progress?)"
    fi

    admerge_work;

    git commit ${gitc_args} || exit $?

    admerge_post;
}

admerge_status() {
    admerge_env;

    case ":$OBR" in
        :) err 2 "Failed to identify current branch. (not in .git dir?)" ;;
    esac

    if [ ! -r "$ALOCK" ]; then
        err 2 "No lock file found. (no merge in progress?)"
    fi

    printf "Our branch: [\n%s\n]\n" "$OBR"
    printf "Their branch: [\n%s\n]\n" "$(_aq 1)"

    printf "Lock file location: [\n%s\n]\n" "$ALOCK"
    printf "Lock file content: [\n%s\n]\n" "$(pline 1 "$ALOCK")"

    printf "Commit message file location: [\n%s\n]\n" "$AMSG"
    printf "Commit message file content: [\n%s\n]\n" "$(parse 0 "$AMSG")"

    printf "Status of files: [\n%s\n]\n" "$(git status -s)"
}

admerge_status_clr() {
    admerge_env;

    case ":$OBR" in
        :) err 2 "Failed to identify current branch. (not in .git dir?)" ;;
    esac

    if [ ! -r "$ALOCK" ]; then
        err 2 "No lock file found. (no merge in progress?)"
    fi

    printf "%bOur branch: [%b\n%s\n%b]%b\n" \
           "\033[1;37m" "\033[0m" \
           "$OBR" \
           "\033[1;37m" "\033[0m"
    printf "%bTheir branch: [%b\n%s\n%b]%b\n" \
           "\033[1;37m" "\033[0m" \
           "$(_aq 1)" \
           "\033[1;37m" "\033[0m"

    printf "%bLock file location: [%b\n%s\n%b]%b\n" \
           "\033[1;37m" "\033[0m" \
           "$ALOCK" \
           "\033[1;37m" "\033[0m"
    printf "%bLock file content: [%b\n%s\n%b]%b\n" \
           "\033[1;37m" "\033[0m" \
           "$(pline 1 "$ALOCK")" \
           "\033[1;37m" "\033[0m"

    printf "%bCommit message file location: [%b\n%s\n%b]%b\n" \
           "\033[1;37m" "\033[0m" \
           "$AMSG" \
           "\033[1;37m" "\033[0m"
    printf "%bCommit message file content: [%b\n%s\n%b]%b\n" \
           "\033[1;37m" "\033[0m" \
           "$(parse 0 "$AMSG")" \
           "\033[1;37m" "\033[0m"

    printf "%bStatus of files: [%b\n%s\n%b]%b\n" \
           "\033[1;37m" "\033[0m" \
           "$(git status -s)" \
           "\033[1;37m" "\033[0m"
}

admerge() {
    _admerge;
    admerge_env;
    admerge_check;
    admerge_lock;
    admerge_msg;
    admerge_work;
    admerge_exec;
    admerge_post;
}

main_functions() {
    # Description:
    # Signify invalid operand count (min)[0>X]
    #
    opd_min() {
        set -- "${0##*/}"
        printf "%s: No operand specified.\n" "$1" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[X>1]
    #
    # Parameters:
    # <"$1"> - count
    #
    opd_cmax() {
        set -- "${0##*/}" "$1"
        printf "%s: Too many operands: %d\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[2>1]
    #
    # Parameters:
    # <"$1"> - first operand
    # <"$2"> - second operand
    #
    opd_max() {
        set -- "${0##*/}" "$1" "$2"
        printf "%s: Too many operands: '[%s]; [%s]'\n" "$1" "$2" "$3" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_invalid() {
        set -- "${0##*/}" "$1"
        printf "%s: Invalid option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unknown (*) option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unknown() {
        set -- "${0##*/}" "$1"
        printf "%s: Unknown option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unrecognized ('--') option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unrecognized() {
        set -- "${0##*/}" "$1"
        printf "%s: Unrecognized option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Return 0 if complex (arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # <"$ii"> - option argument
    # <"$n"> - shift count
    #
    copt() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        esac

        case "$ii:$i " in
            :"$1 ")
                printf "%s: Option '%s' requires an argument.\n" \
                       "${0##*/}" "$1" 1>&2
                printf "%s: Try '%s --help' for more information.\n" \
                       "${0##*/}" "${0##*/}" 1>&2
                exit 2
           ;;
        esac

        case "$i" in
        "--"*)
            case "$i " in
                "$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1 ")
                    n=2
                    unset i; return 0
                ;;
                "$1="*)
                    ii="${i#"$1"=}"; n=1
                    unset i; return 0
                ;;
            esac
        ;;
        "-"*)
            case "$i " in
                "$1 ")
                    n=2
                    unset i; return 0
                ;;
                "$1"*)
                    ii="${i#"$1"}"; n=1
                    unset i; return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if perhaps complex (arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # ["$ii"] - option argument
    # <"$n"> - shift count
    #
    copt_optional() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    n=1
                    unset i ii; return 0
                ;;
                "$1="*)
                    ii="${i#"$1"=}"; n=1
                    unset i; return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1")
                    n=1
                    unset i ii; return 0
                ;;
                "$1"*)
                    ii="${i#"$1"}"; n=1
                    unset i; return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific complex (arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # <"$ii"> - option argument
    # <"$n"> - shift count
    #
    scopt() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$ii:$i " in
                :"$1 ")
                    printf "%s: Option '%s' requires an argument.\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$ii:$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$ii:$1 ")
                    n=2
                    unset i; return 0
                ;;
                "$ii:$1="*)
                    ii="${i#"$1"=}"; n=1
                    unset i; return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if specific perhaps complex (arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # ["$ii"] - option argument
    # <"$n"> - shift count
    #
    scopt_optional() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$i" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    n=1
                    unset i ii; return 0
                ;;
                "$1="*)
                    ii="${i#"$1"=}"; n=1
                    unset i; return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if simple (!arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    sopt() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1")
                    n=1
                    unset i; return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1"*)
                    case ":$optind" in
                        :) optind="@$1@" ;;
                        *) optind="$optind @$1@" ;;
                    esac

                    i="-${i#??}"; n=1
                    return 0
               ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific simple (!arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    ssopt() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$i" in
                "$1")
                    n=1
                    unset i; return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }
}

# Description:
# Substitute the function call with script options
#
# Parameters:
# <"$1"> - mode('0' - print standard ('-'; '--') utility options,
#               '1' - print miscellaneous (*) options)
#
main_options() {
    case $1 in
    0)
        sopt "--no-color" && { ncolor=1; }
        sopt "-s" "--sign-off" && { soff=1; }
        sopt "-S" "--gpg-sign" && { gsign=1; }
        sopt "-v" "--git-version" && { gver=1; }
    ;;
    1)
        ssopt "a" "abort" && { _admerge; admerge_abort; exit 0; }
        ssopt "c" "continue" && { _admerge; admerge_continue; exit 0; }
        ssopt "s" "status" && { _admerge; admerge_status; exit 0; }
    ;;
    esac
}

main() {
    # For practical reasons, unset conditional variables if they exist
    # > special:
    unset RC BRANCH
    # > options:
    unset ncolor soff gsign gver

    # Source common functions
    main_functions;

    # Parse options
    while [ "$1" ]; do
        # Simulate global $N (positional parameters) shift
        #  > option functions modify when appropriate
        n=1

        # Simulate global $1/$2 (option/argument) handling
        #  > option functions modify when appropriate
        i="$1"; ii="$2"

        # Parse standard options
        #  > required to parse them first
        ssopt "-" && { opt_invalid "$1"; exit 2; }
        ssopt "--" && { shift && break; }
        ssopt "--help" && { usage; exit 0; }
        ssopt "--version" && { version; exit 0; }

        # Loop on the option holder until fully parsed
        #  > as we might need to loop on its characters
        while [ -n "$i" ]; do
            unset optind

            case "$i" in
                "-"*) main_options 0 ;;
                *) main_options 1 ;;
            esac

            case ":$i" in
            :)
                :
            ;;
            :"--"*)
                opt_unrecognized "$i"; exit 2
            ;;
            :"-"*)
                case ":$optind" in
                    :) opt_invalid "${i%"${i#??}"}"; exit 2 ;;
                esac

                case ${#i} in
                    1) unset optind && break ;;
                esac
            ;;
            *)
                case ":$BRANCH" in
                    :) BRANCH="$i" ;;
                    *) opd_max "$BRANCH" "$i"; exit 2 ;;
                esac

                break
            ;;
            esac
        done

        # Move on positional parameters
        #  > either with default value or with option value
        shift $n
    done

    # Parse operands
    while [ "$1" ]; do
        i="$1"

        case ":$BRANCH" in
            :) BRANCH="$i" ;;
            *) opd_max "$BRANCH" "$i"; exit 2 ;;
        esac

        shift
    done

    # Here and no branch specified -> bad input
    case ":$BRANCH" in
        :) opd_min; exit 2 ;;
    esac

    # Execute the core function
    admerge;

    # Check if RC is set, otherwise explicit success
    [ -n "$RC" ] && return $RC || return 0
}

main "$@"
