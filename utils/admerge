#!/bin/sh
# shellcheck disable=SC2016
# shellcheck disable=SC2034
# shellcheck disable=SC2046
# shellcheck disable=SC2048
# shellcheck disable=SC2086

: <<'notice'
 * SPDX-License-Identifier: GPL-3.0
 *
 * Copyright (C) 2021 Dimitar Yurukov <mscalindt@protonmail.com>
 *
notice

usage() {
printf "%s" "\
Usage: admerge [options] [--] [BRANCH]
Do an advanced, better merge. (git wrapper)

Options:
  -s, --sign-off             add Signed-off-by line at the end of the commit
                             message; requires preconfigured signoff info
  -S, --gpg-sign             sign the merge commit; requires preconfigured key
                             and user.signingkey
  -v, --git-version          print the git version at the end of the commit
                             message
      --help     display this help text and exit
      --         specify end of options

In-merge options (merge with conflicts):
  a, abort                   abort a merge in progress; this option disregards
                             other options
  c, continue                resume a merge; this option disregards other
                             options
  s, status                  show status of the current merge; this option
                             disregards other options

External utilities dependency list:
git, rm.
"
}

# Description:
# Get substring after (from / up to) specific (N)character(s) in a string
#
# Parameters:
# [$1] - from left to right N $2 character(s)
# <"$2"> - from character(s)
# [$3] - up to N $4 character(s)
# ["$4"] - up to character(s)
# <"$5"> - string
#
# Returns:
# (0) substring of $5 | undefined behaviour if $2/$4 not present
# (1) undefined behaviour
#
substr_after() {
    x=0

    if [ $# -eq 5 ]; then
        i=$(printf "%s" "$5")
        until [ $x -eq $1 ]; do
            i=$(printf "%s" "${i#*$2}")
            x=$((x + 1))
        done
        x=0
        ii="$i"
        until [ $x -eq $3 ]; do
            i=$(printf "%s" "${i#*$4}")
            x=$((x + 1))
        done
        i=$(printf "%s" "${ii%$i}")
    elif [ $# -eq 4 ]; then
        i=$(printf "%s" "$4")
        case "$1" in
            '' | *[!0-9]*)
                i=$(printf "%s" "${i##*$1}")
                ii="$i"
                until [ $x -eq $2 ]; do
                    i=$(printf "%s" "${i#*$3}")
                    x=$((x + 1))
                done
                i=$(printf "%s" "${ii%$i}")
            ;;
            *)
                until [ $x -eq $1 ]; do
                    i=$(printf "%s" "${i#*$2}")
                    x=$((x + 1))
                done
                ii="$i"
                i=$(printf "%s" "${i##*$3}")
                i=$(printf "%s" "${ii%$i}")
            ;;
        esac
    elif [ $# -eq 3 ]; then
        i=$(printf "%s" "$3")
        case "$1" in
            '' | *[!0-9]*)
                i=$(printf "%s" "${i##*$1}")
                ii="$i"
                i=$(printf "%s" "${i##*$2}")
                i=$(printf "%s" "${ii%$i}")
            ;;
            *)
                until [ $x -eq $1 ]; do
                    i=$(printf "%s" "${i#*$2}")
                    x=$((x + 1))
                done
            ;;
        esac
    else
        i=$(printf "%s" "${2##*$1}")
    fi

    if [ -n "$i" ]; then
        case "$i" in
            " "*) i=$(printf "%s" "${i# }") ;;
        esac
        case "$i" in
            *" ") i=$(printf "%s" "${i% }") ;;
        esac

        printf "%s" "${i}"
        return 0
    fi

    return 1
}

# Description:
# Print specific line in a file
#
# Parameters:
# <$1> - line number
# <"$2"> - file
#
# Returns:
# (0) line's content
# (1) line empty | does not exist | file permission error
#
pline() {
    x=0
    unset i

    while read -r LINE || [ -n "$LINE" ]; do
        x=$((x + 1))
        if [ $x -eq $1 ]; then
            i=$(printf "%s" "${LINE}")
            break
        fi
    done < "$2"

    if [ -n "$i" ]; then
        printf "%s" "${i}"
        return 0
    fi
    
    return 1
}

# Description:
# Check the existence/position of a substring in a string
#
# Parameters:
# <"$1"> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is the string on its own)
#
# Returns:
# (0) substring exists
# (1) no substring
#
grep_str() {
    if [ $# -eq 3 ]; then
        if [ $3 -eq 1 ]; then
            case "$2" in
                "$1"*) grepstr=0 && return 0 ;;
            esac
        elif [ $3 -eq 2 ]; then
            case "$2" in
                *"$1") grepstr=0 && return 0 ;;
            esac
        elif [ $3 -eq 3 ]; then
            case "$2" in
                "$1") grepstr=0 && return 0 ;;
            esac
        fi
    else
        case "$2" in
            *"$1"*) grepstr=0 && return 0 ;;
        esac
    fi

    return 1
}

# Description:
# Strip character(s) from the end of a string
#
# Parameters:
# <"$1"> - character(s)
# <"$2"> - string
#
# Returns:
# (0) string stripped
# (1) no $1 at the end of $2
#
strip_end() {
    case "$2" in
        *"$1") printf "%s" "${2%$1}" && return 0 ;;
    esac

    return 1
}

# Description:
# Parse the content of a file
#
# Parameters:
# <"$1"> - file
# [$2] - mode('1' - wrap parsed lines in one trailing whitespace,
#             '2' - wrap parsed lines in two trailing whitespaces,
#             '3' - skip empty lines)
#
# Returns:
# (0) file's content | empty output (file)
# (1) file does not exist | permission error
#
fparse() {
    if [ $# -eq 2 ]; then
        if [ $2 -eq 1 ]; then
            while read -r LINE || [ -n "$LINE" ]; do
                echo " $LINE "
            done < "$1"
        elif [ $2 -eq 2 ]; then
            while read -r LINE || [ -n "$LINE" ]; do
                echo "  $LINE  "
            done < "$1"
        elif [ $2 -eq 3 ]; then
            while read -r LINE || [ -n "$LINE" ]; do
                if [ -n "$LINE" ]; then
                    echo "$LINE"
                fi
            done < "$1"
        fi
    else
        while read -r LINE || [ -n "$LINE" ]; do
            echo "$LINE"
        done < "$1"
    fi

    return $?
}

# Description:
# Remove specific character(s) in a string
#
# Parameters:
# <"$1"> - character(s)
# <"$2"> - string
#
# Returns:
# $2 without $1 characters,
# $2
#
remchars() {
    i=$IFS

    IFS=$1
    set -- $2

    IFS=""
    set -- $*

    printf "%s\n" "$*"

    IFS=$i
}

# Description:
# Print error and exit
#
# Parameters:
# <"$1"> - text
# <$2> - exit code
#
err() {
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$1"
    exit $2
}

# Description:
# Print a warning
#
# Parameters:
# <"$1"> - text
#
warn() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$1"
}

# Description:
# Print info
#
# Parameters:
# <"$1"> - text
#
info() {
    printf "%bINFO:%b %s\n" "\033[1;37m" "\033[0m" "$1"
}

# Description:
# Get N attribute in the lock file
#
# Parameters:
# <$1> - N
#
# Returns:
# (0) N attribute
# (1) N attribute does not exist
#
aq() {
    x=$1
    i=$(pline 1 "$ALOCK")
    x=$((x - 1 + x))
    i=$(substr_after $x "@" 1 "@" "$i")
    i=$(strip_end "@" "$i")

    if [ -n "$i" ]; then
        printf "%s" "${i}"
        return 0
    fi

    return 1
}

# Description:
# Check if an attribute exists in the lock file
#
# Parameters:
# <"$1"> - attribute
#
# Returns:
# (0) attribute exists
# (1) no attribute
#
ac() {
    i=$(pline 1 "$ALOCK")

    if grep_str "@$1@" "$i"; then
        return 0
    fi

    return 1
}

# Description:
# Return lock format for an attribute
#
# Parameters:
# <"$1"> - attribute('0' - begin lock format,
#                  '1' - end lock format)
# ['$2'] - test variable
#
# Returns:
# (0) format
# (1) variable is empty/unset
#
aw() {
    if [ $# -eq 2 ]; then
        i=$(eval "echo $2") && if [ ! "$i" ]; then return 1; fi
    fi

    case "$1" in
        "0") printf " " ;;
        "1") printf " \n" ;;
        *) printf "@%s@ " "$1" ;;
    esac
}

# Description:
# Run a git command for the msg file
#
# Parameters:
# <"$1"> - printf format('1' - "%s\n",
#                      '2' - "%s\n\n",
#                      '3' - "\n%s\n")
# ["$2"] - command
# ['$3'] - test variable
# [$4] - mode('1' - unique commits, "..",
#             '2' - unique commits of both, "...")
#
# Returns:
# (0) output
# (1) variable is empty/unset | no command output
#
mc() {
    if [ $# -eq 3 ] || [ $# -eq 4 ]; then
        i=$(eval "echo $3") && if [ ! "$i" ]; then return 1; fi
    fi
    if [ $# -eq 2 ]; then
        i=$(eval "echo $2") && if [ ! "$i" ]; then return 1; fi
    fi

    if [ $# -eq 4 ]; then
        case "$4" in
            "1") i=$(git $2 ${OBR}..${TBR} 2> /dev/null) ;;
            "2") i=$(git $2 ${OBR}...${TBR} 2> /dev/null) ;;
        esac
    elif [ $# -eq 3 ]; then
        case "$3" in
            "1") i=$(git $2 ${OBR}..${TBR} 2> /dev/null) ;;
            "2") i=$(git $2 ${OBR}...${TBR} 2> /dev/null) ;;
            *) i=$(git $2 2> /dev/null) ;;
        esac
    elif [ $# -eq 2 ]; then
        case "$2" in
            '$'*) printf "$1" && return 0 ;;
            *) i=$(git $2 2> /dev/null) ;;
        esac
    else
        printf "$1" && return 0
    fi

    if [ -n "$i" ]; then
        case "$1" in
            "1") printf "%s\n" "$i" ;;
            "2") printf "%s\n\n" "$i" ;;
            "3") printf "\n%s\n" "$i" ;;
            *) printf "$1" "$i" ;;
        esac
        return 0
    fi

    return 1
}

admerge_env() {
    OBR=$(git symbolic-ref --short HEAD 2> /dev/null)
    ALOCK="$PWD"/.git/admerge_lock
    AMSG="$PWD"/.git/admerge_msg

    if [ "$1" ]; then
        TBR="$1"
    else
        TBR=""
    fi
}

admerge_check() {
    if [ -z $OBR ]; then
        err "Failed to identify current branch. (not in git repository?)" 1
    fi

    if [ $1 ]; then
        if [ ! -r "$ALOCK" ]; then
            err "No lock file found. (no merge in progress?)" 2
        fi
    else
        if [ -r "$ALOCK" ]; then
            err "A merge is already in progress. ($ALOCK)" 2
        fi
    fi

    if [ ! $1 ]; then
        if [ -r "$AMSG" ]; then
            err "'$AMSG' exists, but no lock file is found. (manual lock rm?)" 1
        fi
    fi
}

admerge_lock() {
    {
    aw "0"
    aw "$TBR"
    aw "s" '$soff'
    aw "S" '$gsign'
    aw "1"
    } >> "$ALOCK"
}

admerge_msg() {
    {
    printf "Merge '%s' into '%s'\n\n" "${TBR}" "${OBR}"
    TMP=$(git rev-list --count ${OBR}..${TBR} 2> /dev/null)
    if [ -n "$TMP" ]; then
        printf "Summary of commits (%d):\n" "$TMP"
    fi
    TMP=$(git log --oneline ${OBR}..${TBR} 2> /dev/null)
    if [ -n "$TMP" ]; then
        printf "%s\n" "${TMP}"
    fi
    if [ -n "$gver" ]; then
        TMP=$(git --version 2> /dev/null)
        if [ -n "$TMP" ]; then
            printf "\n%s\n" "${TMP}"
        fi
    fi
    } >> "$AMSG"
}

admerge_work() {
    gitm_args="--no-ff --no-commit $TBR"
    gitc_args="-eF $AMSG --no-edit"

    if [ -r "$ALOCK" ]; then
        if ac "s"; then gitc_args="--signoff ${gitc_args}"; fi
        if ac "S"; then gitc_args="--gpg-sign ${gitc_args}"; fi
    fi
}

admerge_exec() {
    if [ $1 ] && [ $1 = a ]; then
        git merge --abort
    elif [ $1 ] && [ $1 = c ]; then
        if ! git commit ${gitc_args}; then
            exit 1
        fi
    elif [ $1 ] && [ $1 = s ]; then
        git status -s
    else
        if ! git merge ${gitm_args}; then
            if git merge HEAD > /dev/null 2>&1; then
                RC=1 && return 1
            else
                exit 1
            fi
        fi
        git commit ${gitc_args}
    fi
}

admerge_post() {
    rm -f "$ALOCK"
    rm -f "$AMSG"
}

admerge_info() {
    info "Our branch: '$OBR'"
    TMP=$(aq 1)
    if [ -n "$TMP" ]; then
        info "Their branch: '$TMP'"
    fi
    info "Lock file location: '$ALOCK'"
    TMP=$(pline 1 "$ALOCK")
    if [ -n "$TMP" ]; then
        info "Lock file content: '$TMP'"
    fi
    info "Commit message file location: '$AMSG'"
    info "Commit message file content (not shown: empty lines, signoff):"
    fparse "$AMSG" 3
    info "Status of files:"
}

admerge_abort() {
    admerge_env;
    admerge_check "a"
    admerge_exec "a"
    admerge_post;
}

admerge_continue() {
    admerge_env;
    admerge_check "c"
    admerge_work;
    admerge_exec "c"
    admerge_post;
}

admerge_status() {
    admerge_env;
    admerge_check "s"
    admerge_info;
    admerge_exec "s"
}

admerge() {
    admerge_env "$1"
    admerge_check;
    admerge_lock;
    admerge_msg;
    admerge_work;
    admerge_exec;
    admerge_post;
}

main() {
    # For security reasons, unset specific internal variables if they exist
    if [ -n "$RC" ]; then unset RC; fi

    # Serve the script until no script parameters passed
    while [ "$1" ]; do
        # Reset variables from previous loop run
        if [ -n "$grepstr" ]; then unset grepstr; fi

        case "$1" in
            # Parse specific options first
            "--") shift && break ;;
            "--help") usage && return 0 ;;
            "a" | "abort") admerge_abort && return 0 ;;
            "c" | "continue") admerge_continue && return 0 ;;
            "s" | "status") admerge_status && return 0 ;;

            # Parse options
            "--"*)
                i=$(substr_after 1 "--" "$1")

                if grep_str "sign-off" "$i" 3; then soff=1; fi 
                if grep_str "gpg-sign" "$i" 3; then gsign=1; fi
                if grep_str "git-version" "$i" 3; then gver=1; fi

                if [ ! $grepstr ]; then
                    warn "Unrecognized option: '$1'"
                fi
                shift
            ;;
            "-"*)
                i=$(substr_after 1 "-" "$1")

                if grep_str "s" "$i"; then soff=1; fi
                if grep_str "S" "$i"; then gsign=1; fi
                if grep_str "v" "$i"; then gver=1; fi

                i=$(remchars "sSv" "$i")
                if [ -n "$i" ]; then
                    warn "Unrecognized option(s): '-$i'"
                fi
                shift
            ;;

            *) break ;;
        esac
    done

    # Catch wrong input
    if [ ! "$1" ]; then
        err "No branch/tag specified." 2
    elif [ "$2" ]; then
        err "Too many operands. ($#)" 2
    fi

    # Execute the core function
    admerge "$1"

    # Check if RC is set, otherwise explicit success
    if [ -n "$RC" ]; then
        return $RC
    fi
    return 0
}

main "$@"
