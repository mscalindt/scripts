#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-only
# shellcheck disable=SC2048 # ShellCheck incorrect pedantic warning

_copyright() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'COPYRIGHT'
Copyright (C) 2021-2022 Dimitar Yurukov <mscalindt@protonmail.com>
COPYRIGHT
}

_description() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'DESCRIPTION'
Do an advanced, better merge. (git wrapper)
DESCRIPTION
}

_license() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'LICENSE'
License GPLv3: GNU GPL version 3
LICENSE
}

_misc() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'MISC'
External utilities hard dependency list:
git, rm.
External utilities soft dependency list:
.
MISC
}

_notice() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'NOTICE'
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
NOTICE
}

_options() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'OPTIONS'
In-merge options (merge with conflicts):
  a, abort                   abort a merge in progress; this option disregards
                             other options
  c, continue                resume a merge; this option disregards other
                             options
  s, status                  show status of the current merge; this option
                             disregards other options

Options:
      --no-color             colorless output on all streams
  -s, --sign-off             add Signed-off-by line at the end of the commit
                             message; requires preconfigured signoff info for
                             seamless work
  -S, --gpg-sign             sign the merge commit; requires preconfigured key
                             and user.signingkey for seamless work
  -v, --git-version          print the git version at the end of the commit
                             message
      --help     display this help text and exit
      --version  display version information and exit
      --         specify end of options
OPTIONS
}

_usage() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'USAGE'
Usage: admerge [options] <a|c|s|BRANCH>
USAGE
}

_version() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'VERSION'
admerge 0.0.0
VERSION
}

usage() {
    _usage; _description; echo
    _options; echo
    _misc;
}

version() {
    _version; echo
    _copyright; echo
    _license; _notice;
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err() {
    _rc=$1; shift
    printf "\nERROR: %s\n\n" "$*" 1>&2
    exit $_rc
}

# Description:
# Print colorful error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err_clr() {
    _rc=$1; shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $_rc
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <"$1"> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is, on its own, $2)
#
# Returns:
# (0) match
# (1) no match
#
grep_str() {
    case $#:$3 in
        2:) case "$2" in *"$1"*) return 0 ;; esac ;;
        3:1) case "$2" in "$1"*) return 0 ;; esac ;;
        3:2) case "$2" in *"$1") return 0 ;; esac ;;
        3:3) case "$2" in "$1") return 0 ;; esac ;;
    esac

    return 1
}

# Description:
# Get positional substring, (from&to LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <"$2"> - from "X" character(s)
# <$3> - to "N" $2-TR character('0' - max)
# <"$4"> - to "X" character(s)
# <"$5"> - string
# [$6] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$7] - mode('3' - keep $2,
#             '4' - keep $4,
#             '5' - keep $2/$4)
# [$8] - mode('6' - verify the expansion)
#
# Returns:
# (0) substring | incorrect substring ($1/$3 > $2/$4)
# (1) empty <unspecified/incorrect> expansion
# (2) unspecified <empty/incorrect> expansion
#
# Returns (mode '6'):
# (0) substring
# (1) unspecified expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion (! $2)
# (3) incorrect expansion ($1 > $2)
# (4) empty expansion ($2..$4)
# (5) unspecified expansion (! $4)
# (6) incorrect expansion ($3 > $4)
#
ltr_substr1() {
    _str="$5"

    case $#:$7$6 in
        8:*|7:6*|6:6)
            case $1 in
                0)
                    case "$_str" in
                        *"$2") return 1 ;;
                        *"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    _str="${_str##*"$2"}"
                ;;
                *)
                    case $1"$_str" in
                        $1*"$2"*"$2"*) : ;;
                        1*"$2") return 1 ;;
                        $1*"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    _i=0; until [ $_i -eq $1 ]; do
                        _str="${_str#*"$2"}"

                        case "$_str" in
                            *"$2"*"$2"*) : ;;
                            *"$2") [ $((_i + 2)) -eq $1 ] && return 1 ;;
                            *"$2"*) : ;;
                            *) [ $((_i + 1)) -eq $1 ] || return 3 ;;
                        esac

                        _i=$((_i + 1))
                    done
                ;;
            esac

            case $3 in
                0)
                    case "$_str" in
                        *"$4"*"$4"*) : ;;
                        "$4"*) return 4 ;;
                        *"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    _str="${_str%"$4"*}"
                ;;
                *)
                    case $3"$_str" in
                        1"$4"*) return 4 ;;
                        $3*"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    _sfix="$_str"; _i=0; until [ $_i -eq $3 ]; do
                        _sfix="${_sfix#*"$4"}"

                        case "$_sfix" in
                            *"$4"*) : ;;
                            *) [ $((_i + 1)) -eq $3 ] || return 6 ;;
                        esac

                        _i=$((_i + 1))
                    done

                    _str="${_str%"$4$_sfix"}"
                ;;
            esac
        ;;
        *)
            case $1 in
                0)
                    _str="${_str##*"$2"}"
                ;;
                *)
                    _i=0; until [ $_i -eq $1 ]; do
                        _str="${_str#*"$2"}"
                        _i=$((_i + 1))
                    done
                ;;
            esac

            [ "$_str" = "$5" ] && return 2
            _old_str="$_str"

            case $3 in
                0)
                    _str="${_str%"$4"*}"
                ;;
                *)
                    _sfix="$_str"; _i=0; until [ $_i -eq $3 ]; do
                        _sfix="${_sfix#*"$4"}"
                        _i=$((_i + 1))
                    done

                    _str="${_str%"$4$_sfix"}"
                ;;
            esac

            [ "$_str" = "$_old_str" ] && return 2
        ;;
    esac

    [ "$_str" ] || return 1

    case $6 in
        0)
            _str="${_str#${_str%%[![:space:]]*}}"
        ;;
        1)
            _str="${_str%${_str##*[![:space:]]}}"
        ;;
        2)
            _str="${_str#${_str%%[![:space:]]*}}"
            _str="${_str%${_str##*[![:space:]]}}"
        ;;
    esac

    case $7$6 in
        *3*) _str="$2$_str" ;;
        *4*) _str="$_str$4" ;;
        *5*) _str="$2$_str$4" ;;
    esac

    printf "%s" "$_str"
}

# Description:
# Parse the content of a file
#
# Parameters:
# <"$1"> - file
# [$2] - mode('1' - add one leading/trailing whitespace character,
#             '2' - add two leading/trailing whitespace characters,
#             '3' - skip empty lines,
#             '4' - strip trailing/leading whitespace characters)
# ["$3"] - mode("5 N" - stop parsing further than "N" line)
#
# Returns:
# (0) output | empty output (file) | empty output (by the given ruleset)
# (1) not a file | file does not exist
# (2) file access error
#
# Caveats:
# 1. NULL character.
# 2. Reading /proc is unreliable.
#
parse() {
    [ -f "$1" ] || return 1
    [ -r "$1" ] || return 2

    case $#:"$3$2" in
        1:)
            while IFS= read -r _line; do
                printf "%s\n" "$_line"
            done < "$1"
        ;;
        2:1)
            while IFS= read -r _line; do
                printf " %s \n" "$_line"
            done < "$1"
        ;;
        2:2)
            while IFS= read -r _line; do
                printf "  %s  \n" "$_line"
            done < "$1"
        ;;
        2:3)
            while IFS= read -r _line; do
                case ":$_line" in :) : ;; *) printf "%s\n" "$_line" ;; esac
            done < "$1"
        ;;
        2:4)
            while read -r _line; do
                printf "%s\n" "$_line"
            done < "$1"
        ;;
        2:5*)
            _maxN="${2#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in $_maxN) break ;; esac
                printf "%s\n" "$_line"
            done < "$1"
        ;;
        3:5*1)
            _maxN="${3#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in $_maxN) break ;; esac
                printf " %s \n" "$_line"
            done < "$1"
        ;;
        3:5*2)
            _maxN="${3#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in $_maxN) break ;; esac
                printf "  %s  \n" "$_line"
            done < "$1"
        ;;
        3:5*3)
            _maxN="${3#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in $_maxN) break ;; esac
                case ":$_line" in :) : ;; *) printf "%s\n" "$_line" ;; esac
            done < "$1"
        ;;
        3:5*4)
            _maxN="${3#??}"; _i=0; while read -r _line; do
                _i=$((_i + 1))
                case $_i in $_maxN) break ;; esac
                printf "%s\n" "$_line"
            done < "$1"
        ;;
    esac

    case $#:"$3$2" in
        1:|2:3|2:4|2:5*|3:5*3|3:5*4)
            printf "%s" "$_line"
        ;;
        2:1|3:5*1)
            [ "$_line" ] && printf " %s " "$_line"
        ;;
        2:2|3:5*2)
            [ "$_line" ] && printf "  %s  " "$_line"
        ;;
    esac
}

# Description:
# Print specific line in file
#
# Parameters:
# <$1> - line number
# <"$2"> - file
#
# Returns:
# (0) line's content | line empty
# (1) line does not exist
# (2) not a file | file does not exist
# (3) file access error
#
# Caveats:
# 1. NULL character.
# 2. Reading /proc is unreliable.
#
pline() {
    [ -f "$2" ] || return 2
    [ -r "$2" ] || return 3

    _i=0; while read -r _line || [ "$_line" ]; do
        _i=$((_i + 1))
        case $_i in $1) printf "%s" "$_line"; return 0 ;; esac
    done < "$2"

    return 1
}

# Description:
# Get N attribute in the lock file
#
# Parameters:
# <$1> - N
#
# Provides:
# <$_attrN> - N '@'
#
# Returns:
# (0) attribute
# (1) attribute does not exist
#
_alock_get() {
    _attrN=$(($1 + $1 - 1))
    _str=$(pline 1 "$ALOCK")

    ltr_substr1 $_attrN '@' 1 '@' "$_str" 6 || return 1
}

# Description:
# Check if an attribute exists in the lock file
#
# Parameters:
# <"$1"> - attribute
#
# Returns:
# (0) match
# (1) no match
# (2) invalid attribute
#
_alock_test() {
    case "$1" in
        *"@"*) return 2 ;;
    esac

    _str=$(pline 1 "$ALOCK")

    grep_str "@$1@" "$_str" || return 1
}

# Description:
# Return attribute format for the lock file
#
# Parameters:
# <"$1"> - attribute
#
# Returns:
# (0) format
# (1) invalid attribute
#
_alock_write() {
    case "$1" in
        *"@"*) return 1 ;;
    esac

    printf "@%s@ " "$1"
}

# Description:
# Check if a merge is in progress
#
# Returns:
# (0) yes
# (1) no
#
_in_merge() {
    git merge HEAD > /dev/null 2>&1 && return 1 || return 0
}

_admerge() {
    case ":$ncolor$NO_COLOR" in
        :)
            ES_inf="\033[1;37m"
            ES_res="\033[0m"

            err() { err_clr "$@"; }
            git() { command git -c color.ui=always "$@"; }
        ;;
        *)
            ES_inf=
            ES_res=

            git() { command git -c color.ui=never "$@"; }
        ;;
    esac

    hash git > /dev/null 2>&1
}

admerge_env() {
    OBR=$(git symbolic-ref --short HEAD 2> /dev/null)
    ALOCK="$PWD"/.git/admerge_lock
    AMSG="$PWD"/.git/admerge_msg
    CDIFF_NEW="$OBR..$BRANCH"
    CDIFF_ALL="$OBR...$BRANCH"
}

admerge_check() {
    [ "$OBR" ] || err 2 "Failed to identify current branch. (not in .git dir?)"
    [ -f "$ALOCK" ] && err 2 "A merge is already in progress. ($ALOCK)"
    [ -f "$AMSG" ] && rm -f "$AMSG"
}

admerge_lock() {
    printf " "

    _alock_write "$BRANCH"

    [ "$soff" ] && _alock_write "s"
    [ "$gsign" ] && _alock_write "S"

    echo " "
} >> "$ALOCK"

admerge_msg() {
    printf "Merge '%s' into '%s'\n\n" "$BRANCH" "$OBR"

    TMP=$(git rev-list --count $CDIFF_NEW 2> /dev/null)
    [ "$TMP" ] && printf "Summary of commits (%d):\n" "$TMP"
    TMP=$(git log --oneline $CDIFF_NEW 2> /dev/null)
    [ "$TMP" ] && printf "%s\n" "$TMP"

    if [ "$gver" ]; then
        TMP=$(git --version 2> /dev/null)
        [ "$TMP" ] && printf "\n%s\n" "$TMP"
    fi
} >> "$AMSG"

admerge_work() {
    gitm_args="--no-ff --no-commit $BRANCH"
    gitc_args="-eF $AMSG --no-edit"

    if [ -r "$ALOCK" ]; then
        _alock_test "s" && gitc_args="--signoff ${gitc_args}"
        _alock_test "S" && gitc_args="--gpg-sign ${gitc_args}"
    fi
}

admerge_exec() {
    if ! git merge ${gitm_args}; then
        if _in_merge; then
            exit 1
        else
            RC=1 && return 1
        fi
    fi

    # Return code of git will not be reliable on a literal "HEAD" merge,
    # therefore the merge check above is unreliable; do a merge check now --
    # again -- to abort prematurely if we are not in a merge.
    _in_merge || return 0

    git commit ${gitc_args} || exit $?
}

admerge_post() {
    rm -f "$ALOCK" "$AMSG"
}

admerge_abort() {
    admerge_env

    [ "$OBR" ] || err 2 "Failed to identify current branch. (not in .git dir?)"
    [ -f "$ALOCK" ] || err 2 "No lock file found. (no merge in progress?)"

    if ! git merge --abort; then
        _in_merge && exit 1
    fi

    admerge_post
}

admerge_continue() {
    admerge_env

    [ "$OBR" ] || err 2 "Failed to identify current branch. (not in .git dir?)"
    [ -f "$ALOCK" ] || err 2 "No lock file found. (no merge in progress?)"

    admerge_work

    git commit ${gitc_args} || exit $?

    admerge_post
}

admerge_status() {
    admerge_env

    [ "$OBR" ] || err 2 "Failed to identify current branch. (not in .git dir?)"
    [ -f "$ALOCK" ] || err 2 "No lock file found. (no merge in progress?)"

    printf "%bOur branch: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$OBR" \
           "${ES_inf}" "${ES_res}"
    printf "%bTheir branch: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$(_alock_get 1)" \
           "${ES_inf}" "${ES_res}"

    printf "%bLock file location: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$ALOCK" \
           "${ES_inf}" "${ES_res}"
    printf "%bLock file content: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$(pline 1 "$ALOCK")" \
           "${ES_inf}" "${ES_res}"

    printf "%bCommit message file location: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$AMSG" \
           "${ES_inf}" "${ES_res}"
    printf "%bCommit message file content: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$(parse "$AMSG")" \
           "${ES_inf}" "${ES_res}"

    printf "%bStatus of files: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$(git status -s)" \
           "${ES_inf}" "${ES_res}"
}

admerge() {
    _admerge
    admerge_env
    admerge_check
    admerge_lock
    admerge_msg
    admerge_work
    admerge_exec
    admerge_post
}

main_functions() {
    # Description:
    # Within single quotes escape single quote(s) in string
    #
    # Parameters:
    # <"$1"+> - string
    #
    # Returns:
    # (0) escaped string | string
    #
    esc_sq() {
        case ":$1" in :) return 0 ;; esac

        _str="$1"

        case "$_str" in
            *"'"*)
                _str_ref="${_str%%\'*}'\\''"
                _str="${_str_ref}${_str#*\'}"

                while :; do case "$_str" in
                    "$_str_ref"*"'"*)
                        _str="${_str#*"$_str_ref"}"
                        _str_ref="$_str_ref${_str%%\'*}'\\''"
                        _str="$_str_ref${_str#*\'}"
                    ;;
                    *)
                        break
                    ;;
                esac done
            ;;
        esac

        printf "'%s'" "$_str"; shift

        while [ "$1" ]; do
            case "$1" in
                *"'"*) : ;;
                *) printf " '%s'" "$1"; shift && continue ;;
            esac

            _str_ref="${1%%\'*}'\\''"
            _str="${_str_ref}${1#*\'}"

            while :; do case "$_str" in
                "$_str_ref"*"'"*)
                    _str="${_str#*"$_str_ref"}"
                    _str_ref="$_str_ref${_str%%\'*}'\\''"
                    _str="$_str_ref${_str#*\'}"
                ;;
                *)
                    break
                ;;
            esac done

            printf " '%s'" "$_str"; shift
        done
    }

    # Description:
    # Signify invalid operand count (min)[0>X]
    #
    opd_min() {
        set -- "${0##*/}"
        printf "%s: No operand specified.\n" "$1" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[X>1]
    #
    # Parameters:
    # <"$1"> - count
    #
    opd_cmax() {
        set -- "${0##*/}" "$1"
        printf "%s: Too many operands: %d\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[2>1]
    #
    # Parameters:
    # <"$1"> - first operand
    # <"$2"> - second operand
    #
    opd_max() {
        set -- "${0##*/}" "$1" "$2"
        printf "%s: Too many operands: '[%s]; [%s]'\n" "$1" "$2" "$3" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_invalid() {
        set -- "${0##*/}" "$1"
        printf "%s: Invalid option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unknown (*) option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unknown() {
        set -- "${0##*/}" "$1"
        printf "%s: Unknown option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unrecognized ('--') option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unrecognized() {
        set -- "${0##*/}" "$1"
        printf "%s: Unrecognized option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Return 0 if complex (arg) option in option holder [$_opt]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # <"$_opt_arg"> - option argument
    # <"$_shiftN"> - shift count
    #
    copt() {
        case ":$_opt" in :) return 1 ;; esac

        case "$_opt" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        esac

        case "$_opt_arg:$_opt " in
            :"$1 ")
                printf "%s: Option '%s' requires an argument.\n" \
                       "${0##*/}" "$1" 1>&2
                printf "%s: Try '%s --help' for more information.\n" \
                       "${0##*/}" "${0##*/}" 1>&2
                exit 2
           ;;
        esac

        case "$_opt" in
        "--"*)
            case "$_opt " in
                "$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1 ")
                    _opt=; _shiftN=2
                    return 0
                ;;
                "$1="*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$_opt " in
                "$1 ")
                    _opt=; _shiftN=2
                    return 0
                ;;
                "$1"*)
                    _opt_arg="${_opt#"$1"}"; _opt=; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if perhaps complex (arg) option in option holder [$_opt]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # ["$_opt_arg"] - option argument
    # <"$_shiftN"> - shift count
    #
    copt_optional() {
        case ":$_opt" in :) return 1 ;; esac

        case "$_opt" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$_opt" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    _opt=; _opt_arg=; _shiftN=1
                    return 0
                ;;
                "$1="*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$_opt" in
                "$1")
                    _opt=; _opt_arg=; _shiftN=1
                    return 0
                ;;
                "$1"*)
                    _opt_arg="${_opt#"$1"}"; _opt=; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific complex (arg) option in option holder [$_opt]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # <"$_opt_arg"> - option argument
    # <"$_shiftN"> - shift count
    #
    scopt() {
        case ":$_opt" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$_opt_arg:$_opt " in
                :"$1 ")
                    printf "%s: Option '%s' requires an argument.\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$_opt_arg:$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$_opt_arg:$1 ")
                    _opt=; _shiftN=2
                    return 0
                ;;
                "$_opt_arg:$1="*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _shiftN=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if specific perhaps complex (arg) option in option holder [$_opt]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # ["$_opt_arg"] - option argument
    # <"$_shiftN"> - shift count
    #
    scopt_optional() {
        case ":$_opt" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$_opt" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    _opt=; _opt_arg=; _shiftN=1
                    return 0
                ;;
                "$1="*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _shiftN=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if simple (!arg) option in option holder [$_opt]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # ["$_opt_index"] - index with encountered short options
    # <"$_shiftN"> - shift count
    #
    sopt() {
        case ":$_opt" in :) return 1 ;; esac

        case "$_opt" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$_opt" in
                "$1")
                    _opt=; _shiftN=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$_opt" in
                "$1"*)
                    case ":$_opt_index" in
                        :) _opt_index="@$1@" ;;
                        *) _opt_index="$_opt_index @$1@" ;;
                    esac

                    _opt="-${_opt#??}"; _shiftN=1
                    return 0
               ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific simple (!arg) option in option holder [$_opt]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # <"$_shiftN"> - shift count
    #
    ssopt() {
        case ":$_opt" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$_opt" in
                "$1")
                    _opt=; _shiftN=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }
}

# Description:
# Reorder positional parameters (string priority = LIFO)
#
# Parameters:
# <$1> - mode('0' - normal operation,
#             '1' - respect end of options)
# <"$2"+> - string
# <$3> - --
# <"$4"> - $@
#
# Provides:
# ["$_str"] - string to evaluate (eval set -- "$_str")
#
main_sargs_ro() {
    _mode=$1; shift

    _opts=$(
        esc_sq "$1"; shift

        while :; do case "$1" in
            --) shift && break ;;
            *) printf " "; esc_sq "$1"; shift ;;
        esac done
    )

    while :; do case "$1" in
        --) shift && break ;;
        *) shift ;;
    esac done

    case ":$*" in :) _str=; return 0 ;; esac

    set -- "$(esc_sq "$@")"; _str="$1"
    eval set -- "$_opts"

    case $_mode in
        0)
            while [ "$1" ]; do
                _opt="$1"

                case "$_opt" in
                    *"'"*) _opt=$(esc_sq "$_opt") ;;
                    *) _opt="'$_opt'" ;;
                esac

                case ":$_str" in
                    :"$_opt"*)
                        :
                    ;;
                    *"$_opt")
                        _str="$_opt ${_str%% "$_opt"*}${_str#*"$_opt"}"
                    ;;
                    *"$_opt"*)
                        _str="$_opt ${_str%%"$_opt"*}${_str#*"$_opt" }"
                    ;;
                esac

                shift
            done
        ;;
        1)
            case "$_str" in
                "'--'"*) return 0 ;;
            esac

            while [ "$1" ]; do
                _opt="$1"

                case "$_opt" in
                    *"'"*) _opt=$(esc_sq "$_opt") ;;
                    *) _opt="'$_opt'" ;;
                esac

                case "$_str" in
                    *"'--'"*)
                        _str_ref="${_str%% "'--'"*}"

                        case ":$_str_ref" in
                            :"$_opt"*)
                                :
                            ;;
                            *"$_opt")
                                _str="$_opt ${_str%% "$_opt"*}${_str#*"$_opt"}"
                            ;;
                            *"$_opt"*)
                                _str="$_opt ${_str%%"$_opt"*}${_str#*"$_opt" }"
                            ;;
                        esac
                    ;;
                    *)
                        case ":$_str" in
                            :"$_opt"*)
                                :
                            ;;
                            *"$_opt")
                                _str="$_opt ${_str%% "$_opt"*}${_str#*"$_opt"}"
                            ;;
                            *"$_opt"*)
                                _str="$_opt ${_str%%"$_opt"*}${_str#*"$_opt" }"
                            ;;
                        esac
                    ;;
                esac

                shift
            done
        ;;
    esac
}

# Description:
# Substitute the function call with script options
#
# Parameters:
# <"$1"> - mode('0' - print standard ('-'; '--') utility options,
#               '1' - print miscellaneous (*) options)
#
main_options() {
    case $1 in
    0)
        sopt "--no-color" && { ncolor=1; }
        sopt "-s" "--sign-off" && { soff=1; }
        sopt "-S" "--gpg-sign" && { gsign=1; }
        sopt "-v" "--git-version" && { gver=1; }
    ;;
    1)
        ssopt "a" "abort" && { _admerge; admerge_abort; exit 0; }
        ssopt "c" "continue" && { _admerge; admerge_continue; exit 0; }
        ssopt "s" "status" && { _admerge; admerge_status; exit 0; }
    ;;
    esac
}

main() {
    # Source common functions
    main_functions;

    # Reorder the positional parameters if needed
    #  > to prioritize specific options first
    main_sargs_ro 1 "--no-color" -- "$@"
    [ "$_str" ] && eval set -- "$_str"

    # Parse options
    while [ "$1" ]; do
        # Simulate global $N (positional parameters) shift
        #  > option functions modify when appropriate
        _shiftN=1

        # Simulate global $1/$2 (option/argument) handling
        #  > option functions modify when appropriate
        _opt="$1"; _opt_arg="$2"

        # Parse standard options
        #  > required to parse them first
        ssopt "-" && { opt_invalid "$1"; exit 2; }
        ssopt "--" && { shift && break; }
        ssopt "--help" && { usage; exit 0; }
        ssopt "--version" && { version; exit 0; }

        # Loop on the option holder until fully parsed
        #  > as we might need to loop on its characters
        while [ "$_opt" ]; do
            unset _opt_index

            case "$_opt" in
                "-"*) main_options 0 ;;
                *) main_options 1 ;;
            esac

            case ":$_opt" in
            :)
                :
            ;;
            :"--"*)
                opt_unrecognized "$_opt"; exit 2
            ;;
            :"-"*)
                case ":$_opt_index" in
                    :) opt_invalid "${_opt%"${_opt#??}"}"; exit 2 ;;
                esac

                case ${#_opt} in
                    1) unset _opt_index && break ;;
                esac
            ;;
            *)
                case ":$BRANCH" in
                    :) BRANCH="$_opt" ;;
                    *) opd_max "$BRANCH" "$_opt"; exit 2 ;;
                esac

                break
            ;;
            esac
        done

        # Move on positional parameters
        #  > either with default value or with option value
        shift $_shiftN
    done

    # Parse operands
    while [ "$1" ]; do
        _opt="$1"

        case ":$BRANCH" in
            :) BRANCH="$_opt" ;;
            *) opd_max "$BRANCH" "$_opt"; exit 2 ;;
        esac

        shift
    done

    # Here and no branch specified = bad input
    case ":$BRANCH" in
        :) opd_min; exit 2 ;;
    esac

    # Execute the core function
    admerge;

    # Check if RC is set, otherwise explicit success
    [ "$RC" ] && return $RC || return 0
}

main "$@"
