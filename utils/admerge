#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-only
# shellcheck disable=SC2048 # ShellCheck incorrect pedantic warning

_copyright() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'COPYRIGHT'
Copyright (C) 2021-2022 Dimitar Yurukov <mscalindt@protonmail.com>
COPYRIGHT
}

_description() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'DESCRIPTION'
Do an advanced, better merge. (git wrapper)
DESCRIPTION
}

_license() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'LICENSE'
License GPLv3: GNU GPL version 3
LICENSE
}

_misc() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'MISC'
External utilities hard dependency list:
git, rm.
External utilities soft dependency list:
.
MISC
}

_notice() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'NOTICE'
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
NOTICE
}

_options() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'OPTIONS'
In-merge options (merge with conflicts):
  a, abort                   abort a merge in progress
  c, continue                resume a merge
  s, status                  show status of the current merge

Options:
  -s, --sign-off             add Signed-off-by line at the end of the commit
                             message; requires preconfigured signoff info for
                             seamless work
  -S, --gpg-sign             sign the merge commit; requires preconfigured key
                             and user.signingkey for seamless work
  -v, --git-version          print the git version at the end of the commit
                             message
      --language <LANG>      custom LANG for LANG
      --locale <LANG>        custom LANG for LC_ALL
      --no-color             colorless output on all streams
      --help     display this help text and exit
      --version  display version information and exit
      --         specify end of options
OPTIONS
}

_usage() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'USAGE'
Usage: admerge [options] <a|c|s|BRANCH>
USAGE
}

_version() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'VERSION'
admerge 0.0.0
VERSION
}

usage() {
    _usage; _description; echo
    _options; echo
    _misc;
}

version() {
    _version; echo
    _copyright; echo
    _license; _notice;
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err() {
    _rc="$1"; shift
    printf "ERROR: %s\n" "$*" 1>&2
    exit "$_rc"
}

# Description:
# Colorfully print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err_clr() {
    _rc="$1"; shift
    printf "%bERROR:%b %s\n" '\033[1;31m' '\033[0m' "$*" 1>&2
    exit "$_rc"
}

# Description:
# Escape all POSIX-defined shell meta characters in a string; characters are:
# \ | & ; < > ( ) $ ` " ' * ? [ ] # ~ = %
#
# Parameters:
# <"$1"> - string
# ["$2"] - mode0("0 X" - escape only "X" whitespace-separated character(s))
# [$3] - mode1-2('1' - strip the characters,
#                '2' - escape single quote character with itself)
# [$4] - mode3('3' - no output)
#
# Provides:
# (0) <"$_str"> - the modified string
# <"$_chars"> - the characters;
#               whitespace delimited;
#               sorted by order parsed
#
# Returns:
# (0) escaped/stripped $1
# (1) no meta characters in $1
#
esc_str() {
    _str="$1"
    unset _str_ref

    set -f

    case "$2" in
        0*) _chars="${2#??}" ;;
        *) _chars='\ | & ; < > ( ) $ ` " '\'' * ? [ ] # ~ = %' ;;
    esac

    case "$_chars" in
        '\'*) : ;;
        *'\') _chars='\'" ${_chars%%\\*}${_chars#*\\}" ;;
        *'\'*) _chars='\'" ${_chars%%\\*}${_chars#*\\ }" ;;
    esac

    for _char in $_chars; do
        case "$_str" in
            *"$_char"*) : ;;
            *) continue ;;
        esac

        case $_char:$3:"$2" in
            "'":2*|"'":"$3":2)
                _str_ref="${_str%%\'*}'\\''"
            ;;
            "$_char":1*|"$_char":"$3":1)
                _str_ref="${_str%%"$_char"*}"
            ;;
            *)
                _str_ref="${_str%%"$_char"*}\\$_char"
            ;;
        esac
        _str="$_str_ref${_str#*"$_char"}"

        case $_char:$3:"$2" in
            "'":2*|"'":"$3":2)
                while :; do case "$_str" in
                    "$_str_ref"*"'"*)
                        _str="${_str#*"$_str_ref"}"
                        _str_ref="$_str_ref${_str%%\'*}'\\''"
                        _str="$_str_ref${_str#*\'}"
                    ;;
                    *)
                        break
                    ;;
                esac done
            ;;
            "$_char":1*|"$_char":"$3":1)
                while :; do case "$_str" in
                    *"$_char"*) _str="${_str%%"$_char"*}${_str#*"$_char"}" ;;
                    *) break ;;
                esac done
            ;;
            *)
                while :; do case "$_str" in
                    "$_str_ref"*"$_char"*)
                        _str="${_str#*"$_str_ref"}"
                        _str_ref="$_str_ref${_str%%"$_char"*}\\$_char"
                        _str="$_str_ref${_str#*"$_char"}"
                    ;;
                    *)
                        break
                    ;;
                esac done
            ;;
        esac
    done

    set +f

    [ "$_str_ref" ] || return 1

    case :$4:$3:"$2" in
        *:3*) : ;;
        *) printf "%s" "$_str" ;;
    esac
}

# Description:
# Parse the content of a file
#
# Parameters:
# <"$1"> - file
# [$2] - mode1-4('1' - add one leading/trailing whitespace character,
#                '2' - add two leading/trailing whitespace characters,
#                '3' - skip empty lines,
#                '4' - strip all leading/trailing whitespace characters)
# ["$3"] - mode5("5 N" - stop parsing further than "N" line)
#
# Returns:
# (0) output | empty output (file) | empty output (by the given ruleset)
# (1) not a file | file does not exist
# (2) file access error
#
# Caveats:
# 1. NULL character.
# 2. Reading /proc is unreliable.
#
parse() {
    [ -f "$1" ] || return 1
    [ -r "$1" ] || return 2

    case $3:$2 in
        :1)
            while IFS= read -r _line; do
                printf " %s \n" "$_line"
            done < "$1"
        ;;
        :2)
            while IFS= read -r _line; do
                printf "  %s  \n" "$_line"
            done < "$1"
        ;;
        :3)
            while IFS= read -r _line; do
                case ":$_line" in :) : ;; *) printf "%s\n" "$_line" ;; esac
            done < "$1"
        ;;
        :4)
            while read -r _line; do
                printf "%s\n" "$_line"
            done < "$1"
        ;;
        :5*)
            _maxN="${2#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                printf "%s\n" "$_line"
            done < "$1"
        ;;
        5*:1)
            _maxN="${3#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                printf " %s \n" "$_line"
            done < "$1"
        ;;
        5*:2)
            _maxN="${3#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                printf "  %s  \n" "$_line"
            done < "$1"
        ;;
        5*:3)
            _maxN="${3#??}"; _i=0; while IFS= read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                case ":$_line" in :) : ;; *) printf "%s\n" "$_line" ;; esac
            done < "$1"
        ;;
        5*:4)
            _maxN="${3#??}"; _i=0; while read -r _line; do
                _i=$((_i + 1))
                case $_i in "$_maxN") break ;; esac
                printf "%s\n" "$_line"
            done < "$1"
        ;;
        *)
            while IFS= read -r _line; do
                printf "%s\n" "$_line"
            done < "$1"
        ;;
    esac

    case $3:$2 in
        :3|:4|:5*|5*:3|5*:4)
            printf "%s" "$_line"
        ;;
        :1|5*:1)
            [ "$_line" ] && printf " %s " "$_line"
        ;;
        :2|5*:2)
            [ "$_line" ] && printf "  %s  " "$_line"
        ;;
        *)
            printf "%s" "$_line"
        ;;
    esac
}

# Description:
# Print specific line in file
#
# Parameters:
# <$1> - line number
# <"$2"> - file
# [$3] - mode0('0' - no output)
# [$4] - mode1('1' - strip all leading/trailing whitespace characters)
#
# Provides:
# (0) <"$_line"> - the line
#
# Returns:
# (0) line's content | line empty
# (1) line does not exist
# (2) not a file | file does not exist
# (3) file access error
#
# Caveats:
# 1. NULL character.
# 2. Reading /proc is unreliable.
#
pline() {
    [ -f "$2" ] || return 2
    [ -r "$2" ] || return 3

    case $4$3 in
        *1*)
            _i=0; while read -r _line || [ "$_line" ]; do
                _i=$((_i + 1))
                case $_i in
                    "$1")
                        case $3 in
                            0) : ;;
                            *) printf "%s" "$_line" ;;
                        esac

                        return 0
                    ;;
                esac
            done < "$2"
        ;;
        *)
            _i=0; while IFS= read -r _line || [ "$_line" ]; do
                _i=$((_i + 1))
                case $_i in
                    "$1")
                        case $3 in
                            0) : ;;
                            *) printf "%s" "$_line" ;;
                        esac

                        return 0
                    ;;
                esac
            done < "$2"
        ;;
    esac

    return 1
}

# Description:
# Print N indentation level info-formatted text
#
# Parameters:
# <$1> - N
# <"$2+"> - text
#
# Returns:
# (0) info-formatted $2
# (255) bad input
#
_info() {
    case :$1${1#*[!0123456789]} in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$1$1") : ;;
        *) return 255 ;;
    esac

    _str=; _i=0; until [ "$_i" -eq "$1" ]; do
        _str="$_str "
        _i=$((_i + 1))
    done

    shift
    printf "%s=>>: %s\n" "$_str" "$*"
}

# Description:
# Colorfully print N indentation level info-formatted text
#
# Parameters:
# <$1> - N
# <"$2+"> - text
#
# Returns:
# (0) info-formatted $2
# (255) bad input
#
_info_clr() {
    case :$1${1#*[!0123456789]} in
        :) return 255 ;;
        :00) : ;;
        :0*) return 255 ;;
        :"$1$1") : ;;
        *) return 255 ;;
    esac

    _str=; _i=0; until [ "$_i" -eq "$1" ]; do
        _str="$_str "
        _i=$((_i + 1))
    done

    shift
    printf "%b%s=>>: %s%b\n" '\033[1;37m' "$_str" "$*" '\033[0m'
}

# Description:
# Get N attribute in the lock file
#
# Parameters:
# <$1> - N
#
# Uses:
# <ALOCK> $ - the lock file's absolute path
#
# Provides:
# <"$_attr"> - the attribute
#
# Returns:
# (0) attribute
# (1) attribute does not exist
#
_alock_get() {
    _attrN=$1

    _str=; while read -r _line || [ "$_line" ]; do
        _str="$_str$_line"
    done 2> /dev/null < "$ALOCK"

    eval set -- "$_str"; eval _attr="\$$_attrN"
    [ "$_attr" ] && printf "%s" "$_attr"
}

# Description:
# Check if an attribute exists in the lock file
#
# Parameters:
# <"$1"> - attribute
#
# Uses:
# <ALOCK> $ - the lock file's absolute path
#
# Returns:
# (0) match
# (1) no match
#
_alock_test() {
    _attr="$1"

    _str=; while read -r _line || [ "$_line" ]; do
        _str="$_str$_line"
    done 2> /dev/null < "$ALOCK"

    eval set -- "$_str"
    while [ "$1" ]; do
        [ "$1" = "$_attr" ] && return 0 || shift
    done

    return 1
}

# Description:
# Print validized attribute for the lock file
#
# Parameters:
# <"$1"> - attribute
#
# Uses:
# <esc_str> ()
#
# Returns:
# (0) validized attribute
#
_alock_validize() {
    case "$1" in
        *"'"*) esc_str "$1" "0 '" && printf "%s " "'$_str'" ;;
        *) printf "%s " "'$1'" ;;
    esac
}

# Description:
# Issue admerge's commit command
#
# Uses:
# <AMSG> $ - the commit message file's absolute path
# <_alock_test> ()
#
_commit() {
    if [ -f "$AMSG" ]; then
        set -- '-eF'
        set -- "$@" "$AMSG"
        set -- "$@" '--no-edit'
    fi

    _alock_test 's/signoff' && set -- "$@" '--signoff'
    _alock_test 'S/gpgsign' && set -- "$@" '--gpg-sign'

    git commit "$@"
}

# Description:
# Issue admerge's merge command
#
# Uses:
# <BRANCH> $ - the branch being merged
#
_merge() {
    set -- '--no-ff'
    set -- "$@" '--no-commit'
    set -- "$@" "$BRANCH"

    git merge "$@"
}

# Description:
# Check if a merge is in progress
#
# Returns:
# (0) yes
# (1) no
#
_in_merge() {
    [ -f "$GMSG" ] && return 0 || return 1
}

_admerge() {
    case :"$locale" in
        :)
            LCgo() {
                agj5k97oN05exMQq="$LC_ALL"
                export LC_ALL=C
            }
        ;;
        *)
            LCgo() {
                agj5k97oN05exMQq="$LC_ALL"
                export LC_ALL="$locale"
            }
        ;;
    esac
    LCstop() { export LC_ALL="$agj5k97oN05exMQq"; }
    LCreset() { LCstop; LCgo; }

    case :"$language" in
        :)
            LANGgo() {
                WIxPdnq3AX2uzCuR="$LANG"
                export LANG=C
            }
        ;;
        *)
            LANGgo() {
                WIxPdnq3AX2uzCuR="$LANG"
                export LANG="$language"
            }
        ;;
    esac
    LANGstop() { export LANG="$WIxPdnq3AX2uzCuR"; }
    LANGreset() { LANGstop; LANGgo; }

    LCgo; LANGgo;

    case :"$ncolor$NO_COLOR" in
        :)
            ES_inf='\033[1;37m'
            ES_res='\033[0m'

            _info() { _info_clr "$@"; }
            err() { err_clr "$@"; }
            git() { command git -c 'color.ui=always' "$@"; }

            [ "$NO_COLOR" ] && export NO_COLOR=
        ;;
        *)
            ES_inf=
            ES_res=

            git() { command git -c 'color.ui=never' "$@"; }

            [ "$NO_COLOR" ] || export NO_COLOR=1
        ;;
    esac

    hash git > /dev/null 2>&1

    # Adjust $PWD accordingly if we are not at the top level of the repository
    if [ ! -d "$PWD"/.git ]; then
        # We use the legacy command 'git rev-parse --git-dir' to support git
        # versions older than 1.7; upward versions can use the command
        # 'git rev-parse --show-toplevel' to directly get the absolute root of
        # the repository.
        cd "$(git rev-parse --git-dir 2> /dev/null)"/..

        [ -d "$PWD"/.git ] || err 2 'Failed to find repository root.'
    fi

    # Assert "HEAD" is pointing to a branch (i.e. head is attached)
    git symbolic-ref --short HEAD > /dev/null 2>&1 || {
        err 2 'Failed: HEAD is detached.'
    }
}

admerge_env() {
    OBR=$(git symbolic-ref --short HEAD)
    ALOCK="$PWD"/.git/admerge_lock
    AMSG="$PWD"/.git/admerge_msg
    GMSG="$PWD"/.git/MERGE_MSG
    CDIFF_NEW="$OBR..$BRANCH"
    CDIFF_ALL="$OBR...$BRANCH"
}

admerge_check() {
    if _in_merge; then
        err 2 "A merge is already in progress."
    fi
}

admerge_lock() {
    _alock_validize "$BRANCH"
    [ "$soff" ] && _alock_validize 's/signoff'
    [ "$gsign" ] && _alock_validize 'S/gpgsign'
    [ "$gver" ] && _alock_validize 'v/gitver'
} > "$ALOCK"

admerge_msg() {
    printf "Merge '%s' into '%s'\n" "$BRANCH" "$OBR"

    {
        echo; printf 'Summary of commits: #'
        git rev-list --count "$CDIFF_NEW" 2> /dev/null && \
        git log --oneline "$CDIFF_NEW" 2> /dev/null
    } || > /dev/null 2>&1

    if [ "$gver" ]; then
        { echo; git --version; } || > /dev/null 2>&1
    fi
} > "$AMSG"

admerge_exec() {
    if ! _merge; then
        if ! _in_merge; then
            exit 1
        else
            RC=1 && return 1
        fi
    fi

    if _in_merge; then
        _commit || exit "$?"
    fi
}

admerge_post() {
    if ! _in_merge; then
        if [ -f "$ALOCK" ] || [ -f "$AMSG" ]; then
            rm -f "$ALOCK" "$AMSG"
        fi
    fi
}

admerge_abort() {
    _admerge
    admerge_env

    if _in_merge; then
        if ! git merge --abort; then
            _in_merge && exit 1
        fi
    else
        _info 0 'No merge is in progress.'
    fi

    admerge_post
}

admerge_continue() {
    _admerge
    admerge_env

    if _in_merge; then
        if ! _commit; then
            _in_merge && exit 1
        fi
    else
        _info 0 'No merge is in progress.'
    fi

    admerge_post
}

admerge_status() {
    _admerge
    admerge_env

    if _in_merge; then
        printf "%bOur branch: [%b\n%s\n%b]%b\n" \
               "${ES_inf}" "${ES_res}" \
               "$OBR" \
               "${ES_inf}" "${ES_res}"

        if [ -f "$ALOCK" ]; then
            printf "%bTheir branch: [%b\n" \
                   "${ES_inf}" "${ES_res}"
            _alock_get 1
            printf "\n%b]%b\n" \
                   "${ES_inf}" "${ES_res}"

            printf "%bLock file location: [%b\n%s\n%b]%b\n" \
                   "${ES_inf}" "${ES_res}" \
                   "$ALOCK" \
                   "${ES_inf}" "${ES_res}"
            printf "%bMerge options: [%b\n" \
                   "${ES_inf}" "${ES_res}"
            parse "$ALOCK" 4
            printf "\n%b]%b\n" \
                   "${ES_inf}" "${ES_res}"

            printf "%bCommit message file location: [%b\n%s\n%b]%b\n" \
                   "${ES_inf}" "${ES_res}" \
                   "$AMSG" \
                   "${ES_inf}" "${ES_res}"
            printf "%bCommit message: [%b\n" \
                   "${ES_inf}" "${ES_res}"
            parse "$AMSG"
            printf "%b]%b\n" \
                   "${ES_inf}" "${ES_res}"
        fi

        printf "%bStatus of files: [%b\n" \
               "${ES_inf}" "${ES_res}"
        git status --short
        printf "%b]%b\n" \
               "${ES_inf}" "${ES_res}"
    else
        _info 0 'No merge is in progress.'
    fi

    admerge_post
}

admerge() {
    _admerge
    admerge_env
    admerge_check
    admerge_lock
    admerge_msg
    admerge_exec
    admerge_post
}

main_functions() {
    # Description:
    # Assert a string
    #
    # Parameters:
    # <$1> - mode1-3('1' - N [0,1,00,01...],
    #                '2' - whole N [0,1...],
    #                '3' - natural N [1...],
    #                '4' - absolute path,
    #                '5' - relative path,
    #                '6' - valid path)
    # <"$2"> - string
    #
    # Returns:
    # (0) true
    # (1) false
    #
    assert() {
        case $1 in
            1)
                case :"$2${2#*[!0123456789]}" in
                    :) return 1 ;;
                    :"$2$2") : ;;
                    *) return 1 ;;
                esac
            ;;
            2)
                case :"$2${2#*[!0123456789]}" in
                    :) return 1 ;;
                    :00) : ;;
                    :0*) return 1 ;;
                    :"$2$2") : ;;
                    *) return 1 ;;
                esac
            ;;
            3)
                case :"$2${2#*[!0123456789]}" in
                    : | :0*) return 1 ;;
                    :"$2$2") : ;;
                    *) return 1 ;;
                esac
            ;;
            4)
                case "$2" in
                    *'//'*) return 1 ;;
                    '/'*) : ;;
                    *) return 1 ;;
                esac
            ;;
            5)
                case "$2" in
                    *'//'* | '/'*) return 1 ;;
                esac
            ;;
            6)
                case "$2" in
                    *'//'*) return 1 ;;
                esac
            ;;
        esac
    }

    # Description:
    # True if complex (argument) option
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Uses:
    # <_opt> $ - the first positional parameter of the main environment
    # <_opt_arg> $ - the second positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_arg"> - the option argument
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    copt() {
        copt_arg_invalid() {
            printf "%s: Invalid argument specification for: '%s'\n" \
                   "${0##*/}" "$1" 1>&2
            printf "%s: Try '%s --help' for more information.\n" \
                   "${0##*/}" "${0##*/}" 1>&2
        }
        copt_arg_missing() {
            printf "%s: Option '%s' requires an argument.\n" \
                   "${0##*/}" "$1" 1>&2
            printf "%s: Try '%s --help' for more information.\n" \
                   "${0##*/}" "${0##*/}" 1>&2
        }

        [ "$_opt" ] || return 1

        case "$_opt" in
            '--'*)
                case "$1$2" in
                    '--'*) : ;;
                    "$1"'--'*) set -- "$2" ;;
                    *) return 1 ;;
                esac

                case "$_opt " in
                    "$1"'= ')
                        copt_arg_invalid "$1"
                        exit 2
                    ;;
                    "$1"'='*)
                        _opt_arg="${_opt#"$1"=}"; _opt=; _opt_match="$1"; \
                        _shiftN=1
                        return 0
                    ;;
                    "$1"' ')
                        [ "$_opt_arg" ] || { copt_arg_missing "$1"; exit 2; }

                        _opt=; _opt_match="$1"; _shiftN=2
                        return 0
                    ;;
                esac
            ;;
            '-'*)
                case "$1$2" in
                    '-'*) : ;;
                    *) return 1 ;;
                esac

                case "$_opt " in
                    "$1"' ')
                        [ "$_opt_arg" ] || { copt_arg_missing "$1"; exit 2; }

                        _opt=; _opt_match="$1"; _shiftN=2
                        return 0
                    ;;
                    "$1"*)
                        _opt_arg="${_opt#"$1"}"; _opt=; _opt_match="$1"; \
                        _shiftN=1
                        return 0
                    ;;
                esac
            ;;
        esac

        return 1
    }

    # Description:
    # True if optional-complex (possible argument) option
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Uses:
    # <_opt> $ - the first positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_arg"> - the option argument
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    copt_optional() {
        copt_arg_invalid() {
            printf "%s: Invalid argument specification for: '%s'\n" \
                   "${0##*/}" "$1" 1>&2
            printf "%s: Try '%s --help' for more information.\n" \
                   "${0##*/}" "${0##*/}" 1>&2
        }

        [ "$_opt" ] || return 1

        case "$_opt" in
            '--'*)
                case "$1$2" in
                    '--'*) : ;;
                    "$1"'--'*) set -- "$2" ;;
                    *) return 1 ;;
                esac

                case "$_opt" in
                    "$1"'=')
                        copt_arg_invalid "$1"
                        exit 2
                    ;;
                    "$1"'='*)
                        _opt_arg="${_opt#"$1"=}"; _opt=; _opt_match="$1"; \
                        _shiftN=1
                        return 0
                    ;;
                    "$1")
                        _opt=; _opt_arg=; _opt_match="$1"; _shiftN=1
                        return 0
                    ;;
                esac
            ;;
            '-'*)
                case "$1$2" in
                    '-'*) : ;;
                    *) return 1 ;;
                esac

                case "$_opt" in
                    "$1")
                        _opt=; _opt_arg=; _opt_match="$1"; _shiftN=1
                        return 0
                    ;;
                    "$1"*)
                        _opt_arg="${_opt#"$1"}"; _opt=; _opt_match="$1"; \
                        _shiftN=1
                        return 0
                    ;;
                esac
            ;;
        esac

        return 1
    }

    # Description:
    # Within single quotes escape single quote(s) in string
    #
    # Parameters:
    # <"$1"+> - string
    #
    # Provides:
    # <"$_str"> - the escaped string | string
    #
    # Returns:
    # (0) escaped string | string
    #
    esc_sq() {
        [ "$1" ] || return 0

        _str="$1"

        case "$_str" in
            *"'"*)
                _str_ref="${_str%%\'*}'\\''"
                _str="${_str_ref}${_str#*\'}"

                while :; do case "$_str" in
                    "$_str_ref"*"'"*)
                        _str="${_str#*"$_str_ref"}"
                        _str_ref="$_str_ref${_str%%\'*}'\\''"
                        _str="$_str_ref${_str#*\'}"
                    ;;
                    *)
                        break
                    ;;
                esac done
            ;;
        esac

        _str="'$_str'"; printf "%s" "$_str"; shift

        while [ "$1" ]; do
            case "$1" in
                *"'"*) : ;;
                *) _str="$_str '$1'"; printf " '%s'" "$1"; shift && continue ;;
            esac

            _str_ref="${1%%\'*}'\\''"
            __str="${_str_ref}${1#*\'}"

            while :; do case "$__str" in
                "$_str_ref"*"'"*)
                    __str="${__str#*"$_str_ref"}"
                    _str_ref="$_str_ref${__str%%\'*}'\\''"
                    __str="$_str_ref${__str#*\'}"
                ;;
                *)
                    break
                ;;
            esac done

            _str="$_str '$__str'"; printf " '%s'" "$__str"; shift
        done
    }

    # Description:
    # Signify invalid operand count (max)[X>X]
    #
    # Parameters:
    # <$1> - invalid count
    # [$2] - valid count
    #
    opd_cmax() {
        printf "%s: Too many operands: %s\n" "${0##*/}" "$1"

        [ "$2" ] && printf " > max allowed: %s\n" "$2"

        printf "%s: Try '%s --help' for more information.\n" \
               "${0##*/}" "${0##*/}"
    } 1>&2

    # Description:
    # Signify invalid operand count (max)[X>1]
    #
    # Parameters:
    # <"$1"> - first operand
    # <"$2"> - second operand
    # ["$3"] - the next practicable operand
    #
    opd_max() {
        if [ "$3" ]; then
            printf "%s: Too many operands: '[%s]; [%s]; ...'\n" \
                   "${0##*/}" "$1" "$2"
        else
            printf "%s: Too many operands: '[%s]; [%s]'\n" "${0##*/}" "$1" "$2"
        fi
        printf "%s: Try '%s --help' for more information.\n" \
               "${0##*/}" "${0##*/}"
    } 1>&2

    # Description:
    # Signify invalid operand count (min)[0>X]
    #
    opd_min() {
        printf "%s: No operand specified.\n" "${0##*/}"
        printf "%s: Try '%s --help' for more information.\n" \
               "${0##*/}" "${0##*/}"
    } 1>&2

    # Description:
    # Signify invalid option argument
    #
    # Parameters:
    # <"$1"> - option
    # <"$2"> - argument
    # ["$3"+] - valid arguments
    #
    opt_err() {
        printf "%s: Invalid argument '%s' for '%s'\n" \
               "${0##*/}" "$2" "$1"
        shift 2

        if [ "$1" ]; then
            echo "Valid arguments are:"

            while [ "$1" ]; do
                printf " > '%s'\n" "$1"; shift
            done
        fi

        printf "%s: Try '%s --help' for more information.\n" \
               "${0##*/}" "${0##*/}"
    } 1>&2

    # Description:
    # Signify invalid option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_invalid() {
        printf "%s: Invalid option: '%s'\n" "${0##*/}" "$1"
        printf "%s: Try '%s --help' for more information.\n" \
               "${0##*/}" "${0##*/}"
    } 1>&2

    # Description:
    # Signify unknown (*) option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unknown() {
        printf "%s: Unknown option: '%s'\n" "${0##*/}" "$1"
        printf "%s: Try '%s --help' for more information.\n" \
               "${0##*/}" "${0##*/}"
    } 1>&2

    # Description:
    # Signify unrecognized ('--') option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unrecognized() {
        printf "%s: Unrecognized option: '%s'\n" "${0##*/}" "$1"
        printf "%s: Try '%s --help' for more information.\n" \
               "${0##*/}" "${0##*/}"
    } 1>&2

    # Description:
    # True if specific complex (argument) option
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Uses:
    # <_opt> $ - the first positional parameter of the main environment
    # <_opt_arg> $ - the second positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_arg"> - the option argument
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    scopt() {
        scopt_arg_invalid() {
            printf "%s: Invalid argument specification for: '%s'\n" \
                   "${0##*/}" "$1" 1>&2
            printf "%s: Try '%s --help' for more information.\n" \
                   "${0##*/}" "${0##*/}" 1>&2
        }
        scopt_arg_missing() {
            printf "%s: Option '%s' requires an argument.\n" \
                   "${0##*/}" "$1" 1>&2
            printf "%s: Try '%s --help' for more information.\n" \
                   "${0##*/}" "${0##*/}" 1>&2
        }

        [ "$_opt" ] || return 1

        while [ "$1" ]; do
            case "$_opt " in
                "$1"'= ')
                    scopt_arg_invalid "$1"
                    exit 2
                ;;
                "$1"'='*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
                "$1"' ')
                    [ "$_opt_arg" ] || { scopt_arg_missing "$1"; exit 2; }

                    _opt=; _opt_match="$1"; _shiftN=2
                    return 0
                ;;
            esac

            shift
        done

        return 1
    }

    # Description:
    # True if specific optional-complex (possible argument) option
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Uses:
    # <_opt> $ - the first positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_arg"> - the option argument
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    scopt_optional() {
        scopt_arg_invalid() {
            printf "%s: Invalid argument specification for: '%s'\n" \
                   "${0##*/}" "$1" 1>&2
            printf "%s: Try '%s --help' for more information.\n" \
                   "${0##*/}" "${0##*/}" 1>&2
        }

        [ "$_opt" ] || return 1

        while [ "$1" ]; do
            case "$_opt" in
                "$1"'=')
                    scopt_arg_invalid "$1"
                    exit 2
                ;;
                "$1"'='*)
                    _opt_arg="${_opt#"$1"=}"; _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
                "$1")
                    _opt=; _opt_arg=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
            esac

            shift
        done

        return 1
    }

    # Description:
    # True if simple (no argument) option
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Uses:
    # <_opt> $ - the first positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    # ["$_sopt_index"] - an index with encountered short options
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    sopt() {
        [ "$_opt" ] || return 1

        case "$_opt" in
            '--'*)
                case "$1$2" in
                    '--'*) : ;;
                    "$1"'--'*) set -- "$2" ;;
                    *) return 1 ;;
                esac

                case "$_opt" in
                    "$1")
                        _opt=; _opt_match="$1"; _shiftN=1
                        return 0
                    ;;
                esac
            ;;
            '-'*)
                case "$1$2" in
                    '-'*) : ;;
                    *) return 1 ;;
                esac

                case "$_opt" in
                    "$1"*)
                        case :"$_sopt_index" in
                            :) _sopt_index="${1#?}" ;;
                            *) _sopt_index="$_sopt_index${1#?}" ;;
                        esac

                        _opt="-${_opt#??}"; _opt_match="$1"; _shiftN=1
                        return 0
                    ;;
                esac
            ;;
        esac

        return 1
    }

    # Description:
    # True if specific simple (no argument) option
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Uses:
    # <_opt> $ - the first positional parameter of the main environment
    #
    # Provides:
    # <"$_opt_match"> - the literal option matched
    # <$_shiftN> - the shift count
    #
    # Returns:
    # (0) match
    # (1) no match
    #
    ssopt() {
        [ "$_opt" ] || return 1

        while [ "$1" ]; do
            case "$_opt" in
                "$1")
                    _opt=; _opt_match="$1"; _shiftN=1
                    return 0
                ;;
            esac

            shift
        done

        return 1
    }
}

# Description:
# Parse utility options
#
# Uses:
# <_opt> $ - {state - anything}; [iteration - X]
#
# Returns:
# (0) $_opt has been parsed
# (1) $_opt is not an option
#
options() {
    _opt_fail() { opt_err "$_opt_match" "$_opt_arg" "$@"; exit 2; }

    unset _sopt_index

    case "$_opt" in
        '-'*)
            sopt '--no-color' && { ncolor=1; }
            copt '--language' && { language="$_opt_arg"; }
            copt '--locale' && { locale="$_opt_arg"; }

            sopt '-s' '--sign-off' && { soff=1; }
            sopt '-S' '--gpg-sign' && { gsign=1; }
            sopt '-v' '--git-version' && { gver=1; }
        ;;
        *)
            ssopt 'a' 'abort' && { merge_op=ABORT; }
            ssopt 'c' 'continue' && { merge_op=CONTINUE; }
            ssopt 's' 'status' && { merge_op=STATUS; }
        ;;
    esac

    [ "$_opt" ] || return 0

    case "$_opt" in
        '--'*)
            opt_unrecognized "$_opt"; exit 2
        ;;
        '-'*)
            case :"$_sopt_index" in
                :) opt_invalid "${_opt%"${_opt#??}"}"; exit 2 ;;
            esac

            case ${#_opt} in
                1) unset _opt _sopt_index; return 0 ;;
            esac

            options;
        ;;
    esac

    return 1
}

main() {
    # Source common functions
    main_functions;

    # Parse options
    while [ "$1" ]; do
        # Simulate global $N (positional parameters) shift
        #  > option functions modify when appropriate
        _shiftN=1

        # Simulate global $1/$2 (option/argument) handling
        #  > option functions modify when appropriate
        _opt="$1"; _opt_arg="$2"

        # Parse standard options
        #  > required to parse them first
        ssopt '-' && { opt_invalid "$1"; exit 2; }
        ssopt '--' && { shift && break; }
        ssopt '--help' && { usage; exit 0; }
        ssopt '--version' && { version; exit 0; }

        # Parse utility options
        #  > rc 1 if $_opt is not a valid option
        options || {
            case :"$BRANCH" in
                :) BRANCH="$_opt" ;;
                *) opd_max "$BRANCH" "$_opt" "$2"; exit 2 ;;
            esac
        }

        # Move on positional parameters
        #  > either with default value or with option value
        shift "$_shiftN"
    done

    # Parse operands
    while [ "$1" ]; do
        case :"$BRANCH" in
            :) BRANCH="$1" ;;
            *) opd_max "$BRANCH" "$1" "$2"; exit 2 ;;
        esac

        shift
    done

    # Core operations
    if [ "$merge_op" = ABORT ]; then
        admerge_abort;
    elif [ "$merge_op" = CONTINUE ]; then
        admerge_continue;
    elif [ "$merge_op" = STATUS ]; then
        admerge_status;
    else
        if [ "$BRANCH" ]; then
            admerge;
        else
            opd_min; exit 2
        fi
    fi

    # Check if RC is set, otherwise explicit success
    [ "$RC" ] && return "$RC" || return 0
}

main "$@"
