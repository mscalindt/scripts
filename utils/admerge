#!/bin/sh
# shellcheck disable=SC2016
# shellcheck disable=SC2034
# shellcheck disable=SC2046
# shellcheck disable=SC2048
# shellcheck disable=SC2059
# shellcheck disable=SC2086

: <<'notice'
 * SPDX-License-Identifier: GPL-3.0
 *
 * Copyright (C) 2021 Dimitar Yurukov <mscalindt@protonmail.com>
 *
notice

usage() {
printf "%s" "\
Usage: admerge [options] [--] [BRANCH]
Do an advanced, better merge. (git wrapper)

Options:
  -s, --sign-off             add Signed-off-by line at the end of the commit
                             message; requires preconfigured signoff info for
                             seamless work
  -S, --gpg-sign             sign the merge commit; requires preconfigured key
                             and user.signingkey for seamless work
  -v, --git-version          print the git version at the end of the commit
                             message
      --help     display this help text and exit
      --         specify end of options

In-merge options (merge with conflicts):
  a, abort                   abort a merge in progress; this option disregards
                             other options
  c, continue                resume a merge; this option disregards other
                             options
  s, status                  show status of the current merge; this option
                             disregards other options

External utilities dependency list:
git, rm.
"
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2+"> - text
#
err() {
    i=$1 && shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $i
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <'$1'> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is, on its own, $2)
#
# Returns:
# (0) substring exists
# (1) no substring
#
grep_str() {
    if [ $# -eq 3 ]; then
        if [ $3 -eq 1 ]; then
            case "$2" in "$1"*) grep_str=0 && return 0 ;; esac
        elif [ $3 -eq 2 ]; then
            case "$2" in *"$1") grep_str=0 && return 0 ;; esac
        elif [ $3 -eq 3 ]; then
            case "$2" in "$1") grep_str=0 && return 0 ;; esac
        fi
    else
        case "$2" in *"$1"*) grep_str=0 && return 0 ;; esac
    fi

    return 1
}

# Description:
# Get positional substring, (from LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <'$2'> - from "X" character(s)
# <"$3"> - string
# [$4] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$5] - mode('3' - keep $2)
# [$6] - mode('4' - verify the expansion)
#
# Returns:
# (0) substring
# (1) empty expansion (empty, or unspecified, or wrong -- shell specific)
# (2) unspecified expansion (unspecified, or empty, or wrong -- shell specific)
#
# Returns (mode '4'):
# (0) substring
# (1) empty expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion ($2 is not present at all)
# (3) wrong expansion ($1 is greater than the total $2 in the string)
#
# Caveats:
# 1. If mode 4 is NOT passed, you should NOT assume the expansion is
#    respectively correct, even if the return code is 0. This is because every
#    shell has its own unique string expander and unspecified results will vary
#    between them; for example, if $2 is not present anymore or at all, one
#    shell might return the same expansion, while another might return empty
#    expansion. Also, the string expander on its own does NOT guarantee correct
#    expansion at all.
#    Fix: Use mode '4'. When mode 4 is passed, the function will do various
#    checks on each expansion to accurately determine what the expansion will
#    result into; this guarantees respectively correct expansion on any shell.
#    Performance cost should be negligible on most shells.
#
ltr_substr0() {
    if [ $# -eq 6 ] || \
       [ $# -ge 5 ] && [ $5 -eq 4 ] || \
       [ $# -ge 4 ] && [ $4 -eq 4 ]; then
        case $1 in
            0)
                case "$3" in
                    *"$2") return 1 ;;
                    *"$2"*) : ;;
                    *) return 2 ;;
                esac

                i="${3##*"$2"}"
            ;;
            *)
                case $1"$3" in
                    $1*"$2"*"$2"*) : ;;
                    1*"$2") return 1 ;;
                    $1*"$2"*) : ;;
                    *) return 2 ;;
                esac

                x=0 && i="$3"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"

                    case "$i" in
                        *"$2"*"$2"*) : ;;
                        *"$2") [ $((x + 2)) -eq $1 ] && return 1 ;;
                        *"$2"*) : ;;
                        *) [ $((x + 1)) -ne $1 ] && return 3 ;;
                    esac

                    x=$((x + 1))
                done
            ;;
        esac
    else
        case $1 in
            0)
                i="${3##*"$2"}"
            ;;
            *)
                x=0 && i="$3"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"
                    x=$((x + 1))
                done
            ;;
        esac

        [ "$i" = "$3" ] && return 2
    fi

    if [ -n "$i" ]; then
        if [ $# -ge 4 ] && [ $4 -eq 0 ]; then
            i="${i#${i%%[![:space:]]*}}"
        elif [ $# -ge 4 ] && [ $4 -eq 1 ]; then
            i="${i%${i##*[![:space:]]}}"
        elif [ $# -ge 4 ] && [ $4 -eq 2 ]; then
            i="${i#${i%%[![:space:]]*}}"
            i="${i%${i##*[![:space:]]}}"
        fi

        if [ $# -ge 5 ] && [ $5 -eq 3 ] || \
           [ $# -ge 4 ] && [ $4 -eq 3 ]; then
            i="$2$i"
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Get positional substring, (from&to LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <'$2'> - from "X" character(s)
# <$3> - to "N" $2-TR character('0' - max)
# <'$4'> - to "X" character(s)
# <"$5"> - string
# [$6] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$7] - mode('3' - keep $2,
#             '4' - keep $4,
#             '5' - keep $2/$4)
# [$8] - mode('6' - verify the expansion)
#
# Returns:
# (0) substring
# (1) empty expansion (empty, or unspecified, or wrong -- shell specific)
# (2) unspecified expansion (unspecified, or empty, or wrong -- shell specific)
#
# Returns (mode '6'):
# (0) substring
# (1) unspecified expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion ($2 is not present at all)
# (3) wrong expansion ($1 is greater than the total $2 in the string)
# (4) empty expansion (empty expansion by the given ruleset)
# (5) unspecified expansion ($4 is not present at all)
# (6) wrong expansion ($3 is greater than the total $4 in the string)
#
# Caveats:
# 1. If mode 6 is NOT passed, you should NOT assume the expansion is
#    respectively correct, even if the return code is 0. This is because every
#    shell has its own unique string expander and unspecified results will vary
#    between them; for example, if $2/$4 is not present anymore or at all, one
#    shell might return the same expansion, while another might return empty
#    expansion. Also, the string expander on its own does NOT guarantee correct
#    expansion at all.
#    Fix: Use mode '6'. When mode 6 is passed, the function will do various
#    checks on each expansion to accurately determine what the expansion will
#    result into; this guarantees respectively correct expansion on any shell.
#    Performance cost should be negligible on most shells.
#
ltr_substr1() {
    if [ $# -eq 8 ] || \
       [ $# -ge 7 ] && [ $7 -eq 6 ] || \
       [ $# -ge 6 ] && [ $6 -eq 6 ]; then
        case $1 in
            0)
                case "$5" in
                    *"$2") return 1 ;;
                    *"$2"*) : ;;
                    *) return 2 ;;
                esac

                i="${5##*"$2"}"
            ;;
            *)
                case $1"$5" in
                    $1*"$2"*"$2"*) : ;;
                    1*"$2") return 1 ;;
                    $1*"$2"*) : ;;
                    *) return 2 ;;
                esac

                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"

                    case "$i" in
                        *"$2"*"$2"*) : ;;
                        *"$2") [ $((x + 2)) -eq $1 ] && return 1 ;;
                        *"$2"*) : ;;
                        *) [ $((x + 1)) -ne $1 ] && return 3 ;;
                    esac

                    x=$((x + 1))
                done
            ;;
        esac

        case $3 in
            0)
                case "$i" in
                    *"$4"*"$4"*) : ;;
                    "$4"*) return 4 ;;
                    *"$4"*) : ;;
                    *) return 5 ;;
                esac

                i="${i%"$4"*}"
            ;;
            *)
                case $3"$i" in
                    1"$4"*) return 4 ;;
                    $3*"$4"*) : ;;
                    *) return 5 ;;
                esac

                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i#*"$4"}"

                    case "$i" in
                        *"$4"*) : ;;
                        *) [ $((x + 1)) -ne $3 ] && return 6 ;;
                    esac

                    x=$((x + 1))
                done
                [ -z "$i" ] && i="${ii%"$4"}" || i="${ii%"$4""$i"}"
            ;;
        esac
    else
        case $1 in
            0)
                i="${5##*"$2"}"
            ;;
            *)
                x=0 && i="$5"
                until [ $x -eq $1 ]; do
                    i="${i#*"$2"}"
                    x=$((x + 1))
                done
            ;;
        esac

        case $3 in
            0)
                i="${i%"$4"*}"
            ;;
            *)
                x=0 && ii="$i"
                until [ $x -eq $3 ]; do
                    i="${i#*"$4"}"
                    x=$((x + 1))
                done
                i="${ii%"$4""$i"}"
            ;;
        esac

        [ "$i" = "$5" ] && return 2
    fi

    if [ -n "$i" ]; then
        if [ $# -ge 6 ] && [ $6 -eq 0 ]; then
            i="${i#${i%%[![:space:]]*}}"
        elif [ $# -ge 6 ] && [ $6 -eq 1 ]; then
            i="${i%${i##*[![:space:]]}}"
        elif [ $# -ge 6 ] && [ $6 -eq 2 ]; then
            i="${i#${i%%[![:space:]]*}}"
            i="${i%${i##*[![:space:]]}}"
        fi

        if [ $# -ge 7 ] && [ $7 -eq 3 ] || \
           [ $# -ge 6 ] && [ $6 -eq 3 ]; then
            i="$2$i"
        elif [ $# -ge 7 ] && [ $7 -eq 4 ] || \
             [ $# -ge 6 ] && [ $6 -eq 4 ]; then
            i="$i$4"
        elif [ $# -ge 7 ] && [ $7 -eq 5 ] || \
             [ $# -ge 6 ] && [ $6 -eq 5 ]; then
            i="$2$i$4"
        fi

        printf "%s" "$i" && return 0
    fi

    return 1
}

# Description:
# Parse the content of file
#
# Parameters:
# <$1> - mode('0' - one-to-one copy,
#             '1' - wrap parsed lines in one leading/trailing whitespace char,
#             '2' - wrap parsed lines in two leading/trailing whitespace chars,
#             '3' - skip empty lines,
#             '4' - strip trailing/leading whitespace chars)
# <"$2"> - file
#
# Returns:
# (0) output | empty output (file)
# (1) file does not exist | file permission error
#
parse() {
    case $1 in
        0)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf "%s\n" "$LINE"
            done < "$2"
        ;;
        1)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf " %s \n" "$LINE"
            done < "$2"
        ;;
        2)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                printf "  %s  \n" "$LINE"
            done < "$2"
        ;;
        3)
            while IFS= read -r LINE || [ -n "$LINE" ]; do
                [ -n "$LINE" ] && printf "%s\n" "$LINE"
            done < "$2"
        ;;
        4)
            while read -r LINE || [ -n "$LINE" ]; do
                printf "%s\n" "$LINE"
            done < "$2"
        ;;
    esac

    return $?
}

# Description:
# Print specific line in file
#
# Parameters:
# <$1> - line number
# <"$2"> - file
#
# Returns:
# (0) line's content | line empty
# (1) line does not exist | file permission error
#
pline() {
    x=0

    while read -r LINE || [ -n "$LINE" ]; do
        x=$((x + 1))
        [ $x -eq $1 ] && printf "%s" "$LINE" && return 0
    done < "$2"

    return 1
}

# Description:
# Remove specific character(s) in string
#
# Parameters:
# <'$1'> - character(s)
# <"$2"> - string
#
# Returns:
# $2 without $1 characters,
# $2
#
remchars() {
    set -f

    i=$IFS

    IFS=$1
    set -- $2

    IFS=
    set -- $*

    printf "%s\n" "$*"

    IFS=$i

    set +f
}

# Description:
# Print a warning
#
# Parameters:
# <"$1+"> - text
#
warn() {
    printf "%bWARNING:%b %s\n" "\033[1;33m" "\033[0m" "$*"
}

# Description:
# Get N attribute in the lock file
#
# Parameters:
# <$1> - N
#
# Returns:
# (0) N attribute
# (1) N attribute does not exist
#
_aq() {
    x=$1
    i=$(pline 1 "$ALOCK")
    x=$((x - 1 + x))
    i=$(ltr_substr1 $x '@' 1 '@' "$i" 6)

    [ -n "$i" ] && printf "%s" "$i" && return 0

    return 1
}

# Description:
# Check if an attribute exists in the lock file
#
# Parameters:
# <"$1"> - attribute
#
# Returns:
# (0) attribute exists
# (1) no attribute
#
_ac() {
    i=$(pline 1 "$ALOCK") && grep_str "@$1@" "$i" && return 0

    return 1
}

# Description:
# Return lock format for an attribute
#
# Parameters:
# <"$1"> - attribute('1' - begin lock format,
#                    '2' - end lock format)
# ['$2'] - test variable
#
# Returns:
# (0) format
# (1) variable is empty/unset
#
_aw() {
    [ $# -eq 2 ] && i=$(eval "echo $2") && [ ! "$i" ] && return 1

    case "$1" in
        1) printf " " ;;
        2) printf " \n" ;;
        *) printf "@%s@ " "$1" ;;
    esac
}

# Description:
# Run a git command for the msg file
#
# Parameters:
# <"$1"> - printf format('1' - "%s\n",
#                        '2' - "%s\n\n",
#                        '3' - "\n%s\n")
# ["$2"] - command
# ['$3'] - test variable
# [$4] - mode('0' - unique commits, "..",
#             '1' - unique commits of both, "...")
#
# Returns:
# (0) output
# (1) variable is empty/unset | no command output
#
_mc() {
    if [ $# -eq 4 ]; then
        i=$(eval "echo $3") && [ ! "$i" ] && return 1
        case $4 in
            0) i=$(git $2 ${OBR}..${TBR} 2> /dev/null) ;;
            1) i=$(git $2 ${OBR}...${TBR} 2> /dev/null) ;;
        esac
    elif [ $# -eq 3 ]; then
        case "$3" in
            '$'*) i=$(eval "echo $3") && [ ! "$i" ] && return 1 ;;
        esac
        case "$3" in
            0) i=$(git $2 ${OBR}..${TBR} 2> /dev/null) ;;
            1) i=$(git $2 ${OBR}...${TBR} 2> /dev/null) ;;
            *) i=$(git $2 2> /dev/null) ;;
        esac
    elif [ $# -eq 2 ]; then
        case "$2" in
            '$'*)
                i=$(eval "echo $2") && [ ! "$i" ] && return 1
                printf "$1" && return 0
            ;;
            *) i=$(git $2 2> /dev/null) ;;
        esac
    else
        printf "$1" && return 0
    fi

    if [ -n "$i" ]; then
        case "$1" in
            1) printf "%s\n" "$i" ;;
            2) printf "%s\n\n" "$i" ;;
            3) printf "\n%s\n" "$i" ;;
            *) printf "$1" "$i" ;;
        esac
        return 0
    fi

    return 1
}

# Description:
# Return info format for status
#
# Parameters:
# <"$1"> - printf format
# ['$2'] - command
# ['$3'] - test variable
#
# Returns:
# (0) format
# (1) variable is empty/unset | no command output
#
_qi() {
    if [ $# -eq 3 ]; then
        i=$(eval "echo $3") && [ ! "$i" ] && return 1
        i=$(eval 'echo $2') && i=$(eval $i 2> /dev/null)
    elif [ $# -eq 2 ]; then
        case "$2" in
            '$'*)
                i=$(eval "echo $2") && [ ! "$i" ] && return 1
                printf "$1\n" "\033[1;37m" "\033[0m" && return 0
            ;;
            *) i=$(eval 'echo $2') && i=$(eval $i 2> /dev/null) ;;
        esac
    else
        printf "$1\n" "\033[1;37m" "\033[0m" && return 0
    fi

    [ -n "$i" ] && printf "$1\n" "\033[1;37m" "\033[0m" "$i" && return 0

    return 1
}

admerge_env() {
    hash git > /dev/null 2>&1

    OBR=$(git symbolic-ref --short HEAD 2> /dev/null)
    ALOCK="$PWD"/.git/admerge_lock
    AMSG="$PWD"/.git/admerge_msg

    [ "$1" ] && TBR="$1" || TBR=
}

admerge_check() {
    [ -z $OBR ] && \
        err 1 "Failed to identify current branch. (not in git repository?)"

    if [ $1 ]; then
        if [ ! -r "$ALOCK" ]; then
            err 2 "No lock file found. (no merge in progress?)"
        fi
    else
        if [ -r "$ALOCK" ]; then
            err 2 "A merge is already in progress. ($ALOCK)"
        fi
    fi

    if [ ! $1 ]; then
        if [ -r "$AMSG" ]; then
            err 1 "'$AMSG' exists, but no lock file is found. (manual lock rm?)"
        fi
    fi
}

admerge_lock() {
    {
    _aw "1"
    _aw "$TBR"
    _aw "s" '$soff'
    _aw "S" '$gsign'
    _aw "2"
    } >> "$ALOCK"
}

admerge_msg() {
    {
    _mc "Merge '$TBR' into '$OBR'\n\n"
    _mc "Summary of commits (%d):\n" "rev-list --count" 0
    _mc "1" "log --oneline" 0
    _mc "3" "--version" '$gver'
    } >> "$AMSG"
}

admerge_work() {
    gitm_args="--no-ff --no-commit $TBR"
    gitc_args="-eF $AMSG --no-edit"

    if [ -r "$ALOCK" ]; then
        _ac "s" && gitc_args="--signoff ${gitc_args}"
        _ac "S" && gitc_args="--gpg-sign ${gitc_args}"
    fi

    if [ $1 ] && [ $1 = s ]; then
        _qi "%bOur branch:%b $OBR"
        _qi "%bTheir branch:%b %s" '_aq 1'
        _qi "%bLock file location:%b $ALOCK"
        _qi "%bLock file content:%b '%s'" 'pline 1 "$ALOCK"'
        _qi "%bCommit message file location:%b $AMSG"
        _qi "%bCommit message file content:%b\n%s" 'parse 3 "$AMSG"'
        _qi "%bStatus of files:%b\n%s" 'git -c color.ui=always status -s'
    fi
}

admerge_exec() {
    if [ $1 ] && [ $1 = a ]; then
        ! git merge --abort && exit 1
    elif [ $1 ] && [ $1 = c ]; then
        ! git commit ${gitc_args} && exit 1
    else
        ! git merge ${gitm_args} && \
            git merge HEAD > /dev/null 2>&1 && RC=1 && return 1 || exit 1
        ! git commit ${gitc_args} && exit 1
    fi
}

admerge_post() {
    rm -f "$ALOCK" "$AMSG"
}

admerge_abort() {
    admerge_env;
    admerge_check "a"
    admerge_exec "a"
    admerge_post;
}

admerge_continue() {
    admerge_env;
    admerge_check "c"
    admerge_work;
    admerge_exec "c"
    admerge_post;
}

admerge_status() {
    admerge_env;
    admerge_check "s"
    admerge_work "s"
}

admerge() {
    admerge_env "$1"
    admerge_check;
    admerge_lock;
    admerge_msg;
    admerge_work;
    admerge_exec;
    admerge_post;
}

main() {
    # For security reasons, unset conditional variables if they exist
    [ -n "$soff" ] && unset soff
    [ -n "$gsign" ] && unset gsign
    [ -n "$gver" ] && unset gver
    [ -n "$RC" ] && unset RC

    # Serve the script until no script parameters passed
    while [ "$1" ]; do
        # Reset variables from previous loop run
        [ -n "$grep_str" ] && unset grep_str

        case "$1" in
            # Parse specific options first
            "--") shift && break ;;
            "--help") usage && return 0 ;;
            "a" | "abort") admerge_abort && return 0 ;;
            "c" | "continue") admerge_continue && return 0 ;;
            "s" | "status") admerge_status && return 0 ;;

            # Parse options
            "--"*)
                i=$(ltr_substr0 1 '--' "$1")

                if grep_str 'sign-off' "$i" 3; then soff=1; fi 
                if grep_str 'gpg-sign' "$i" 3; then gsign=1; fi
                if grep_str 'git-version' "$i" 3; then gver=1; fi

                if [ ! $grep_str ]; then
                    warn "Unrecognized option: '$1'. See --help"
                fi
                shift
            ;;
            "-"*)
                i=$(ltr_substr0 1 '-' "$1")

                if grep_str 's' "$i"; then soff=1; fi
                if grep_str 'S' "$i"; then gsign=1; fi
                if grep_str 'v' "$i"; then gver=1; fi

                i=$(remchars 'sSv' "$i")
                if [ -n "$i" ]; then
                    warn "Unrecognized option(s): '-$i'. See --help"
                fi
                shift
            ;;

            *) break ;;
        esac
    done

    # Catch wrong input
    if [ ! "$1" ]; then
        err 2 "No branch/tag specified."
    elif [ "$2" ]; then
        err 2 "Too many operands. ($#)"
    fi

    # Execute the core function
    admerge "$1"

    # Check if RC is set, otherwise explicit success
    [ -n "$RC" ] && return $RC || return 0
}

main "$@"
