#!/bin/sh
# SPDX-License-Identifier: GPL-3.0
# shellcheck disable=SC2048 # ShellCheck incorrect pedantic warning

_copyright() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'COPYRIGHT'
Copyright (C) 2021-2022 Dimitar Yurukov <mscalindt@protonmail.com>
COPYRIGHT
}

_description() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'DESCRIPTION'
Do an advanced, better merge. (git wrapper)
DESCRIPTION
}

_license() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'LICENSE'
License GPLv3: GNU GPL version 3
LICENSE
}

_misc() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'MISC'
External utilities hard dependency list:
git, rm.
External utilities soft dependency list:
.
MISC
}

_notice() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'NOTICE'
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
NOTICE
}

_options() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'OPTIONS'
In-merge options (merge with conflicts):
  a, abort                   abort a merge in progress; this option disregards
                             other options
  c, continue                resume a merge; this option disregards other
                             options
  s, status                  show status of the current merge; this option
                             disregards other options

Options:
      --no-color             colorless output on all streams
  -s, --sign-off             add Signed-off-by line at the end of the commit
                             message; requires preconfigured signoff info for
                             seamless work
  -S, --gpg-sign             sign the merge commit; requires preconfigured key
                             and user.signingkey for seamless work
  -v, --git-version          print the git version at the end of the commit
                             message
      --help     display this help text and exit
      --version  display version information and exit
      --         specify end of options
OPTIONS
}

_usage() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'USAGE'
Usage: admerge [options] <a|c|s|BRANCH>
USAGE
}

_version() {
    while IFS= read -r LINE; do printf "%s\n" "$LINE"; done \
<<'VERSION'
admerge 0.0.0
VERSION
}

usage() {
    _usage; _description; echo
    _options; echo
    _misc;
}

version() {
    _version; echo
    _copyright; echo
    _license; _notice;
}

# Description:
# Print error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err() {
    i=$1 && shift
    printf "\nERROR: %s\n\n" "$*" 1>&2
    exit $i
}

# Description:
# Print colorful error and exit
#
# Parameters:
# <$1> - exit code
# <"$2"+> - text
#
err_clr() {
    i=$1 && shift
    printf "\n%bERROR:%b %s\n\n" "\033[1;31m" "\033[0m" "$*" 1>&2
    exit $i
}

# Description:
# Check the existence/position of a substring in string
#
# Parameters:
# <"$1"> - substring
# <"$2"> - string
# [$3] - mode('1' - $1 is first character(s) of $2,
#             '2' - $1 is last character(s) of $2,
#             '3' - $1 is, on its own, $2)
#
# Returns:
# (0) match
# (1) no match
#
grep_str() {
    case $#:$3 in
        2:) case "$2" in *"$1"*) return 0 ;; esac ;;
        3:1) case "$2" in "$1"*) return 0 ;; esac ;;
        3:2) case "$2" in *"$1") return 0 ;; esac ;;
        3:3) case "$2" in "$1") return 0 ;; esac ;;
    esac

    return 1
}

# Description:
# Get positional substring, (from&to LTR) (N)character(s), in a string
#
# Parameters:
# <$1> - from "N" LTR character('0' - max)
# <"$2"> - from "X" character(s)
# <$3> - to "N" $2-TR character('0' - max)
# <"$4"> - to "X" character(s)
# <"$5"> - string
# [$6] - mode('0' - strip all leading whitespace characters,
#             '1' - strip all trailing whitespace characters,
#             '2' - strip all leading/trailing whitespace characters)
# [$7] - mode('3' - keep $2,
#             '4' - keep $4,
#             '5' - keep $2/$4)
# [$8] - mode('6' - verify the expansion)
#
# Returns:
# (0) substring | incorrect substring ($1/$3 > $2/$4)
# (1) empty <unspecified/incorrect> expansion
# (2) unspecified <empty/incorrect> expansion
#
# Returns (mode '6'):
# (0) substring
# (1) unspecified expansion ($2 is the last character by the given ruleset)
# (2) unspecified expansion (! $2)
# (3) incorrect expansion ($1 > $2)
# (4) empty expansion ($2..$4)
# (5) unspecified expansion (! $4)
# (6) incorrect expansion ($3 > $4)
#
ltr_substr1() {
    case $#:$7$6 in
        8:*|7:6*|6:6)
            case $1 in
                0)
                    case "$5" in
                        *"$2") return 1 ;;
                        *"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    i="${5##*"$2"}"
                ;;
                *)
                    case $1"$5" in
                        $1*"$2"*"$2"*) : ;;
                        1*"$2") return 1 ;;
                        $1*"$2"*) : ;;
                        *) return 2 ;;
                    esac

                    x=0 && i="$5"
                    until [ $x -eq $1 ]; do
                        i="${i#*"$2"}"

                        case "$i" in
                            *"$2"*"$2"*) : ;;
                            *"$2") [ $((x + 2)) -eq $1 ] && return 1 ;;
                            *"$2"*) : ;;
                            *) [ $((x + 1)) -eq $1 ] || return 3 ;;
                        esac

                        x=$((x + 1))
                    done
                ;;
            esac

            case $3 in
                0)
                    case "$i" in
                        *"$4"*"$4"*) : ;;
                        "$4"*) return 4 ;;
                        *"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    i="${i%"$4"*}"
                ;;
                *)
                    case $3"$i" in
                        1"$4"*) return 4 ;;
                        $3*"$4"*) : ;;
                        *) return 5 ;;
                    esac

                    x=0 && ii="$i"
                    until [ $x -eq $3 ]; do
                        i="${i#*"$4"}"

                        case "$i" in
                            *"$4"*) : ;;
                            *) [ $((x + 1)) -eq $3 ] || return 6 ;;
                        esac

                        x=$((x + 1))
                    done

                    case ":$i" in
                        :) i="${ii%"$4"}" ;;
                        *) i="${ii%"$4""$i"}" ;;
                    esac
                ;;
            esac
        ;;
        *)
            case $1 in
                0)
                    i="${5##*"$2"}"
                ;;
                *)
                    x=0 && i="$5"
                    until [ $x -eq $1 ]; do
                        i="${i#*"$2"}"
                        x=$((x + 1))
                    done
                ;;
            esac

            [ "$i" = "$5" ] && return 2
            iii="$i"

            case $3 in
                0)
                    i="${i%"$4"*}"
                ;;
                *)
                    x=0 && ii="$i"
                    until [ $x -eq $3 ]; do
                        i="${i#*"$4"}"
                        x=$((x + 1))
                    done
                    i="${ii%"$4""$i"}"
                ;;
            esac

            [ "$i" = "$iii" ] && return 2
        ;;
    esac

    [ "$i" ] || return 1

    case $6 in
        0)
            i="${i#${i%%[![:space:]]*}}"
        ;;
        1)
            i="${i%${i##*[![:space:]]}}"
        ;;
        2)
            i="${i#${i%%[![:space:]]*}}"
            i="${i%${i##*[![:space:]]}}"
        ;;
    esac

    case $7$6 in
        *3*) i="$2$i" ;;
        *4*) i="$i$4" ;;
        *5*) i="$2$i$4" ;;
    esac

    printf "%s" "$i"
}

# Description:
# Parse the lines of a file
#
# Parameters:
# <"$1"> - file
# [$2] - mode('1' - add one leading/trailing whitespace character,
#             '2' - add two leading/trailing whitespace characters,
#             '3' - skip empty lines,
#             '4' - strip trailing/leading whitespace characters)
# ["$3"] - mode("5 N" - stop parsing further than specified "N" line)
#
# Returns:
# (0) output | empty output (file) | empty output (by the given ruleset)
# (1) not a file | file does not exist
# (2) file access error
#
# Caveats:
# 1. NULL character.
# 2. Reading /proc is unreliable.
#
parse() {
    [ -f "$1" ] || return 1
    [ -r "$1" ] || return 2

    case $#:"$3$2" in
        2:5*) x=0; i="${2#??}" ;;
        3:5*1|3:5*2|3:5*3|3:5*4) x=0; i="${3#??}" ;;
    esac

    case $#:"$3$2" in
        1:)
            while IFS= read -r LINE; do
                printf "%s\n" "$LINE"
            done < "$1"
        ;;
        2:1)
            while IFS= read -r LINE; do
                printf " %s \n" "$LINE"
            done < "$1"
        ;;
        2:2)
            while IFS= read -r LINE; do
                printf "  %s  \n" "$LINE"
            done < "$1"
        ;;
        2:3)
            while IFS= read -r LINE; do
                case ":$LINE" in :) : ;; *) printf "%s\n" "$LINE" ;; esac
            done < "$1"
        ;;
        2:4)
            while read -r LINE; do
                printf "%s\n" "$LINE"
            done < "$1"
        ;;
        2:5*)
            while IFS= read -r LINE; do
                x=$((x + 1))
                case $x in $i) break ;; esac
                printf "%s\n" "$LINE"
            done < "$1"
        ;;
        3:5*1)
            while IFS= read -r LINE; do
                x=$((x + 1))
                case $x in $i) break ;; esac
                printf " %s \n" "$LINE"
            done < "$1"
        ;;
        3:5*2)
            while IFS= read -r LINE; do
                x=$((x + 1))
                case $x in $i) break ;; esac
                printf "  %s  \n" "$LINE"
            done < "$1"
        ;;
        3:5*3)
            while IFS= read -r LINE; do
                x=$((x + 1))
                case $x in $i) break ;; esac
                case ":$LINE" in :) : ;; *) printf "%s\n" "$LINE" ;; esac
            done < "$1"
        ;;
        3:5*4)
            while read -r LINE; do
                x=$((x + 1))
                case $x in $i) break ;; esac
                printf "%s\n" "$LINE"
            done < "$1"
        ;;
    esac

    case $#:"$3$2" in
        1:|2:3|2:4|2:5*|3:5*3|3:5*4)
            printf "%s" "$LINE"
        ;;
        2:1|3:5*1)
            case ":$LINE" in :) : ;; *) printf " %s " "$LINE" ;; esac
        ;;
        2:2|3:5*2)
            case ":$LINE" in :) : ;; *) printf "  %s  " "$LINE" ;; esac
        ;;
    esac
}

# Description:
# Print specific line in file
#
# Parameters:
# <$1> - line number
# <"$2"> - file
#
# Returns:
# (0) line's content | line empty
# (1) line does not exist
# (2) not a file | file does not exist
# (3) file access error
#
# Caveats:
# 1. NULL character.
# 2. Reading /proc is unreliable.
#
pline() {
    x=0

    [ -f "$2" ] || return 2
    [ -r "$2" ] || return 3

    while read -r LINE; do
        x=$((x + 1))
        case $x in $1) printf "%s" "$LINE"; return 0 ;; esac
    done < "$2"

    case $((x + 1)) in $1) printf "%s" "$LINE"; return 0 ;; esac

    return 1
}

# Description:
# Get N attribute in the lock file
#
# Parameters:
# <$1> - N
#
# Returns:
# (0) attribute
# (1) attribute does not exist
#
_alock_get() {
    x=$(($1 + $1 - 1))
    i=$(pline 1 "$ALOCK")

    ltr_substr1 $x '@' 1 '@' "$i" 6 || return 1
}

# Description:
# Check if an attribute exists in the lock file
#
# Parameters:
# <"$1"> - attribute
#
# Returns:
# (0) match
# (1) no match
# (2) invalid attribute
#
_alock_test() {
    case "$1" in
        *"@"*) return 2 ;;
    esac

    i=$(pline 1 "$ALOCK")

    grep_str "@$1@" "$i" || return 1
}

# Description:
# Return attribute format for the lock file
#
# Parameters:
# <"$1"> - attribute
#
# Returns:
# (0) format
# (1) invalid attribute
#
_alock_write() {
    case "$1" in
        *"@"*) return 1 ;;
    esac

    printf "@%s@ " "$1"
}

# Description:
# Check if a merge is in progress
#
# Returns:
# (0) yes
# (1) no
#
_in_merge() {
    git merge HEAD > /dev/null 2>&1 && return 1 || return 0
}

_admerge() {
    case ":$ncolor$NO_COLOR" in
        :)
            ES_inf="\033[1;37m"
            ES_res="\033[0m"

            err() { err_clr "$@"; }
            git() { command git -c color.ui=always "$@"; }
        ;;
        *)
            ES_inf=
            ES_res=

            git() { command git -c color.ui=never "$@"; }
        ;;
    esac

    hash git > /dev/null 2>&1
}

admerge_env() {
    OBR=$(git symbolic-ref --short HEAD 2> /dev/null)
    ALOCK="$PWD"/.git/admerge_lock
    AMSG="$PWD"/.git/admerge_msg
    CDIFF_NEW="$OBR..$BRANCH"
    CDIFF_ALL="$OBR...$BRANCH"
}

admerge_check() {
    [ "$OBR" ] || err 2 "Failed to identify current branch. (not in .git dir?)"
    [ -f "$ALOCK" ] && err 2 "A merge is already in progress. ($ALOCK)"
    [ -f "$AMSG" ] && rm -f "$AMSG"
}

admerge_lock() {
    printf " "

    _alock_write "$BRANCH"

    [ "$soff" ] && _alock_write "s"
    [ "$gsign" ] && _alock_write "S"

    echo " "
} >> "$ALOCK"

admerge_msg() {
    printf "Merge '%s' into '%s'\n\n" "$BRANCH" "$OBR"

    TMP=$(git rev-list --count $CDIFF_NEW 2> /dev/null)
    [ "$TMP" ] && printf "Summary of commits (%d):\n" "$TMP"
    TMP=$(git log --oneline $CDIFF_NEW 2> /dev/null)
    [ "$TMP" ] && printf "%s\n" "$TMP"

    if [ "$gver" ]; then
        TMP=$(git --version 2> /dev/null)
        [ "$TMP" ] && printf "\n%s\n" "$TMP"
    fi
} >> "$AMSG"

admerge_work() {
    gitm_args="--no-ff --no-commit $BRANCH"
    gitc_args="-eF $AMSG --no-edit"

    if [ -r "$ALOCK" ]; then
        _alock_test "s" && gitc_args="--signoff ${gitc_args}"
        _alock_test "S" && gitc_args="--gpg-sign ${gitc_args}"
    fi
}

admerge_exec() {
    if ! git merge ${gitm_args}; then
        if _in_merge; then
            exit 1
        else
            RC=1 && return 1
        fi
    fi

    # Return code of git will not be reliable on a literal "HEAD" merge,
    # therefore the merge check above is unreliable; do a merge check now --
    # again -- to abort prematurely if we are not in a merge.
    _in_merge || return 0

    git commit ${gitc_args} || exit $?
}

admerge_post() {
    rm -f "$ALOCK" "$AMSG"
}

admerge_abort() {
    admerge_env;

    [ "$OBR" ] || err 2 "Failed to identify current branch. (not in .git dir?)"
    [ -f "$ALOCK" ] || err 2 "No lock file found. (no merge in progress?)"

    if ! git merge --abort; then
        _in_merge && exit 1
    fi

    admerge_post;
}

admerge_continue() {
    admerge_env;

    [ "$OBR" ] || err 2 "Failed to identify current branch. (not in .git dir?)"
    [ -f "$ALOCK" ] || err 2 "No lock file found. (no merge in progress?)"

    admerge_work;

    git commit ${gitc_args} || exit $?

    admerge_post;
}

admerge_status() {
    admerge_env;

    [ "$OBR" ] || err 2 "Failed to identify current branch. (not in .git dir?)"
    [ -f "$ALOCK" ] || err 2 "No lock file found. (no merge in progress?)"

    printf "%bOur branch: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$OBR" \
           "${ES_inf}" "${ES_res}"
    printf "%bTheir branch: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$(_alock_get 1)" \
           "${ES_inf}" "${ES_res}"

    printf "%bLock file location: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$ALOCK" \
           "${ES_inf}" "${ES_res}"
    printf "%bLock file content: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$(pline 1 "$ALOCK")" \
           "${ES_inf}" "${ES_res}"

    printf "%bCommit message file location: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$AMSG" \
           "${ES_inf}" "${ES_res}"
    printf "%bCommit message file content: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$(parse "$AMSG")" \
           "${ES_inf}" "${ES_res}"

    printf "%bStatus of files: [%b\n%s\n%b]%b\n" \
           "${ES_inf}" "${ES_res}" \
           "$(git status -s)" \
           "${ES_inf}" "${ES_res}"
}

admerge() {
    _admerge;
    admerge_env;
    admerge_check;
    admerge_lock;
    admerge_msg;
    admerge_work;
    admerge_exec;
    admerge_post;
}

main_functions() {
    # Description:
    # Within single quotes escape single quote(s) in string
    #
    # Parameters:
    # <"$1"+> - string
    #
    # Returns:
    # (0) escaped string | string
    #
    esc_sq() {
        case ":$1" in :) return 0 ;; esac

        case "$1" in
            *"'"*)
                ii="${1%%\'*}'\\''"
                i="${ii}${1#*\'}"

                while :; do case "$i" in
                    "$ii"*"'"*)
                        iii="${i#*"$ii"}" && iii="${iii%%\'*}"
                        i="${ii}${iii}'\\''${i#*"${ii}${iii}"\'}"
                        ii="${ii}${iii}'\\''"
                    ;;
                    *)
                        break
                    ;;
                esac done
            ;;
            *)
                i="$1"
            ;;
        esac

        printf "'%s'" "$i"; shift

        while [ "$1" ]; do
            case "$1" in
                *"'"*) : ;;
                *) printf " '%s'" "$1"; shift && continue ;;
            esac

            ii="${1%%\'*}'\\''"
            i="${ii}${1#*\'}"

            while :; do case "$i" in
                "$ii"*"'"*)
                    iii="${i#*"$ii"}" && iii="${iii%%\'*}"
                    i="${ii}${iii}'\\''${i#*"${ii}${iii}"\'}"
                    ii="${ii}${iii}'\\''"
                ;;
                *)
                    break
                ;;
            esac done

            printf " '%s'" "$i"; shift
        done
    }

    # Description:
    # Signify invalid operand count (min)[0>X]
    #
    opd_min() {
        set -- "${0##*/}"
        printf "%s: No operand specified.\n" "$1" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[X>1]
    #
    # Parameters:
    # <"$1"> - count
    #
    opd_cmax() {
        set -- "${0##*/}" "$1"
        printf "%s: Too many operands: %d\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid operand count (max)[2>1]
    #
    # Parameters:
    # <"$1"> - first operand
    # <"$2"> - second operand
    #
    opd_max() {
        set -- "${0##*/}" "$1" "$2"
        printf "%s: Too many operands: '[%s]; [%s]'\n" "$1" "$2" "$3" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify invalid option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_invalid() {
        set -- "${0##*/}" "$1"
        printf "%s: Invalid option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unknown (*) option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unknown() {
        set -- "${0##*/}" "$1"
        printf "%s: Unknown option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Signify unrecognized ('--') option
    #
    # Parameters:
    # <"$1"> - option
    #
    opt_unrecognized() {
        set -- "${0##*/}" "$1"
        printf "%s: Unrecognized option: '%s'\n" "$1" "$2" 1>&2
        printf "%s: Try '%s --help' for more information.\n" "$1" "$1" 1>&2
    }

    # Description:
    # Return 0 if complex (arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # <"$ii"> - option argument
    # <"$n"> - shift count
    #
    copt() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac
        ;;
        esac

        case "$ii:$i " in
            :"$1 ")
                printf "%s: Option '%s' requires an argument.\n" \
                       "${0##*/}" "$1" 1>&2
                printf "%s: Try '%s --help' for more information.\n" \
                       "${0##*/}" "${0##*/}" 1>&2
                exit 2
           ;;
        esac

        case "$i" in
        "--"*)
            case "$i " in
                "$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1 ")
                    i=; n=2
                    return 0
                ;;
                "$1="*)
                    ii="${i#"$1"=}"; i=; n=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$i " in
                "$1 ")
                    i=; n=2
                    return 0
                ;;
                "$1"*)
                    ii="${i#"$1"}"; i=; n=1
                    return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if perhaps complex (arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    # Provides:
    # ["$ii"] - option argument
    # <"$n"> - shift count
    #
    copt_optional() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    i=; ii=; n=1
                    return 0
                ;;
                "$1="*)
                    ii="${i#"$1"=}"; i=; n=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1")
                    i=; ii=; n=1
                    return 0
                ;;
                "$1"*)
                    ii="${i#"$1"}"; i=; n=1
                    return 0
                ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific complex (arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # <"$ii"> - option argument
    # <"$n"> - shift count
    #
    scopt() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$ii:$i " in
                :"$1 ")
                    printf "%s: Option '%s' requires an argument.\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$ii:$1= ")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$ii:$1 ")
                    i=; n=2
                    return 0
                ;;
                "$ii:$1="*)
                    ii="${i#"$1"=}"; i=; n=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if specific perhaps complex (arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    # Provides:
    # ["$ii"] - option argument
    # <"$n"> - shift count
    #
    scopt_optional() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$i" in
                "$1=")
                    printf "%s: Invalid argument specification for: '%s'\n" \
                           "${0##*/}" "$1" 1>&2
                    printf "%s: Try '%s --help' for more information.\n" \
                           "${0##*/}" "${0##*/}" 1>&2
                    exit 2
                ;;
                "$1")
                    i=; ii=; n=1
                    return 0
                ;;
                "$1="*)
                    ii="${i#"$1"=}"; i=; n=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }

    # Description:
    # Return 0 if simple (!arg) option in option holder [$i]
    #
    # Parameters (<1+>):
    # ["$1"] - -*
    # ["$2"] - --*
    #
    sopt() {
        case ":$i" in :) return 1 ;; esac

        case "$i" in
        "--"*)
            case "$1:$2" in
                "--"*":$2") : ;;
                "$1:--"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1")
                    i=; n=1
                    return 0
                ;;
            esac
        ;;
        "-"*)
            case "$1:$2" in
                "-"*":$2") : ;;
                "$1:-"*) set -- "$2" ;;
                *) return 1 ;;
            esac

            case "$i" in
                "$1"*)
                    case ":$optind" in
                        :) optind="@$1@" ;;
                        *) optind="$optind @$1@" ;;
                    esac

                    i="-${i#??}"; n=1
                    return 0
               ;;
            esac
        ;;
        esac

        return 1
    }

    # Description:
    # Return 0 if specific simple (!arg) option in option holder [$i]
    #
    # Parameters:
    # <"$1"+> - *
    #
    ssopt() {
        case ":$i" in :) return 1 ;; esac

        while [ "$1" ]; do
            case "$i" in
                "$1")
                    i=; n=1
                    return 0
                ;;
                *)
                    shift
                ;;
            esac
        done

        return 1
    }
}

# Description:
# Reorder positional parameters (string priority = LIFO)
#
# Parameters:
# <$1> - mode('0' - normal operation,
#             '1' - respect end of options)
# <"$2"+> - string
# <$3> - --
# <"$4"> - $@
#
# Provides:
# ["$i"] - string to evaluate (eval set -- "$i")
#
main_sargs_ro() {
    iii=$1; shift

    ii=$(
        esc_sq "$1"; shift

        while :; do case "$1" in
            --) shift && break ;;
            *) printf " "; esc_sq "$1"; shift ;;
        esac done
    )

    while :; do case "$1" in
        --) shift && break ;;
        *) shift ;;
    esac done

    case ":$*" in :) i=; return 0 ;; esac

    set -- "$(esc_sq "$@")"; i="$1"
    eval set -- "$ii"

    case $iii in
        0)
            while [ "$1" ]; do
                ii="$1"

                case "$ii" in
                    *"'"*) ii=$(esc_sq "$ii") ;;
                    *) ii="'$ii'" ;;
                esac

                case ":$i" in
                    :"$ii"*) : ;;
                    *"$ii") i="$ii ${i%% "$ii"*}${i#*"$ii"}" ;;
                    *"$ii"*) i="$ii ${i%%"$ii"*}${i#*"$ii" }" ;;
                esac

                shift
            done
        ;;
        1)
            case "$i" in
                "'--'"*) return 0 ;;
            esac

            while [ "$1" ]; do
                ii="$1"

                case "$ii" in
                    *"'"*) ii=$(esc_sq "$ii") ;;
                    *) ii="'$ii'" ;;
                esac

                case "$i" in
                    *"'--'"*)
                        iii="${i%% "'--'"*}"

                        case ":$iii" in
                            :"$ii"*) : ;;
                            *"$ii") i="$ii ${i%% "$ii"*}${i#*"$ii"}" ;;
                            *"$ii"*) i="$ii ${i%%"$ii"*}${i#*"$ii" }" ;;
                        esac
                    ;;
                    *)
                        case ":$i" in
                            :"$ii"*) : ;;
                            *"$ii") i="$ii ${i%% "$ii"*}${i#*"$ii"}" ;;
                            *"$ii"*) i="$ii ${i%%"$ii"*}${i#*"$ii" }" ;;
                        esac
                    ;;
                esac

                shift
            done
        ;;
    esac
}

# Description:
# Substitute the function call with script options
#
# Parameters:
# <"$1"> - mode('0' - print standard ('-'; '--') utility options,
#               '1' - print miscellaneous (*) options)
#
main_options() {
    case $1 in
    0)
        sopt "--no-color" && { ncolor=1; }
        sopt "-s" "--sign-off" && { soff=1; }
        sopt "-S" "--gpg-sign" && { gsign=1; }
        sopt "-v" "--git-version" && { gver=1; }
    ;;
    1)
        ssopt "a" "abort" && { _admerge; admerge_abort; exit 0; }
        ssopt "c" "continue" && { _admerge; admerge_continue; exit 0; }
        ssopt "s" "status" && { _admerge; admerge_status; exit 0; }
    ;;
    esac
}

main() {
    # For practical reasons, unset conditional variables if they exist
    # > special:
    unset RC BRANCH
    # > options:
    unset ncolor soff gsign gver

    # Source common functions
    main_functions;

    # Reorder the positional parameters if needed
    #  > to prioritize specific options first
    main_sargs_ro 1 "--no-color" -- "$@"
    [ "$i" ] && eval set -- "$i"

    # Parse options
    while [ "$1" ]; do
        # Simulate global $N (positional parameters) shift
        #  > option functions modify when appropriate
        n=1

        # Simulate global $1/$2 (option/argument) handling
        #  > option functions modify when appropriate
        i="$1"; ii="$2"

        # Parse standard options
        #  > required to parse them first
        ssopt "-" && { opt_invalid "$1"; exit 2; }
        ssopt "--" && { shift && break; }
        ssopt "--help" && { usage; exit 0; }
        ssopt "--version" && { version; exit 0; }

        # Loop on the option holder until fully parsed
        #  > as we might need to loop on its characters
        while [ "$i" ]; do
            unset optind

            case "$i" in
                "-"*) main_options 0 ;;
                *) main_options 1 ;;
            esac

            case ":$i" in
            :)
                :
            ;;
            :"--"*)
                opt_unrecognized "$i"; exit 2
            ;;
            :"-"*)
                case ":$optind" in
                    :) opt_invalid "${i%"${i#??}"}"; exit 2 ;;
                esac

                case ${#i} in
                    1) unset optind && break ;;
                esac
            ;;
            *)
                case ":$BRANCH" in
                    :) BRANCH="$i" ;;
                    *) opd_max "$BRANCH" "$i"; exit 2 ;;
                esac

                break
            ;;
            esac
        done

        # Move on positional parameters
        #  > either with default value or with option value
        shift $n
    done

    # Parse operands
    while [ "$1" ]; do
        i="$1"

        case ":$BRANCH" in
            :) BRANCH="$i" ;;
            *) opd_max "$BRANCH" "$i"; exit 2 ;;
        esac

        shift
    done

    # Here and no branch specified = bad input
    case ":$BRANCH" in
        :) opd_min; exit 2 ;;
    esac

    # Execute the core function
    admerge;

    # Check if RC is set, otherwise explicit success
    [ "$RC" ] && return $RC || return 0
}

main "$@"
